<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>万年水的博客</title><meta name=keywords content><meta name=description content="第15篇：OpenID Connect (OIDC)：在OAuth 2.0之上构建身份认证层
在前面的文章中，我们深入探讨了OAuth 2.0，了解到它是一个强大的授权框架，解决了“客户端应用如何安全地访问用户资源”的问题。然而，OAuth 2.0本身并不直接提供身份认证（Authentication） 功能，也就是说，它无法直接回答“当前登录的用户是谁”这个问题。
在实际应用中，尤其是在需要单点登录（SSO）的场景下，应用不仅需要获取用户的授权去访问资源，更需要确认用户的身份。这就是OpenID Connect (OIDC) 出现的背景。OIDC巧妙地构建在OAuth 2.0之上，为我们提供了一个简单、可互操作的身份认证层。
1. OIDC与OAuth 2.0的关系：授权之上的身份认证
OpenID Connect不是一个全新的协议，它是一个基于OAuth 2.0的身份认证层。可以这样理解：

OAuth 2.0： 是授权协议，目标是让第三方应用获得访问用户资源的权限。它回答的是“你（客户端）能替我（用户）做什么？”
OpenID Connect： 是身份认证协议，目标是验证用户的身份，并获取用户的基本资料（User Profile）。它回答的是“当前登录的用户是谁？”

OIDC的精髓在于，它利用了OAuth 2.0的授权流程（特别是授权码模式）来安全地分发代表用户身份的令牌。 当一个客户端（通常称为依赖方，Relying Party, RP）需要验证用户身份时，它会向OpenID Provider (OP)（即OAuth 2.0中的授权服务器）发起一个OAuth 2.0授权请求，OP在用户认证和授权后，除了返回OAuth 2.0的访问令牌（Access Token），还会返回一个额外的令牌——ID Token，其中包含了用户的身份信息。
这种关系使得OIDC既继承了OAuth 2.0的灵活性和安全性，又在其上增加了标准的身份认证机制，从而非常适合现代Web和移动应用的单点登录（SSO）场景。
2. ID Token详解：用户的数字身份证
ID Token是OpenID Connect的核心。它是一个JSON Web Token (JWT)，包含了关于用户认证事件和用户身份的关键信息。对于依赖方（RP）来说，ID Token就是用户的数字身份证。
2.1 JWT结构回顾
JWT通常由三部分组成，用点（.）分隔：Header.Payload.Signature。

Header（头部）： 声明令牌的类型（JWT）和所使用的签名算法（如HS256、RS256）。
Payload（负载/内容）： 包含了一组声明（Claims），即关于实体（通常是用户）和额外数据的陈述。这是ID Token真正包含身份信息的部分。
Signature（签名）： 用于验证令牌的完整性，确保令牌在传输过程中没有被篡改。

2.2 ID Token中的核心Claims
ID Token的Payload中包含了一系列标准化的Claims（声明），这些声明提供了用户的身份信息和认证上下文。

iss (Issuer)： 必选。ID Token的颁发者，通常是OpenID Provider的URL。RP会验证此值。
sub (Subject)： 必选。主题标识符，是OP为此用户分配的唯一标识。在OP的上下文中，此值在所有客户端中对该用户都是唯一的且不可重新分配。
aud (Audience)： 必选。ID Token的接收方，即依赖方（RP）的client_id。RP会验证此值，确保令牌是为其自身颁发的。
exp (Expiration Time)： 必选。JWT的过期时间戳。RP会检查此值，拒绝过期的令牌。
iat (Issued At)： 必选。JWT的签发时间戳。
auth_time (Authentication Time)： 可选。用户进行认证的时间。RP可以使用此值来判断用户上次认证的时间是否满足其安全策略。
nonce： 可选，但强烈推荐在授权码模式和隐式模式中使用。一个由RP生成，在认证请求中发送到OP，并在ID Token中返回的随机值。用于防止重放攻击和CSRF攻击。RP会验证此值是否与请求时发送的一致。
azp (Authorized Party)： 可选，但推荐在某些场景下使用。表示授权令牌的客户端ID，用于RP验证。
amr (Authentication Methods References)： 可选。指示用户认证时使用的认证方法列表（如pwd密码、mfa多因素认证、face面部识别等）。
acr (Authentication Context Class Reference)： 可选。指示用户认证的上下文级别或强度，例如，LoA2低安全级别，LoA3高安全级别。
c_hash (Code Hash) / at_hash (Access Token Hash)： 可选，用于隐式模式和混合模式，用于客户端验证授权码或访问令牌是否与ID Token相关联，防止令牌注入攻击。

2.3 ID Token的验证
依赖方（RP）收到ID Token后，必须对其进行严格验证，才能信任其中的身份信息："><meta name=author content><link rel=canonical href=https://bsong2015.github.io/blog/posts/technology/15-%E7%AC%AC15%E7%AF%87openid-connect-oidc%E5%9C%A8oauth-2.0%E4%B9%8B%E4%B8%8A%E6%9E%84%E5%BB%BA%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%B1%82/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://bsong2015.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bsong2015.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bsong2015.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://bsong2015.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://bsong2015.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://bsong2015.github.io/blog/posts/technology/15-%E7%AC%AC15%E7%AF%87openid-connect-oidc%E5%9C%A8oauth-2.0%E4%B9%8B%E4%B8%8A%E6%9E%84%E5%BB%BA%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%B1%82/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://bsong2015.github.io/blog/posts/technology/15-%E7%AC%AC15%E7%AF%87openid-connect-oidc%E5%9C%A8oauth-2.0%E4%B9%8B%E4%B8%8A%E6%9E%84%E5%BB%BA%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%B1%82/"><meta property="og:site_name" content="万年水的博客"><meta property="og:title" content="万年水的博客"><meta property="og:description" content="第15篇：OpenID Connect (OIDC)：在OAuth 2.0之上构建身份认证层 在前面的文章中，我们深入探讨了OAuth 2.0，了解到它是一个强大的授权框架，解决了“客户端应用如何安全地访问用户资源”的问题。然而，OAuth 2.0本身并不直接提供身份认证（Authentication） 功能，也就是说，它无法直接回答“当前登录的用户是谁”这个问题。
在实际应用中，尤其是在需要单点登录（SSO）的场景下，应用不仅需要获取用户的授权去访问资源，更需要确认用户的身份。这就是OpenID Connect (OIDC) 出现的背景。OIDC巧妙地构建在OAuth 2.0之上，为我们提供了一个简单、可互操作的身份认证层。
1. OIDC与OAuth 2.0的关系：授权之上的身份认证 OpenID Connect不是一个全新的协议，它是一个基于OAuth 2.0的身份认证层。可以这样理解：
OAuth 2.0： 是授权协议，目标是让第三方应用获得访问用户资源的权限。它回答的是“你（客户端）能替我（用户）做什么？” OpenID Connect： 是身份认证协议，目标是验证用户的身份，并获取用户的基本资料（User Profile）。它回答的是“当前登录的用户是谁？” OIDC的精髓在于，它利用了OAuth 2.0的授权流程（特别是授权码模式）来安全地分发代表用户身份的令牌。 当一个客户端（通常称为依赖方，Relying Party, RP）需要验证用户身份时，它会向OpenID Provider (OP)（即OAuth 2.0中的授权服务器）发起一个OAuth 2.0授权请求，OP在用户认证和授权后，除了返回OAuth 2.0的访问令牌（Access Token），还会返回一个额外的令牌——ID Token，其中包含了用户的身份信息。
这种关系使得OIDC既继承了OAuth 2.0的灵活性和安全性，又在其上增加了标准的身份认证机制，从而非常适合现代Web和移动应用的单点登录（SSO）场景。
2. ID Token详解：用户的数字身份证 ID Token是OpenID Connect的核心。它是一个JSON Web Token (JWT)，包含了关于用户认证事件和用户身份的关键信息。对于依赖方（RP）来说，ID Token就是用户的数字身份证。
2.1 JWT结构回顾 JWT通常由三部分组成，用点（.）分隔：Header.Payload.Signature。
Header（头部）： 声明令牌的类型（JWT）和所使用的签名算法（如HS256、RS256）。 Payload（负载/内容）： 包含了一组声明（Claims），即关于实体（通常是用户）和额外数据的陈述。这是ID Token真正包含身份信息的部分。 Signature（签名）： 用于验证令牌的完整性，确保令牌在传输过程中没有被篡改。 2.2 ID Token中的核心Claims ID Token的Payload中包含了一系列标准化的Claims（声明），这些声明提供了用户的身份信息和认证上下文。
iss (Issuer)： 必选。ID Token的颁发者，通常是OpenID Provider的URL。RP会验证此值。 sub (Subject)： 必选。主题标识符，是OP为此用户分配的唯一标识。在OP的上下文中，此值在所有客户端中对该用户都是唯一的且不可重新分配。 aud (Audience)： 必选。ID Token的接收方，即依赖方（RP）的client_id。RP会验证此值，确保令牌是为其自身颁发的。 exp (Expiration Time)： 必选。JWT的过期时间戳。RP会检查此值，拒绝过期的令牌。 iat (Issued At)： 必选。JWT的签发时间戳。 auth_time (Authentication Time)： 可选。用户进行认证的时间。RP可以使用此值来判断用户上次认证的时间是否满足其安全策略。 nonce： 可选，但强烈推荐在授权码模式和隐式模式中使用。一个由RP生成，在认证请求中发送到OP，并在ID Token中返回的随机值。用于防止重放攻击和CSRF攻击。RP会验证此值是否与请求时发送的一致。 azp (Authorized Party)： 可选，但推荐在某些场景下使用。表示授权令牌的客户端ID，用于RP验证。 amr (Authentication Methods References)： 可选。指示用户认证时使用的认证方法列表（如pwd密码、mfa多因素认证、face面部识别等）。 acr (Authentication Context Class Reference)： 可选。指示用户认证的上下文级别或强度，例如，LoA2低安全级别，LoA3高安全级别。 c_hash (Code Hash) / at_hash (Access Token Hash)： 可选，用于隐式模式和混合模式，用于客户端验证授权码或访问令牌是否与ID Token相关联，防止令牌注入攻击。 2.3 ID Token的验证 依赖方（RP）收到ID Token后，必须对其进行严格验证，才能信任其中的身份信息："><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="第15篇：OpenID Connect (OIDC)：在OAuth 2.0之上构建身份认证层
在前面的文章中，我们深入探讨了OAuth 2.0，了解到它是一个强大的授权框架，解决了“客户端应用如何安全地访问用户资源”的问题。然而，OAuth 2.0本身并不直接提供身份认证（Authentication） 功能，也就是说，它无法直接回答“当前登录的用户是谁”这个问题。
在实际应用中，尤其是在需要单点登录（SSO）的场景下，应用不仅需要获取用户的授权去访问资源，更需要确认用户的身份。这就是OpenID Connect (OIDC) 出现的背景。OIDC巧妙地构建在OAuth 2.0之上，为我们提供了一个简单、可互操作的身份认证层。
1. OIDC与OAuth 2.0的关系：授权之上的身份认证
OpenID Connect不是一个全新的协议，它是一个基于OAuth 2.0的身份认证层。可以这样理解：

OAuth 2.0： 是授权协议，目标是让第三方应用获得访问用户资源的权限。它回答的是“你（客户端）能替我（用户）做什么？”
OpenID Connect： 是身份认证协议，目标是验证用户的身份，并获取用户的基本资料（User Profile）。它回答的是“当前登录的用户是谁？”

OIDC的精髓在于，它利用了OAuth 2.0的授权流程（特别是授权码模式）来安全地分发代表用户身份的令牌。 当一个客户端（通常称为依赖方，Relying Party, RP）需要验证用户身份时，它会向OpenID Provider (OP)（即OAuth 2.0中的授权服务器）发起一个OAuth 2.0授权请求，OP在用户认证和授权后，除了返回OAuth 2.0的访问令牌（Access Token），还会返回一个额外的令牌——ID Token，其中包含了用户的身份信息。
这种关系使得OIDC既继承了OAuth 2.0的灵活性和安全性，又在其上增加了标准的身份认证机制，从而非常适合现代Web和移动应用的单点登录（SSO）场景。
2. ID Token详解：用户的数字身份证
ID Token是OpenID Connect的核心。它是一个JSON Web Token (JWT)，包含了关于用户认证事件和用户身份的关键信息。对于依赖方（RP）来说，ID Token就是用户的数字身份证。
2.1 JWT结构回顾
JWT通常由三部分组成，用点（.）分隔：Header.Payload.Signature。

Header（头部）： 声明令牌的类型（JWT）和所使用的签名算法（如HS256、RS256）。
Payload（负载/内容）： 包含了一组声明（Claims），即关于实体（通常是用户）和额外数据的陈述。这是ID Token真正包含身份信息的部分。
Signature（签名）： 用于验证令牌的完整性，确保令牌在传输过程中没有被篡改。

2.2 ID Token中的核心Claims
ID Token的Payload中包含了一系列标准化的Claims（声明），这些声明提供了用户的身份信息和认证上下文。

iss (Issuer)： 必选。ID Token的颁发者，通常是OpenID Provider的URL。RP会验证此值。
sub (Subject)： 必选。主题标识符，是OP为此用户分配的唯一标识。在OP的上下文中，此值在所有客户端中对该用户都是唯一的且不可重新分配。
aud (Audience)： 必选。ID Token的接收方，即依赖方（RP）的client_id。RP会验证此值，确保令牌是为其自身颁发的。
exp (Expiration Time)： 必选。JWT的过期时间戳。RP会检查此值，拒绝过期的令牌。
iat (Issued At)： 必选。JWT的签发时间戳。
auth_time (Authentication Time)： 可选。用户进行认证的时间。RP可以使用此值来判断用户上次认证的时间是否满足其安全策略。
nonce： 可选，但强烈推荐在授权码模式和隐式模式中使用。一个由RP生成，在认证请求中发送到OP，并在ID Token中返回的随机值。用于防止重放攻击和CSRF攻击。RP会验证此值是否与请求时发送的一致。
azp (Authorized Party)： 可选，但推荐在某些场景下使用。表示授权令牌的客户端ID，用于RP验证。
amr (Authentication Methods References)： 可选。指示用户认证时使用的认证方法列表（如pwd密码、mfa多因素认证、face面部识别等）。
acr (Authentication Context Class Reference)： 可选。指示用户认证的上下文级别或强度，例如，LoA2低安全级别，LoA3高安全级别。
c_hash (Code Hash) / at_hash (Access Token Hash)： 可选，用于隐式模式和混合模式，用于客户端验证授权码或访问令牌是否与ID Token相关联，防止令牌注入攻击。

2.3 ID Token的验证
依赖方（RP）收到ID Token后，必须对其进行严格验证，才能信任其中的身份信息："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bsong2015.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"技术实践","item":"https://bsong2015.github.io/blog/posts/technology/"},{"@type":"ListItem","position":3,"name":"","item":"https://bsong2015.github.io/blog/posts/technology/15-%E7%AC%AC15%E7%AF%87openid-connect-oidc%E5%9C%A8oauth-2.0%E4%B9%8B%E4%B8%8A%E6%9E%84%E5%BB%BA%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%B1%82/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"第15篇：OpenID Connect (OIDC)：在OAuth 2.0之上构建身份认证层 在前面的文章中，我们深入探讨了OAuth 2.0，了解到它是一个强大的授权框架，解决了“客户端应用如何安全地访问用户资源”的问题。然而，OAuth 2.0本身并不直接提供身份认证（Authentication） 功能，也就是说，它无法直接回答“当前登录的用户是谁”这个问题。\n在实际应用中，尤其是在需要单点登录（SSO）的场景下，应用不仅需要获取用户的授权去访问资源，更需要确认用户的身份。这就是OpenID Connect (OIDC) 出现的背景。OIDC巧妙地构建在OAuth 2.0之上，为我们提供了一个简单、可互操作的身份认证层。\n1. OIDC与OAuth 2.0的关系：授权之上的身份认证 OpenID Connect不是一个全新的协议，它是一个基于OAuth 2.0的身份认证层。可以这样理解：\nOAuth 2.0： 是授权协议，目标是让第三方应用获得访问用户资源的权限。它回答的是“你（客户端）能替我（用户）做什么？” OpenID Connect： 是身份认证协议，目标是验证用户的身份，并获取用户的基本资料（User Profile）。它回答的是“当前登录的用户是谁？” OIDC的精髓在于，它利用了OAuth 2.0的授权流程（特别是授权码模式）来安全地分发代表用户身份的令牌。 当一个客户端（通常称为依赖方，Relying Party, RP）需要验证用户身份时，它会向OpenID Provider (OP)（即OAuth 2.0中的授权服务器）发起一个OAuth 2.0授权请求，OP在用户认证和授权后，除了返回OAuth 2.0的访问令牌（Access Token），还会返回一个额外的令牌——ID Token，其中包含了用户的身份信息。\n这种关系使得OIDC既继承了OAuth 2.0的灵活性和安全性，又在其上增加了标准的身份认证机制，从而非常适合现代Web和移动应用的单点登录（SSO）场景。\n2. ID Token详解：用户的数字身份证 ID Token是OpenID Connect的核心。它是一个JSON Web Token (JWT)，包含了关于用户认证事件和用户身份的关键信息。对于依赖方（RP）来说，ID Token就是用户的数字身份证。\n2.1 JWT结构回顾 JWT通常由三部分组成，用点（.）分隔：Header.Payload.Signature。\nHeader（头部）： 声明令牌的类型（JWT）和所使用的签名算法（如HS256、RS256）。 Payload（负载/内容）： 包含了一组声明（Claims），即关于实体（通常是用户）和额外数据的陈述。这是ID Token真正包含身份信息的部分。 Signature（签名）： 用于验证令牌的完整性，确保令牌在传输过程中没有被篡改。 2.2 ID Token中的核心Claims ID Token的Payload中包含了一系列标准化的Claims（声明），这些声明提供了用户的身份信息和认证上下文。\niss (Issuer)： 必选。ID Token的颁发者，通常是OpenID Provider的URL。RP会验证此值。 sub (Subject)： 必选。主题标识符，是OP为此用户分配的唯一标识。在OP的上下文中，此值在所有客户端中对该用户都是唯一的且不可重新分配。 aud (Audience)： 必选。ID Token的接收方，即依赖方（RP）的client_id。RP会验证此值，确保令牌是为其自身颁发的。 exp (Expiration Time)： 必选。JWT的过期时间戳。RP会检查此值，拒绝过期的令牌。 iat (Issued At)： 必选。JWT的签发时间戳。 auth_time (Authentication Time)： 可选。用户进行认证的时间。RP可以使用此值来判断用户上次认证的时间是否满足其安全策略。 nonce： 可选，但强烈推荐在授权码模式和隐式模式中使用。一个由RP生成，在认证请求中发送到OP，并在ID Token中返回的随机值。用于防止重放攻击和CSRF攻击。RP会验证此值是否与请求时发送的一致。 azp (Authorized Party)： 可选，但推荐在某些场景下使用。表示授权令牌的客户端ID，用于RP验证。 amr (Authentication Methods References)： 可选。指示用户认证时使用的认证方法列表（如pwd密码、mfa多因素认证、face面部识别等）。 acr (Authentication Context Class Reference)： 可选。指示用户认证的上下文级别或强度，例如，LoA2低安全级别，LoA3高安全级别。 c_hash (Code Hash) / at_hash (Access Token Hash)： 可选，用于隐式模式和混合模式，用于客户端验证授权码或访问令牌是否与ID Token相关联，防止令牌注入攻击。 2.3 ID Token的验证 依赖方（RP）收到ID Token后，必须对其进行严格验证，才能信任其中的身份信息：\n","keywords":[],"articleBody":"第15篇：OpenID Connect (OIDC)：在OAuth 2.0之上构建身份认证层 在前面的文章中，我们深入探讨了OAuth 2.0，了解到它是一个强大的授权框架，解决了“客户端应用如何安全地访问用户资源”的问题。然而，OAuth 2.0本身并不直接提供身份认证（Authentication） 功能，也就是说，它无法直接回答“当前登录的用户是谁”这个问题。\n在实际应用中，尤其是在需要单点登录（SSO）的场景下，应用不仅需要获取用户的授权去访问资源，更需要确认用户的身份。这就是OpenID Connect (OIDC) 出现的背景。OIDC巧妙地构建在OAuth 2.0之上，为我们提供了一个简单、可互操作的身份认证层。\n1. OIDC与OAuth 2.0的关系：授权之上的身份认证 OpenID Connect不是一个全新的协议，它是一个基于OAuth 2.0的身份认证层。可以这样理解：\nOAuth 2.0： 是授权协议，目标是让第三方应用获得访问用户资源的权限。它回答的是“你（客户端）能替我（用户）做什么？” OpenID Connect： 是身份认证协议，目标是验证用户的身份，并获取用户的基本资料（User Profile）。它回答的是“当前登录的用户是谁？” OIDC的精髓在于，它利用了OAuth 2.0的授权流程（特别是授权码模式）来安全地分发代表用户身份的令牌。 当一个客户端（通常称为依赖方，Relying Party, RP）需要验证用户身份时，它会向OpenID Provider (OP)（即OAuth 2.0中的授权服务器）发起一个OAuth 2.0授权请求，OP在用户认证和授权后，除了返回OAuth 2.0的访问令牌（Access Token），还会返回一个额外的令牌——ID Token，其中包含了用户的身份信息。\n这种关系使得OIDC既继承了OAuth 2.0的灵活性和安全性，又在其上增加了标准的身份认证机制，从而非常适合现代Web和移动应用的单点登录（SSO）场景。\n2. ID Token详解：用户的数字身份证 ID Token是OpenID Connect的核心。它是一个JSON Web Token (JWT)，包含了关于用户认证事件和用户身份的关键信息。对于依赖方（RP）来说，ID Token就是用户的数字身份证。\n2.1 JWT结构回顾 JWT通常由三部分组成，用点（.）分隔：Header.Payload.Signature。\nHeader（头部）： 声明令牌的类型（JWT）和所使用的签名算法（如HS256、RS256）。 Payload（负载/内容）： 包含了一组声明（Claims），即关于实体（通常是用户）和额外数据的陈述。这是ID Token真正包含身份信息的部分。 Signature（签名）： 用于验证令牌的完整性，确保令牌在传输过程中没有被篡改。 2.2 ID Token中的核心Claims ID Token的Payload中包含了一系列标准化的Claims（声明），这些声明提供了用户的身份信息和认证上下文。\niss (Issuer)： 必选。ID Token的颁发者，通常是OpenID Provider的URL。RP会验证此值。 sub (Subject)： 必选。主题标识符，是OP为此用户分配的唯一标识。在OP的上下文中，此值在所有客户端中对该用户都是唯一的且不可重新分配。 aud (Audience)： 必选。ID Token的接收方，即依赖方（RP）的client_id。RP会验证此值，确保令牌是为其自身颁发的。 exp (Expiration Time)： 必选。JWT的过期时间戳。RP会检查此值，拒绝过期的令牌。 iat (Issued At)： 必选。JWT的签发时间戳。 auth_time (Authentication Time)： 可选。用户进行认证的时间。RP可以使用此值来判断用户上次认证的时间是否满足其安全策略。 nonce： 可选，但强烈推荐在授权码模式和隐式模式中使用。一个由RP生成，在认证请求中发送到OP，并在ID Token中返回的随机值。用于防止重放攻击和CSRF攻击。RP会验证此值是否与请求时发送的一致。 azp (Authorized Party)： 可选，但推荐在某些场景下使用。表示授权令牌的客户端ID，用于RP验证。 amr (Authentication Methods References)： 可选。指示用户认证时使用的认证方法列表（如pwd密码、mfa多因素认证、face面部识别等）。 acr (Authentication Context Class Reference)： 可选。指示用户认证的上下文级别或强度，例如，LoA2低安全级别，LoA3高安全级别。 c_hash (Code Hash) / at_hash (Access Token Hash)： 可选，用于隐式模式和混合模式，用于客户端验证授权码或访问令牌是否与ID Token相关联，防止令牌注入攻击。 2.3 ID Token的验证 依赖方（RP）收到ID Token后，必须对其进行严格验证，才能信任其中的身份信息：\n签名验证： 使用OP提供的公钥（通常通过OP的发现端点获取）验证ID Token的数字签名，确保令牌未被篡改。 iss验证： 确认iss声明与已知的OP URL匹配。 aud验证： 确认aud声明包含自己的client_id。 exp验证： 确认令牌未过期。 iat验证： 确认令牌的签发时间在合理范围内（防范时钟偏差）。 nonce验证： 如果在请求中发送了nonce，则验证ID Token中的nonce是否匹配。 azp验证（如存在）： 验证azp是否与自己的client_id匹配。 c_hash / at_hash验证（如适用）： 验证哈希值，确保授权码或访问令牌与ID Token的关联性。 通过这些验证步骤，RP可以高度信任ID Token中包含的用户身份信息。\n3. OIDC的核心端点：交互的桥梁 OpenID Connect定义了一系列标准化的HTTP端点，用于客户端（RP）与OpenID Provider (OP) 之间的交互。这些端点的具体URL通常可以从发现端点（Discovery Endpoint） 获取。\n3.1 授权端点（Authorization Endpoint） 作用： 这是用户进行认证和授权的入口点。客户端将用户浏览器重定向到此端点，并传递OAuth 2.0授权请求参数（如response_type、client_id、redirect_uri、scope、state、nonce等）。 URL示例： 通常以 /authorize 或 /auth 结尾，例如 https://accounts.google.com/o/oauth2/v2/auth。 返回： 认证成功后，根据response_type，OP会重定向用户浏览器到redirect_uri，并返回授权码、ID Token或访问令牌等。 3.2 令牌端点（Token Endpoint） 作用： 客户端（通常是服务器端应用）使用授权码、刷新令牌或客户端凭证来此端点交换Access Token、ID Token和Refresh Token。 URL示例： 通常以 /token 结尾，例如 https://oauth2.googleapis.com/token。 通信： 通常是后端对后端的直接通信，通过HTTPS POST请求。 3.3 用户信息端点（UserInfo Endpoint） 作用： 这是一个受保护的资源API。客户端在获取到Access Token后，可以使用该令牌向此端点发起请求，以获取更丰富的用户基本资料（如姓名、邮箱、头像等），这些信息通常是ID Token中未包含的。 URL示例： 通常以 /userinfo 结尾，例如 https://openidconnect.googleapis.com/v1/userinfo。 通信： 客户端携带Access Token通过HTTPS GET/POST请求访问此端点，OP验证Access Token后返回JSON格式的用户信息。 3.4 发现端点（Discovery Endpoint） 作用： 这是一个元数据端点，OP在此端点发布自己的所有配置信息，包括其他核心端点的URL、支持的response_type、scope、grant_type、JWKS（JSON Web Key Set）URI等。 URL规范： 按照OpenID Connect Discovery规范，此端点必须位于OP的Issuer URL后拼接 /.well-known/openid-configuration。例如，如果Issuer是 https://accounts.google.com，则发现端点是 https://accounts.google.com/.well-known/openid-configuration。 重要性： 使得客户端（RP）能够自动化发现OP的各项配置，无需手动配置，大大简化了集成过程。 3.5 JWKS 端点 (JSON Web Key Set Endpoint) 作用： 虽然不总是作为独立的核心端点列出，但其重要性不亚于其他。这是一个公共端点，OP在此处发布用于签名其ID Token和JWT（如访问令牌）的公钥。 URL示例： 通常在发现文档中通过 jwks_uri 字段指定，例如 https://www.googleapis.com/oauth2/v3/certs。 用途： 依赖方（RP）通过此端点获取OP的公钥，以便验证ID Token的数字签名。 总结 OpenID Connect (OIDC) 是在OAuth 2.0授权框架之上构建的，提供了一个轻量级、可互操作的身份认证层。它通过引入ID Token（一个包含用户身份信息的JWT）和一系列标准化的端点（授权、令牌、用户信息、发现、JWKS），解决了OAuth 2.0在身份认证方面的空白。\nOIDC使得第三方应用能够安全、便捷地验证用户身份并获取其基本资料，而无需直接处理用户的敏感凭证。这不仅极大地简化了单点登录（SSO）的实现，也为构建现代、安全的微服务和分布式应用提供了坚实的基础。理解OIDC的这些核心概念和端点，是你在IAM领域深入实践的关键一步。\n欢迎关注+点赞+推荐+转发\n","wordCount":"251","inLanguage":"zh","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bsong2015.github.io/blog/posts/technology/15-%E7%AC%AC15%E7%AF%87openid-connect-oidc%E5%9C%A8oauth-2.0%E4%B9%8B%E4%B8%8A%E6%9E%84%E5%BB%BA%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%B1%82/"},"publisher":{"@type":"Organization","name":"万年水的博客","logo":{"@type":"ImageObject","url":"https://bsong2015.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bsong2015.github.io/blog/ accesskey=h title="万年水的博客 (Alt + H)">万年水的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bsong2015.github.io/blog/posts/artificial-intelligence/ title=人工智能><span>人工智能</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/reading/ title=阅读><span>阅读</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/thinking-models/ title=思维模型><span>思维模型</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/thought-experiments/ title=思想实验><span>思想实验</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/personal-growth/ title=个人成长><span>个人成长</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/technology/ title=技术><span>技术</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/current-affairs/ title=时事><span>时事</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/others/ title=其它><span>其它</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent"></h1><div class=post-meta></div></header><div class=post-content><h2 id=第15篇openid-connect-oidc在oauth-20之上构建身份认证层>第15篇：OpenID Connect (OIDC)：在OAuth 2.0之上构建身份认证层<a hidden class=anchor aria-hidden=true href=#第15篇openid-connect-oidc在oauth-20之上构建身份认证层>#</a></h2><p>在前面的文章中，我们深入探讨了OAuth 2.0，了解到它是一个强大的<strong>授权框架</strong>，解决了“客户端应用如何安全地访问用户资源”的问题。然而，OAuth 2.0本身并不直接提供<strong>身份认证（Authentication）</strong> 功能，也就是说，它无法直接回答“当前登录的用户是谁”这个问题。</p><p>在实际应用中，尤其是在需要单点登录（SSO）的场景下，应用不仅需要获取用户的授权去访问资源，更需要确认用户的身份。这就是<strong>OpenID Connect (OIDC)</strong> 出现的背景。OIDC巧妙地构建在OAuth 2.0之上，为我们提供了一个简单、可互操作的身份认证层。</p><h3 id=1-oidc与oauth-20的关系授权之上的身份认证>1. OIDC与OAuth 2.0的关系：授权之上的身份认证<a hidden class=anchor aria-hidden=true href=#1-oidc与oauth-20的关系授权之上的身份认证>#</a></h3><p>OpenID Connect不是一个全新的协议，它是一个<strong>基于OAuth 2.0的身份认证层</strong>。可以这样理解：</p><ul><li><strong>OAuth 2.0：</strong> 是<strong>授权</strong>协议，目标是让第三方应用<strong>获得访问用户资源的权限</strong>。它回答的是“你（客户端）能替我（用户）做什么？”</li><li><strong>OpenID Connect：</strong> 是<strong>身份认证</strong>协议，目标是<strong>验证用户的身份</strong>，并获取用户的基本资料（User Profile）。它回答的是“当前登录的用户是谁？”</li></ul><p><strong>OIDC的精髓在于，它利用了OAuth 2.0的授权流程（特别是授权码模式）来安全地分发代表用户身份的令牌。</strong> 当一个客户端（通常称为<strong>依赖方，Relying Party, RP</strong>）需要验证用户身份时，它会向<strong>OpenID Provider (OP)</strong>（即OAuth 2.0中的授权服务器）发起一个OAuth 2.0授权请求，OP在用户认证和授权后，除了返回OAuth 2.0的访问令牌（Access Token），还会返回一个额外的令牌——<strong>ID Token</strong>，其中包含了用户的身份信息。</p><p>这种关系使得OIDC既继承了OAuth 2.0的灵活性和安全性，又在其上增加了标准的身份认证机制，从而非常适合现代Web和移动应用的单点登录（SSO）场景。</p><h3 id=2-id-token详解用户的数字身份证>2. ID Token详解：用户的数字身份证<a hidden class=anchor aria-hidden=true href=#2-id-token详解用户的数字身份证>#</a></h3><p><strong>ID Token</strong>是OpenID Connect的核心。它是一个<strong>JSON Web Token (JWT)</strong>，包含了关于用户认证事件和用户身份的关键信息。对于依赖方（RP）来说，ID Token就是用户的数字身份证。</p><h4 id=21-jwt结构回顾>2.1 JWT结构回顾<a hidden class=anchor aria-hidden=true href=#21-jwt结构回顾>#</a></h4><p>JWT通常由三部分组成，用点（.）分隔：Header.Payload.Signature。</p><ul><li><strong>Header（头部）：</strong> 声明令牌的类型（JWT）和所使用的签名算法（如HS256、RS256）。</li><li><strong>Payload（负载/内容）：</strong> 包含了一组<strong>声明（Claims）</strong>，即关于实体（通常是用户）和额外数据的陈述。这是ID Token真正包含身份信息的部分。</li><li><strong>Signature（签名）：</strong> 用于验证令牌的完整性，确保令牌在传输过程中没有被篡改。</li></ul><h4 id=22-id-token中的核心claims>2.2 ID Token中的核心Claims<a hidden class=anchor aria-hidden=true href=#22-id-token中的核心claims>#</a></h4><p>ID Token的Payload中包含了一系列标准化的<strong>Claims</strong>（声明），这些声明提供了用户的身份信息和认证上下文。</p><ul><li><strong>iss (Issuer)：</strong> 必选。ID Token的颁发者，通常是OpenID Provider的URL。RP会验证此值。</li><li><strong>sub (Subject)：</strong> 必选。主题标识符，是OP为此用户分配的唯一标识。在OP的上下文中，此值在所有客户端中对该用户都是唯一的且不可重新分配。</li><li><strong>aud (Audience)：</strong> 必选。ID Token的接收方，即依赖方（RP）的client_id。RP会验证此值，确保令牌是为其自身颁发的。</li><li><strong>exp (Expiration Time)：</strong> 必选。JWT的过期时间戳。RP会检查此值，拒绝过期的令牌。</li><li><strong>iat (Issued At)：</strong> 必选。JWT的签发时间戳。</li><li><strong>auth_time (Authentication Time)：</strong> 可选。用户进行认证的时间。RP可以使用此值来判断用户上次认证的时间是否满足其安全策略。</li><li><strong>nonce：</strong> 可选，但强烈推荐在授权码模式和隐式模式中使用。一个由RP生成，在认证请求中发送到OP，并在ID Token中返回的随机值。用于防止<strong>重放攻击</strong>和<strong>CSRF攻击</strong>。RP会验证此值是否与请求时发送的一致。</li><li><strong>azp (Authorized Party)：</strong> 可选，但推荐在某些场景下使用。表示授权令牌的客户端ID，用于RP验证。</li><li><strong>amr (Authentication Methods References)：</strong> 可选。指示用户认证时使用的认证方法列表（如pwd密码、mfa多因素认证、face面部识别等）。</li><li><strong>acr (Authentication Context Class Reference)：</strong> 可选。指示用户认证的上下文级别或强度，例如，LoA2低安全级别，LoA3高安全级别。</li><li><strong>c_hash (Code Hash) / at_hash (Access Token Hash)：</strong> 可选，用于隐式模式和混合模式，用于客户端验证授权码或访问令牌是否与ID Token相关联，防止令牌注入攻击。</li></ul><h4 id=23-id-token的验证>2.3 ID Token的验证<a hidden class=anchor aria-hidden=true href=#23-id-token的验证>#</a></h4><p>依赖方（RP）收到ID Token后，必须对其进行严格验证，才能信任其中的身份信息：</p><ol><li><strong>签名验证：</strong> 使用OP提供的公钥（通常通过OP的发现端点获取）验证ID Token的数字签名，确保令牌未被篡改。</li><li><strong>iss验证：</strong> 确认iss声明与已知的OP URL匹配。</li><li><strong>aud验证：</strong> 确认aud声明包含自己的client_id。</li><li><strong>exp验证：</strong> 确认令牌未过期。</li><li><strong>iat验证：</strong> 确认令牌的签发时间在合理范围内（防范时钟偏差）。</li><li><strong>nonce验证：</strong> 如果在请求中发送了nonce，则验证ID Token中的nonce是否匹配。</li><li><strong>azp验证（如存在）：</strong> 验证azp是否与自己的client_id匹配。</li><li><strong>c_hash / at_hash验证（如适用）：</strong> 验证哈希值，确保授权码或访问令牌与ID Token的关联性。</li></ol><p>通过这些验证步骤，RP可以高度信任ID Token中包含的用户身份信息。</p><h3 id=3-oidc的核心端点交互的桥梁>3. OIDC的核心端点：交互的桥梁<a hidden class=anchor aria-hidden=true href=#3-oidc的核心端点交互的桥梁>#</a></h3><p>OpenID Connect定义了一系列标准化的HTTP端点，用于客户端（RP）与OpenID Provider (OP) 之间的交互。这些端点的具体URL通常可以从<strong>发现端点（Discovery Endpoint）</strong> 获取。</p><h4 id=31-授权端点authorization-endpoint>3.1 授权端点（Authorization Endpoint）<a hidden class=anchor aria-hidden=true href=#31-授权端点authorization-endpoint>#</a></h4><ul><li><strong>作用：</strong> 这是用户进行认证和授权的入口点。客户端将用户浏览器重定向到此端点，并传递OAuth 2.0授权请求参数（如response_type、client_id、redirect_uri、scope、state、nonce等）。</li><li><strong>URL示例：</strong> 通常以 /authorize 或 /auth 结尾，例如 <a href=https://accounts.google.com/o/oauth2/v2/auth>https://accounts.google.com/o/oauth2/v2/auth</a>。</li><li><strong>返回：</strong> 认证成功后，根据response_type，OP会重定向用户浏览器到redirect_uri，并返回授权码、ID Token或访问令牌等。</li></ul><h4 id=32-令牌端点token-endpoint>3.2 令牌端点（Token Endpoint）<a hidden class=anchor aria-hidden=true href=#32-令牌端点token-endpoint>#</a></h4><ul><li><strong>作用：</strong> 客户端（通常是服务器端应用）使用授权码、刷新令牌或客户端凭证来此端点交换Access Token、ID Token和Refresh Token。</li><li><strong>URL示例：</strong> 通常以 /token 结尾，例如 <a href=https://oauth2.googleapis.com/token>https://oauth2.googleapis.com/token</a>。</li><li><strong>通信：</strong> 通常是后端对后端的直接通信，通过HTTPS POST请求。</li></ul><h4 id=33-用户信息端点userinfo-endpoint>3.3 用户信息端点（UserInfo Endpoint）<a hidden class=anchor aria-hidden=true href=#33-用户信息端点userinfo-endpoint>#</a></h4><ul><li><strong>作用：</strong> 这是一个受保护的资源API。客户端在获取到Access Token后，可以使用该令牌向此端点发起请求，以获取更丰富的用户基本资料（如姓名、邮箱、头像等），这些信息通常是ID Token中未包含的。</li><li><strong>URL示例：</strong> 通常以 /userinfo 结尾，例如 <a href=https://openidconnect.googleapis.com/v1/userinfo>https://openidconnect.googleapis.com/v1/userinfo</a>。</li><li><strong>通信：</strong> 客户端携带Access Token通过HTTPS GET/POST请求访问此端点，OP验证Access Token后返回JSON格式的用户信息。</li></ul><h4 id=34-发现端点discovery-endpoint>3.4 发现端点（Discovery Endpoint）<a hidden class=anchor aria-hidden=true href=#34-发现端点discovery-endpoint>#</a></h4><ul><li><strong>作用：</strong> 这是一个元数据端点，OP在此端点发布自己的所有配置信息，包括其他核心端点的URL、支持的response_type、scope、grant_type、JWKS（JSON Web Key Set）URI等。</li><li><strong>URL规范：</strong> 按照OpenID Connect Discovery规范，此端点必须位于OP的Issuer URL后拼接 /.well-known/openid-configuration。例如，如果Issuer是 <a href=https://accounts.google.com>https://accounts.google.com</a>，则发现端点是 <a href=https://accounts.google.com/.well-known/openid-configuration>https://accounts.google.com/.well-known/openid-configuration</a>。</li><li><strong>重要性：</strong> 使得客户端（RP）能够自动化发现OP的各项配置，无需手动配置，大大简化了集成过程。</li></ul><h4 id=35-jwks-端点-json-web-key-set-endpoint>3.5 JWKS 端点 (JSON Web Key Set Endpoint)<a hidden class=anchor aria-hidden=true href=#35-jwks-端点-json-web-key-set-endpoint>#</a></h4><ul><li><strong>作用：</strong> 虽然不总是作为独立的核心端点列出，但其重要性不亚于其他。这是一个公共端点，OP在此处发布用于签名其ID Token和JWT（如访问令牌）的公钥。</li><li><strong>URL示例：</strong> 通常在发现文档中通过 jwks_uri 字段指定，例如 <a href=https://www.googleapis.com/oauth2/v3/certs>https://www.googleapis.com/oauth2/v3/certs</a>。</li><li><strong>用途：</strong> 依赖方（RP）通过此端点获取OP的公钥，以便验证ID Token的数字签名。</li></ul><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><p>OpenID Connect (OIDC) 是在OAuth 2.0授权框架之上构建的，提供了一个轻量级、可互操作的身份认证层。它通过引入<strong>ID Token</strong>（一个包含用户身份信息的JWT）和一系列标准化的<strong>端点</strong>（授权、令牌、用户信息、发现、JWKS），解决了OAuth 2.0在身份认证方面的空白。</p><p>OIDC使得第三方应用能够安全、便捷地验证用户身份并获取其基本资料，而无需直接处理用户的敏感凭证。这不仅极大地简化了单点登录（SSO）的实现，也为构建现代、安全的微服务和分布式应用提供了坚实的基础。理解OIDC的这些核心概念和端点，是你在IAM领域深入实践的关键一步。</p><h3></h3><p><strong>欢迎关注+点赞+推荐+转发</strong></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bsong2015.github.io/blog/>万年水的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>