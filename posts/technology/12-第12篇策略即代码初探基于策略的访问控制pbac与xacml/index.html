<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>万年水的博客</title><meta name=keywords content><meta name=description content="第12篇：策略即代码：初探基于策略的访问控制（PBAC）与XACML
在之前的文章中，我们讨论了RBAC（基于角色的访问控制）和ABAC（基于属性的访问控制）。RBAC通过预定义的角色简化了权限管理，而ABAC则通过评估运行时属性实现更精细和动态的授权。本篇，我们将进一步探讨一种将授权逻辑推向“策略即代码”境界的模型——基于策略的访问控制（Policy-Based Access Control，简称PBAC），以及实现PBAC的行业标准XACML。
PBAC的核心思想是将所有的授权规则表达为结构化的、可机器解析的策略，并由专门的引擎进行评估和执行。这使得授权逻辑可以像代码一样被管理、版本控制和自动化。
1. 策略即代码：PBAC的核心思想
基于策略的访问控制（PBAC） 是一种授权范式，它将授权决策从应用程序的业务逻辑中解耦出来，通过定义一套明确的、可执行的策略（Policies） 来驱动访问决策。
PBAC的理念可以概括为“策略即代码”：

策略是核心： 所有的授权规则都表现为具体的策略，这些策略清晰地定义了在什么条件下，谁可以对什么资源执行什么操作。
可外部化： 授权逻辑不再硬编码在应用内部，而是以独立的策略文件或服务形式存在。这意味着你可以不修改应用程序代码就改变授权逻辑。
可自动化： 策略可以用机器可读的语言编写，方便自动化工具进行管理、部署、测试和审计。
可审计性： 策略的清晰定义使得授权决策的依据一目了然，极大地提升了审计和合规性。

PBAC与ABAC的关系非常紧密。事实上，PBAC是ABAC的一种高级实现形式，它提供了将ABAC中基于属性的规则（如“如果主体部门是资源部门，且操作是读取，则允许”）以结构化、标准化的策略语言表达和执行的框架。可以说，ABAC是决策模型，而PBAC是实现这个模型的具体方法论和技术体系。
2. XACML：PBAC的工业级标准
为了标准化PBAC的实现，OASIS（结构化信息标准促进组织） 制定了XACML（eXtensible Access Control Markup Language，可扩展访问控制标记语言） 标准。XACML是一个声明式语言，用于表达访问控制策略，并定义了一个体系结构，规范了授权决策的各个组件及其交互方式。
XACML提供了一种强大且灵活的方式来编写复杂、细粒度的访问控制策略。它允许策略包含以下逻辑：

目标（Target）： 策略适用的主体、资源和操作的初始匹配条件。
规则（Rule）： 具体执行“允许”或“拒绝”决策的条件逻辑。
效应（Effect）： 如果规则满足，是“允许”（Permit）还是“拒绝”（Deny）。
条件（Condition）： 结合属性和函数进行更复杂的逻辑判断。
规则组合算法（Rule Combining Algorithm）： 当多个规则适用时，如何得出最终决策（例如，是“先拒绝”原则还是“先允许”原则）。
策略集（Policy Set）： 多个策略的集合，也可以有自己的策略组合算法。

3. XACML的核心架构组件
XACML定义了一个明确的授权体系结构，包含以下四个主要组件，它们协同工作来完成访问控制决策：
3.1 策略执行点（Policy Enforcement Point, PEP）

作用： PEP是离应用程序最近的组件，负责拦截用户对资源的访问请求。它就像一个“门卫”，在用户尝试进入时进行检查。
职责：

拦截请求： 当应用程序收到用户对受保护资源的请求时，PEP会拦截这个请求。
生成访问请求： PEP将访问请求转换为XACML格式的访问请求上下文（Access Request Context），其中包含了请求中所有相关的主体属性、资源属性、环境属性和操作属性。
发送到PDP： PEP将这个XACML格式的访问请求发送给策略决策点（PDP）。
执行决策： 接收PDP返回的访问决策（Permit/Deny/NotApplicable/Indeterminate），并据此强制执行（允许或拒绝访问）。



3.2 策略决策点（Policy Decision Point, PDP）

作用： PDP是XACML架构的核心，它负责接收PEP的访问请求，并根据预定义的XACML策略集做出授权决策。它就像一个“中央决策大脑”。
职责：

接收请求： 从PEP接收XACML访问请求上下文。
获取策略： 加载并识别所有相关的XACML策略和策略集。
获取属性： 如果请求上下文中缺少做出决策所需的某些属性，PDP会请求策略信息点（PIP）来获取这些属性。
评估策略： 根据XACML策略的规则和条件，评估所有属性，并根据策略组合算法得出最终的授权决策。
返回决策： 将最终决策（如Permit、Deny）返回给PEP。



3.3 策略信息点（Policy Information Point, PIP）

作用： PIP是属性数据的来源。当PDP在评估策略时发现缺少某些必要的属性信息（如用户的最新部门信息、资源的当前状态等），它会向PIP发出请求。PIP就像一个“数据源连接器”。
职责：

集成外部数据源： 连接到各种外部数据源，如LDAP目录、数据库、HR系统、微服务API、CRM系统等。
按需提供属性： 根据PDP的请求，从这些数据源中检索并提供所需的属性值，将其返回给PDP。



3.4 策略管理点（Policy Administration Point, PAP）

作用： PAP是负责创建、存储、管理、部署和维护XACML策略的组件。它就像一个“策略管理员”。
职责：

策略创作： 提供界面或API，允许管理员编写和修改XACML策略。
策略存储： 安全地存储策略，通常在一个策略存储库中。
策略分发： 将策略部署和分发给PDP。
策略版本控制： 管理策略的版本，支持回滚和审计。
策略测试与调试： 提供工具测试策略的有效性和预期行为。



XACML架构组件交互图示："><meta name=author content><link rel=canonical href=https://bsong2015.github.io/blog/posts/technology/12-%E7%AC%AC12%E7%AF%87%E7%AD%96%E7%95%A5%E5%8D%B3%E4%BB%A3%E7%A0%81%E5%88%9D%E6%8E%A2%E5%9F%BA%E4%BA%8E%E7%AD%96%E7%95%A5%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6pbac%E4%B8%8Exacml/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://bsong2015.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bsong2015.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bsong2015.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://bsong2015.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://bsong2015.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://bsong2015.github.io/blog/posts/technology/12-%E7%AC%AC12%E7%AF%87%E7%AD%96%E7%95%A5%E5%8D%B3%E4%BB%A3%E7%A0%81%E5%88%9D%E6%8E%A2%E5%9F%BA%E4%BA%8E%E7%AD%96%E7%95%A5%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6pbac%E4%B8%8Exacml/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
</script><meta property="og:url" content="https://bsong2015.github.io/blog/posts/technology/12-%E7%AC%AC12%E7%AF%87%E7%AD%96%E7%95%A5%E5%8D%B3%E4%BB%A3%E7%A0%81%E5%88%9D%E6%8E%A2%E5%9F%BA%E4%BA%8E%E7%AD%96%E7%95%A5%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6pbac%E4%B8%8Exacml/"><meta property="og:site_name" content="万年水的博客"><meta property="og:title" content="万年水的博客"><meta property="og:description" content="第12篇：策略即代码：初探基于策略的访问控制（PBAC）与XACML 在之前的文章中，我们讨论了RBAC（基于角色的访问控制）和ABAC（基于属性的访问控制）。RBAC通过预定义的角色简化了权限管理，而ABAC则通过评估运行时属性实现更精细和动态的授权。本篇，我们将进一步探讨一种将授权逻辑推向“策略即代码”境界的模型——基于策略的访问控制（Policy-Based Access Control，简称PBAC），以及实现PBAC的行业标准XACML。
PBAC的核心思想是将所有的授权规则表达为结构化的、可机器解析的策略，并由专门的引擎进行评估和执行。这使得授权逻辑可以像代码一样被管理、版本控制和自动化。
1. 策略即代码：PBAC的核心思想 基于策略的访问控制（PBAC） 是一种授权范式，它将授权决策从应用程序的业务逻辑中解耦出来，通过定义一套明确的、可执行的策略（Policies） 来驱动访问决策。
PBAC的理念可以概括为“策略即代码”：
策略是核心： 所有的授权规则都表现为具体的策略，这些策略清晰地定义了在什么条件下，谁可以对什么资源执行什么操作。 可外部化： 授权逻辑不再硬编码在应用内部，而是以独立的策略文件或服务形式存在。这意味着你可以不修改应用程序代码就改变授权逻辑。 可自动化： 策略可以用机器可读的语言编写，方便自动化工具进行管理、部署、测试和审计。 可审计性： 策略的清晰定义使得授权决策的依据一目了然，极大地提升了审计和合规性。 PBAC与ABAC的关系非常紧密。事实上，PBAC是ABAC的一种高级实现形式，它提供了将ABAC中基于属性的规则（如“如果主体部门是资源部门，且操作是读取，则允许”）以结构化、标准化的策略语言表达和执行的框架。可以说，ABAC是决策模型，而PBAC是实现这个模型的具体方法论和技术体系。
2. XACML：PBAC的工业级标准 为了标准化PBAC的实现，OASIS（结构化信息标准促进组织） 制定了XACML（eXtensible Access Control Markup Language，可扩展访问控制标记语言） 标准。XACML是一个声明式语言，用于表达访问控制策略，并定义了一个体系结构，规范了授权决策的各个组件及其交互方式。
XACML提供了一种强大且灵活的方式来编写复杂、细粒度的访问控制策略。它允许策略包含以下逻辑：
目标（Target）： 策略适用的主体、资源和操作的初始匹配条件。 规则（Rule）： 具体执行“允许”或“拒绝”决策的条件逻辑。 效应（Effect）： 如果规则满足，是“允许”（Permit）还是“拒绝”（Deny）。 条件（Condition）： 结合属性和函数进行更复杂的逻辑判断。 规则组合算法（Rule Combining Algorithm）： 当多个规则适用时，如何得出最终决策（例如，是“先拒绝”原则还是“先允许”原则）。 策略集（Policy Set）： 多个策略的集合，也可以有自己的策略组合算法。 3. XACML的核心架构组件 XACML定义了一个明确的授权体系结构，包含以下四个主要组件，它们协同工作来完成访问控制决策：
3.1 策略执行点（Policy Enforcement Point, PEP） 作用： PEP是离应用程序最近的组件，负责拦截用户对资源的访问请求。它就像一个“门卫”，在用户尝试进入时进行检查。 职责： 拦截请求： 当应用程序收到用户对受保护资源的请求时，PEP会拦截这个请求。 生成访问请求： PEP将访问请求转换为XACML格式的访问请求上下文（Access Request Context），其中包含了请求中所有相关的主体属性、资源属性、环境属性和操作属性。 发送到PDP： PEP将这个XACML格式的访问请求发送给策略决策点（PDP）。 执行决策： 接收PDP返回的访问决策（Permit/Deny/NotApplicable/Indeterminate），并据此强制执行（允许或拒绝访问）。 3.2 策略决策点（Policy Decision Point, PDP） 作用： PDP是XACML架构的核心，它负责接收PEP的访问请求，并根据预定义的XACML策略集做出授权决策。它就像一个“中央决策大脑”。 职责： 接收请求： 从PEP接收XACML访问请求上下文。 获取策略： 加载并识别所有相关的XACML策略和策略集。 获取属性： 如果请求上下文中缺少做出决策所需的某些属性，PDP会请求策略信息点（PIP）来获取这些属性。 评估策略： 根据XACML策略的规则和条件，评估所有属性，并根据策略组合算法得出最终的授权决策。 返回决策： 将最终决策（如Permit、Deny）返回给PEP。 3.3 策略信息点（Policy Information Point, PIP） 作用： PIP是属性数据的来源。当PDP在评估策略时发现缺少某些必要的属性信息（如用户的最新部门信息、资源的当前状态等），它会向PIP发出请求。PIP就像一个“数据源连接器”。 职责： 集成外部数据源： 连接到各种外部数据源，如LDAP目录、数据库、HR系统、微服务API、CRM系统等。 按需提供属性： 根据PDP的请求，从这些数据源中检索并提供所需的属性值，将其返回给PDP。 3.4 策略管理点（Policy Administration Point, PAP） 作用： PAP是负责创建、存储、管理、部署和维护XACML策略的组件。它就像一个“策略管理员”。 职责： 策略创作： 提供界面或API，允许管理员编写和修改XACML策略。 策略存储： 安全地存储策略，通常在一个策略存储库中。 策略分发： 将策略部署和分发给PDP。 策略版本控制： 管理策略的版本，支持回滚和审计。 策略测试与调试： 提供工具测试策略的有效性和预期行为。 XACML架构组件交互图示："><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="第12篇：策略即代码：初探基于策略的访问控制（PBAC）与XACML
在之前的文章中，我们讨论了RBAC（基于角色的访问控制）和ABAC（基于属性的访问控制）。RBAC通过预定义的角色简化了权限管理，而ABAC则通过评估运行时属性实现更精细和动态的授权。本篇，我们将进一步探讨一种将授权逻辑推向“策略即代码”境界的模型——基于策略的访问控制（Policy-Based Access Control，简称PBAC），以及实现PBAC的行业标准XACML。
PBAC的核心思想是将所有的授权规则表达为结构化的、可机器解析的策略，并由专门的引擎进行评估和执行。这使得授权逻辑可以像代码一样被管理、版本控制和自动化。
1. 策略即代码：PBAC的核心思想
基于策略的访问控制（PBAC） 是一种授权范式，它将授权决策从应用程序的业务逻辑中解耦出来，通过定义一套明确的、可执行的策略（Policies） 来驱动访问决策。
PBAC的理念可以概括为“策略即代码”：

策略是核心： 所有的授权规则都表现为具体的策略，这些策略清晰地定义了在什么条件下，谁可以对什么资源执行什么操作。
可外部化： 授权逻辑不再硬编码在应用内部，而是以独立的策略文件或服务形式存在。这意味着你可以不修改应用程序代码就改变授权逻辑。
可自动化： 策略可以用机器可读的语言编写，方便自动化工具进行管理、部署、测试和审计。
可审计性： 策略的清晰定义使得授权决策的依据一目了然，极大地提升了审计和合规性。

PBAC与ABAC的关系非常紧密。事实上，PBAC是ABAC的一种高级实现形式，它提供了将ABAC中基于属性的规则（如“如果主体部门是资源部门，且操作是读取，则允许”）以结构化、标准化的策略语言表达和执行的框架。可以说，ABAC是决策模型，而PBAC是实现这个模型的具体方法论和技术体系。
2. XACML：PBAC的工业级标准
为了标准化PBAC的实现，OASIS（结构化信息标准促进组织） 制定了XACML（eXtensible Access Control Markup Language，可扩展访问控制标记语言） 标准。XACML是一个声明式语言，用于表达访问控制策略，并定义了一个体系结构，规范了授权决策的各个组件及其交互方式。
XACML提供了一种强大且灵活的方式来编写复杂、细粒度的访问控制策略。它允许策略包含以下逻辑：

目标（Target）： 策略适用的主体、资源和操作的初始匹配条件。
规则（Rule）： 具体执行“允许”或“拒绝”决策的条件逻辑。
效应（Effect）： 如果规则满足，是“允许”（Permit）还是“拒绝”（Deny）。
条件（Condition）： 结合属性和函数进行更复杂的逻辑判断。
规则组合算法（Rule Combining Algorithm）： 当多个规则适用时，如何得出最终决策（例如，是“先拒绝”原则还是“先允许”原则）。
策略集（Policy Set）： 多个策略的集合，也可以有自己的策略组合算法。

3. XACML的核心架构组件
XACML定义了一个明确的授权体系结构，包含以下四个主要组件，它们协同工作来完成访问控制决策：
3.1 策略执行点（Policy Enforcement Point, PEP）

作用： PEP是离应用程序最近的组件，负责拦截用户对资源的访问请求。它就像一个“门卫”，在用户尝试进入时进行检查。
职责：

拦截请求： 当应用程序收到用户对受保护资源的请求时，PEP会拦截这个请求。
生成访问请求： PEP将访问请求转换为XACML格式的访问请求上下文（Access Request Context），其中包含了请求中所有相关的主体属性、资源属性、环境属性和操作属性。
发送到PDP： PEP将这个XACML格式的访问请求发送给策略决策点（PDP）。
执行决策： 接收PDP返回的访问决策（Permit/Deny/NotApplicable/Indeterminate），并据此强制执行（允许或拒绝访问）。



3.2 策略决策点（Policy Decision Point, PDP）

作用： PDP是XACML架构的核心，它负责接收PEP的访问请求，并根据预定义的XACML策略集做出授权决策。它就像一个“中央决策大脑”。
职责：

接收请求： 从PEP接收XACML访问请求上下文。
获取策略： 加载并识别所有相关的XACML策略和策略集。
获取属性： 如果请求上下文中缺少做出决策所需的某些属性，PDP会请求策略信息点（PIP）来获取这些属性。
评估策略： 根据XACML策略的规则和条件，评估所有属性，并根据策略组合算法得出最终的授权决策。
返回决策： 将最终决策（如Permit、Deny）返回给PEP。



3.3 策略信息点（Policy Information Point, PIP）

作用： PIP是属性数据的来源。当PDP在评估策略时发现缺少某些必要的属性信息（如用户的最新部门信息、资源的当前状态等），它会向PIP发出请求。PIP就像一个“数据源连接器”。
职责：

集成外部数据源： 连接到各种外部数据源，如LDAP目录、数据库、HR系统、微服务API、CRM系统等。
按需提供属性： 根据PDP的请求，从这些数据源中检索并提供所需的属性值，将其返回给PDP。



3.4 策略管理点（Policy Administration Point, PAP）

作用： PAP是负责创建、存储、管理、部署和维护XACML策略的组件。它就像一个“策略管理员”。
职责：

策略创作： 提供界面或API，允许管理员编写和修改XACML策略。
策略存储： 安全地存储策略，通常在一个策略存储库中。
策略分发： 将策略部署和分发给PDP。
策略版本控制： 管理策略的版本，支持回滚和审计。
策略测试与调试： 提供工具测试策略的有效性和预期行为。



XACML架构组件交互图示："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bsong2015.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"技术实践","item":"https://bsong2015.github.io/blog/posts/technology/"},{"@type":"ListItem","position":3,"name":"","item":"https://bsong2015.github.io/blog/posts/technology/12-%E7%AC%AC12%E7%AF%87%E7%AD%96%E7%95%A5%E5%8D%B3%E4%BB%A3%E7%A0%81%E5%88%9D%E6%8E%A2%E5%9F%BA%E4%BA%8E%E7%AD%96%E7%95%A5%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6pbac%E4%B8%8Exacml/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"第12篇：策略即代码：初探基于策略的访问控制（PBAC）与XACML 在之前的文章中，我们讨论了RBAC（基于角色的访问控制）和ABAC（基于属性的访问控制）。RBAC通过预定义的角色简化了权限管理，而ABAC则通过评估运行时属性实现更精细和动态的授权。本篇，我们将进一步探讨一种将授权逻辑推向“策略即代码”境界的模型——基于策略的访问控制（Policy-Based Access Control，简称PBAC），以及实现PBAC的行业标准XACML。\nPBAC的核心思想是将所有的授权规则表达为结构化的、可机器解析的策略，并由专门的引擎进行评估和执行。这使得授权逻辑可以像代码一样被管理、版本控制和自动化。\n1. 策略即代码：PBAC的核心思想 基于策略的访问控制（PBAC） 是一种授权范式，它将授权决策从应用程序的业务逻辑中解耦出来，通过定义一套明确的、可执行的策略（Policies） 来驱动访问决策。\nPBAC的理念可以概括为“策略即代码”：\n策略是核心： 所有的授权规则都表现为具体的策略，这些策略清晰地定义了在什么条件下，谁可以对什么资源执行什么操作。 可外部化： 授权逻辑不再硬编码在应用内部，而是以独立的策略文件或服务形式存在。这意味着你可以不修改应用程序代码就改变授权逻辑。 可自动化： 策略可以用机器可读的语言编写，方便自动化工具进行管理、部署、测试和审计。 可审计性： 策略的清晰定义使得授权决策的依据一目了然，极大地提升了审计和合规性。 PBAC与ABAC的关系非常紧密。事实上，PBAC是ABAC的一种高级实现形式，它提供了将ABAC中基于属性的规则（如“如果主体部门是资源部门，且操作是读取，则允许”）以结构化、标准化的策略语言表达和执行的框架。可以说，ABAC是决策模型，而PBAC是实现这个模型的具体方法论和技术体系。\n2. XACML：PBAC的工业级标准 为了标准化PBAC的实现，OASIS（结构化信息标准促进组织） 制定了XACML（eXtensible Access Control Markup Language，可扩展访问控制标记语言） 标准。XACML是一个声明式语言，用于表达访问控制策略，并定义了一个体系结构，规范了授权决策的各个组件及其交互方式。\nXACML提供了一种强大且灵活的方式来编写复杂、细粒度的访问控制策略。它允许策略包含以下逻辑：\n目标（Target）： 策略适用的主体、资源和操作的初始匹配条件。 规则（Rule）： 具体执行“允许”或“拒绝”决策的条件逻辑。 效应（Effect）： 如果规则满足，是“允许”（Permit）还是“拒绝”（Deny）。 条件（Condition）： 结合属性和函数进行更复杂的逻辑判断。 规则组合算法（Rule Combining Algorithm）： 当多个规则适用时，如何得出最终决策（例如，是“先拒绝”原则还是“先允许”原则）。 策略集（Policy Set）： 多个策略的集合，也可以有自己的策略组合算法。 3. XACML的核心架构组件 XACML定义了一个明确的授权体系结构，包含以下四个主要组件，它们协同工作来完成访问控制决策：\n3.1 策略执行点（Policy Enforcement Point, PEP） 作用： PEP是离应用程序最近的组件，负责拦截用户对资源的访问请求。它就像一个“门卫”，在用户尝试进入时进行检查。 职责： 拦截请求： 当应用程序收到用户对受保护资源的请求时，PEP会拦截这个请求。 生成访问请求： PEP将访问请求转换为XACML格式的访问请求上下文（Access Request Context），其中包含了请求中所有相关的主体属性、资源属性、环境属性和操作属性。 发送到PDP： PEP将这个XACML格式的访问请求发送给策略决策点（PDP）。 执行决策： 接收PDP返回的访问决策（Permit/Deny/NotApplicable/Indeterminate），并据此强制执行（允许或拒绝访问）。 3.2 策略决策点（Policy Decision Point, PDP） 作用： PDP是XACML架构的核心，它负责接收PEP的访问请求，并根据预定义的XACML策略集做出授权决策。它就像一个“中央决策大脑”。 职责： 接收请求： 从PEP接收XACML访问请求上下文。 获取策略： 加载并识别所有相关的XACML策略和策略集。 获取属性： 如果请求上下文中缺少做出决策所需的某些属性，PDP会请求策略信息点（PIP）来获取这些属性。 评估策略： 根据XACML策略的规则和条件，评估所有属性，并根据策略组合算法得出最终的授权决策。 返回决策： 将最终决策（如Permit、Deny）返回给PEP。 3.3 策略信息点（Policy Information Point, PIP） 作用： PIP是属性数据的来源。当PDP在评估策略时发现缺少某些必要的属性信息（如用户的最新部门信息、资源的当前状态等），它会向PIP发出请求。PIP就像一个“数据源连接器”。 职责： 集成外部数据源： 连接到各种外部数据源，如LDAP目录、数据库、HR系统、微服务API、CRM系统等。 按需提供属性： 根据PDP的请求，从这些数据源中检索并提供所需的属性值，将其返回给PDP。 3.4 策略管理点（Policy Administration Point, PAP） 作用： PAP是负责创建、存储、管理、部署和维护XACML策略的组件。它就像一个“策略管理员”。 职责： 策略创作： 提供界面或API，允许管理员编写和修改XACML策略。 策略存储： 安全地存储策略，通常在一个策略存储库中。 策略分发： 将策略部署和分发给PDP。 策略版本控制： 管理策略的版本，支持回滚和审计。 策略测试与调试： 提供工具测试策略的有效性和预期行为。 XACML架构组件交互图示：\n","keywords":[],"articleBody":"第12篇：策略即代码：初探基于策略的访问控制（PBAC）与XACML 在之前的文章中，我们讨论了RBAC（基于角色的访问控制）和ABAC（基于属性的访问控制）。RBAC通过预定义的角色简化了权限管理，而ABAC则通过评估运行时属性实现更精细和动态的授权。本篇，我们将进一步探讨一种将授权逻辑推向“策略即代码”境界的模型——基于策略的访问控制（Policy-Based Access Control，简称PBAC），以及实现PBAC的行业标准XACML。\nPBAC的核心思想是将所有的授权规则表达为结构化的、可机器解析的策略，并由专门的引擎进行评估和执行。这使得授权逻辑可以像代码一样被管理、版本控制和自动化。\n1. 策略即代码：PBAC的核心思想 基于策略的访问控制（PBAC） 是一种授权范式，它将授权决策从应用程序的业务逻辑中解耦出来，通过定义一套明确的、可执行的策略（Policies） 来驱动访问决策。\nPBAC的理念可以概括为“策略即代码”：\n策略是核心： 所有的授权规则都表现为具体的策略，这些策略清晰地定义了在什么条件下，谁可以对什么资源执行什么操作。 可外部化： 授权逻辑不再硬编码在应用内部，而是以独立的策略文件或服务形式存在。这意味着你可以不修改应用程序代码就改变授权逻辑。 可自动化： 策略可以用机器可读的语言编写，方便自动化工具进行管理、部署、测试和审计。 可审计性： 策略的清晰定义使得授权决策的依据一目了然，极大地提升了审计和合规性。 PBAC与ABAC的关系非常紧密。事实上，PBAC是ABAC的一种高级实现形式，它提供了将ABAC中基于属性的规则（如“如果主体部门是资源部门，且操作是读取，则允许”）以结构化、标准化的策略语言表达和执行的框架。可以说，ABAC是决策模型，而PBAC是实现这个模型的具体方法论和技术体系。\n2. XACML：PBAC的工业级标准 为了标准化PBAC的实现，OASIS（结构化信息标准促进组织） 制定了XACML（eXtensible Access Control Markup Language，可扩展访问控制标记语言） 标准。XACML是一个声明式语言，用于表达访问控制策略，并定义了一个体系结构，规范了授权决策的各个组件及其交互方式。\nXACML提供了一种强大且灵活的方式来编写复杂、细粒度的访问控制策略。它允许策略包含以下逻辑：\n目标（Target）： 策略适用的主体、资源和操作的初始匹配条件。 规则（Rule）： 具体执行“允许”或“拒绝”决策的条件逻辑。 效应（Effect）： 如果规则满足，是“允许”（Permit）还是“拒绝”（Deny）。 条件（Condition）： 结合属性和函数进行更复杂的逻辑判断。 规则组合算法（Rule Combining Algorithm）： 当多个规则适用时，如何得出最终决策（例如，是“先拒绝”原则还是“先允许”原则）。 策略集（Policy Set）： 多个策略的集合，也可以有自己的策略组合算法。 3. XACML的核心架构组件 XACML定义了一个明确的授权体系结构，包含以下四个主要组件，它们协同工作来完成访问控制决策：\n3.1 策略执行点（Policy Enforcement Point, PEP） 作用： PEP是离应用程序最近的组件，负责拦截用户对资源的访问请求。它就像一个“门卫”，在用户尝试进入时进行检查。 职责： 拦截请求： 当应用程序收到用户对受保护资源的请求时，PEP会拦截这个请求。 生成访问请求： PEP将访问请求转换为XACML格式的访问请求上下文（Access Request Context），其中包含了请求中所有相关的主体属性、资源属性、环境属性和操作属性。 发送到PDP： PEP将这个XACML格式的访问请求发送给策略决策点（PDP）。 执行决策： 接收PDP返回的访问决策（Permit/Deny/NotApplicable/Indeterminate），并据此强制执行（允许或拒绝访问）。 3.2 策略决策点（Policy Decision Point, PDP） 作用： PDP是XACML架构的核心，它负责接收PEP的访问请求，并根据预定义的XACML策略集做出授权决策。它就像一个“中央决策大脑”。 职责： 接收请求： 从PEP接收XACML访问请求上下文。 获取策略： 加载并识别所有相关的XACML策略和策略集。 获取属性： 如果请求上下文中缺少做出决策所需的某些属性，PDP会请求策略信息点（PIP）来获取这些属性。 评估策略： 根据XACML策略的规则和条件，评估所有属性，并根据策略组合算法得出最终的授权决策。 返回决策： 将最终决策（如Permit、Deny）返回给PEP。 3.3 策略信息点（Policy Information Point, PIP） 作用： PIP是属性数据的来源。当PDP在评估策略时发现缺少某些必要的属性信息（如用户的最新部门信息、资源的当前状态等），它会向PIP发出请求。PIP就像一个“数据源连接器”。 职责： 集成外部数据源： 连接到各种外部数据源，如LDAP目录、数据库、HR系统、微服务API、CRM系统等。 按需提供属性： 根据PDP的请求，从这些数据源中检索并提供所需的属性值，将其返回给PDP。 3.4 策略管理点（Policy Administration Point, PAP） 作用： PAP是负责创建、存储、管理、部署和维护XACML策略的组件。它就像一个“策略管理员”。 职责： 策略创作： 提供界面或API，允许管理员编写和修改XACML策略。 策略存储： 安全地存储策略，通常在一个策略存储库中。 策略分发： 将策略部署和分发给PDP。 策略版本控制： 管理策略的版本，支持回滚和审计。 策略测试与调试： 提供工具测试策略的有效性和预期行为。 XACML架构组件交互图示：\ngraph TD User --\u003e|Access Request| Application Application -- \"Intercept \u0026 Create XACML Request\" --\u003e PEP PEP --\u003e|XACML Access Request| PDP PDP -- \"Missing Attribute Query\" --\u003e PIP PIP --\u003e|Attribute Values| PDP subgraph Policy Administration PAP --\u003e|Manage \u0026 Distribute Policies| PDP end PDP --\u003e|Access Decision| PEP PEP --\u003e|Enforce Decision| Application Application --\u003e|Access Granted/Denied| User 4. PBAC/XACML的优势与适用场景 优势：\n高度灵活性和动态性： 能够处理极其复杂和动态的授权规则，远超RBAC和简单ABAC的表达能力。 解耦性： 将授权逻辑从应用代码中完全分离，实现业务逻辑和安全逻辑的独立演进。 细粒度控制： 可以实现对数据字段、API参数甚至时间、地理位置等上下文的超细粒度授权。 集中化管理： 所有策略集中管理，便于审计、一致性部署和变更控制。 可审计性和透明度： 策略的声明性使得决策过程可理解、可追溯。 跨平台/语言： XACML作为XML标准，可以跨越不同的编程语言和技术栈实现互操作性。 适用场景：\n高合规性要求行业： 金融、医疗、政府等需要严格满足数据隔离、职责分离等复杂合规性要求的场景。 大数据和微服务架构： 数据量巨大且访问模式复杂，需要基于数据属性、服务调用者属性进行动态授权。 多租户SaaS平台： 租户之间数据严格隔离，且不同租户有不同定制化授权需求的场景。 API安全网关： 在API层面进行精细的认证和授权控制。 零信任架构： 作为零信任策略引擎的核心组成部分，实现基于上下文的动态授权。 挑战：\n学习曲线陡峭： XACML的语法和概念相对复杂，学习和掌握需要一定时间。 初始部署和集成复杂： 搭建XACML体系架构（PDP、PIP等）可能需要专业知识和工具。 性能考量： 复杂的策略评估可能会引入额外的延迟，需要进行性能优化。 总结 基于策略的访问控制（PBAC）代表了授权管理的未来方向，它将授权逻辑抽象为可管理、可执行的策略，实现了“策略即代码”的理念。XACML作为PBAC的工业级标准，提供了一个完善的架构（PEP、PDP、PIP、PAP）和强大的策略语言，能够处理最复杂、最动态的授权场景。\n虽然PBAC和XACML的学习和实施成本相对较高，但它们带来的灵活性、精细度、可审计性和解耦性，使其成为构建高度安全、适应性强的现代IAM系统的理想选择，尤其是在需要应对复杂业务规则和严格合规性要求的企业级场景中。\n欢迎关注+点赞+推荐+转发\n","wordCount":"205","inLanguage":"zh","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bsong2015.github.io/blog/posts/technology/12-%E7%AC%AC12%E7%AF%87%E7%AD%96%E7%95%A5%E5%8D%B3%E4%BB%A3%E7%A0%81%E5%88%9D%E6%8E%A2%E5%9F%BA%E4%BA%8E%E7%AD%96%E7%95%A5%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6pbac%E4%B8%8Exacml/"},"publisher":{"@type":"Organization","name":"万年水的博客","logo":{"@type":"ImageObject","url":"https://bsong2015.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bsong2015.github.io/blog/ accesskey=h title="万年水的博客 (Alt + H)">万年水的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bsong2015.github.io/blog/posts/artificial-intelligence/ title=人工智能><span>人工智能</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/reading/ title=阅读><span>阅读</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/thinking-models/ title=思维模型><span>思维模型</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/thought-experiments/ title=思想实验><span>思想实验</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/personal-growth/ title=个人成长><span>个人成长</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/technology/ title=技术><span>技术</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/current-affairs/ title=时事><span>时事</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/others/ title=其它><span>其它</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent"></h1><div class=post-meta></div></header><div class=post-content><h2 id=第12篇策略即代码初探基于策略的访问控制pbac与xacml>第12篇：策略即代码：初探基于策略的访问控制（PBAC）与XACML<a hidden class=anchor aria-hidden=true href=#第12篇策略即代码初探基于策略的访问控制pbac与xacml>#</a></h2><p>在之前的文章中，我们讨论了RBAC（基于角色的访问控制）和ABAC（基于属性的访问控制）。RBAC通过预定义的角色简化了权限管理，而ABAC则通过评估运行时属性实现更精细和动态的授权。本篇，我们将进一步探讨一种将授权逻辑推向“策略即代码”境界的模型——<strong>基于策略的访问控制（Policy-Based Access Control，简称PBAC）</strong>，以及实现PBAC的行业标准<strong>XACML</strong>。</p><p>PBAC的核心思想是将所有的授权规则表达为结构化的、可机器解析的策略，并由专门的引擎进行评估和执行。这使得授权逻辑可以像代码一样被管理、版本控制和自动化。</p><h3 id=1-策略即代码pbac的核心思想>1. 策略即代码：PBAC的核心思想<a hidden class=anchor aria-hidden=true href=#1-策略即代码pbac的核心思想>#</a></h3><p><strong>基于策略的访问控制（PBAC）</strong> 是一种授权范式，它将授权决策从应用程序的业务逻辑中解耦出来，通过定义一套明确的、可执行的<strong>策略（Policies）</strong> 来驱动访问决策。</p><p>PBAC的理念可以概括为“策略即代码”：</p><ul><li><strong>策略是核心：</strong> 所有的授权规则都表现为具体的策略，这些策略清晰地定义了在什么条件下，谁可以对什么资源执行什么操作。</li><li><strong>可外部化：</strong> 授权逻辑不再硬编码在应用内部，而是以独立的策略文件或服务形式存在。这意味着你可以不修改应用程序代码就改变授权逻辑。</li><li><strong>可自动化：</strong> 策略可以用机器可读的语言编写，方便自动化工具进行管理、部署、测试和审计。</li><li><strong>可审计性：</strong> 策略的清晰定义使得授权决策的依据一目了然，极大地提升了审计和合规性。</li></ul><p>PBAC与ABAC的关系非常紧密。事实上，PBAC是ABAC的一种高级实现形式，它提供了将ABAC中基于属性的规则（如“如果主体部门是资源部门，且操作是读取，则允许”）以结构化、标准化的策略语言表达和执行的框架。可以说，<strong>ABAC是决策模型，而PBAC是实现这个模型的具体方法论和技术体系。</strong></p><h3 id=2-xacmlpbac的工业级标准>2. XACML：PBAC的工业级标准<a hidden class=anchor aria-hidden=true href=#2-xacmlpbac的工业级标准>#</a></h3><p>为了标准化PBAC的实现，<strong>OASIS（结构化信息标准促进组织）</strong> 制定了<strong>XACML（eXtensible Access Control Markup Language，可扩展访问控制标记语言）</strong> 标准。XACML是一个声明式语言，用于表达访问控制策略，并定义了一个体系结构，规范了授权决策的各个组件及其交互方式。</p><p>XACML提供了一种强大且灵活的方式来编写复杂、细粒度的访问控制策略。它允许策略包含以下逻辑：</p><ul><li><strong>目标（Target）：</strong> 策略适用的主体、资源和操作的初始匹配条件。</li><li><strong>规则（Rule）：</strong> 具体执行“允许”或“拒绝”决策的条件逻辑。</li><li><strong>效应（Effect）：</strong> 如果规则满足，是“允许”（Permit）还是“拒绝”（Deny）。</li><li><strong>条件（Condition）：</strong> 结合属性和函数进行更复杂的逻辑判断。</li><li><strong>规则组合算法（Rule Combining Algorithm）：</strong> 当多个规则适用时，如何得出最终决策（例如，是“先拒绝”原则还是“先允许”原则）。</li><li><strong>策略集（Policy Set）：</strong> 多个策略的集合，也可以有自己的策略组合算法。</li></ul><h3 id=3-xacml的核心架构组件>3. XACML的核心架构组件<a hidden class=anchor aria-hidden=true href=#3-xacml的核心架构组件>#</a></h3><p>XACML定义了一个明确的授权体系结构，包含以下四个主要组件，它们协同工作来完成访问控制决策：</p><h4 id=31-策略执行点policy-enforcement-point-pep>3.1 策略执行点（Policy Enforcement Point, PEP）<a hidden class=anchor aria-hidden=true href=#31-策略执行点policy-enforcement-point-pep>#</a></h4><ul><li><strong>作用：</strong> PEP是离应用程序最近的组件，负责拦截用户对资源的访问请求。它就像一个“门卫”，在用户尝试进入时进行检查。</li><li><strong>职责：</strong><ol><li><strong>拦截请求：</strong> 当应用程序收到用户对受保护资源的请求时，PEP会拦截这个请求。</li><li><strong>生成访问请求：</strong> PEP将访问请求转换为XACML格式的<strong>访问请求上下文（Access Request Context）</strong>，其中包含了请求中所有相关的<strong>主体属性、资源属性、环境属性和操作属性</strong>。</li><li><strong>发送到PDP：</strong> PEP将这个XACML格式的访问请求发送给策略决策点（PDP）。</li><li><strong>执行决策：</strong> 接收PDP返回的访问决策（Permit/Deny/NotApplicable/Indeterminate），并据此强制执行（允许或拒绝访问）。</li></ol></li></ul><h4 id=32-策略决策点policy-decision-point-pdp>3.2 策略决策点（Policy Decision Point, PDP）<a hidden class=anchor aria-hidden=true href=#32-策略决策点policy-decision-point-pdp>#</a></h4><ul><li><strong>作用：</strong> PDP是XACML架构的核心，它负责接收PEP的访问请求，并根据预定义的XACML策略集做出授权决策。它就像一个“中央决策大脑”。</li><li><strong>职责：</strong><ol><li><strong>接收请求：</strong> 从PEP接收XACML访问请求上下文。</li><li><strong>获取策略：</strong> 加载并识别所有相关的XACML策略和策略集。</li><li><strong>获取属性：</strong> 如果请求上下文中缺少做出决策所需的某些属性，PDP会请求策略信息点（PIP）来获取这些属性。</li><li><strong>评估策略：</strong> 根据XACML策略的规则和条件，评估所有属性，并根据策略组合算法得出最终的授权决策。</li><li><strong>返回决策：</strong> 将最终决策（如Permit、Deny）返回给PEP。</li></ol></li></ul><h4 id=33-策略信息点policy-information-point-pip>3.3 策略信息点（Policy Information Point, PIP）<a hidden class=anchor aria-hidden=true href=#33-策略信息点policy-information-point-pip>#</a></h4><ul><li><strong>作用：</strong> PIP是属性数据的来源。当PDP在评估策略时发现缺少某些必要的属性信息（如用户的最新部门信息、资源的当前状态等），它会向PIP发出请求。PIP就像一个“数据源连接器”。</li><li><strong>职责：</strong><ol><li><strong>集成外部数据源：</strong> 连接到各种外部数据源，如LDAP目录、数据库、HR系统、微服务API、CRM系统等。</li><li><strong>按需提供属性：</strong> 根据PDP的请求，从这些数据源中检索并提供所需的属性值，将其返回给PDP。</li></ol></li></ul><h4 id=34-策略管理点policy-administration-point-pap>3.4 策略管理点（Policy Administration Point, PAP）<a hidden class=anchor aria-hidden=true href=#34-策略管理点policy-administration-point-pap>#</a></h4><ul><li><strong>作用：</strong> PAP是负责创建、存储、管理、部署和维护XACML策略的组件。它就像一个“策略管理员”。</li><li><strong>职责：</strong><ol><li><strong>策略创作：</strong> 提供界面或API，允许管理员编写和修改XACML策略。</li><li><strong>策略存储：</strong> 安全地存储策略，通常在一个策略存储库中。</li><li><strong>策略分发：</strong> 将策略部署和分发给PDP。</li><li><strong>策略版本控制：</strong> 管理策略的版本，支持回滚和审计。</li><li><strong>策略测试与调试：</strong> 提供工具测试策略的有效性和预期行为。</li></ol></li></ul><p><strong>XACML架构组件交互图示：</strong></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>graph TD
    User --&gt;|Access Request| Application
    Application -- &#34;Intercept &amp; Create XACML Request&#34; --&gt; PEP
    PEP --&gt;|XACML Access Request| PDP
    PDP -- &#34;Missing Attribute Query&#34; --&gt; PIP
    PIP --&gt;|Attribute Values| PDP
    subgraph Policy Administration
        PAP --&gt;|Manage &amp; Distribute Policies| PDP
    end
    PDP --&gt;|Access Decision| PEP
    PEP --&gt;|Enforce Decision| Application
    Application --&gt;|Access Granted/Denied| User
</code></pre><h3 id=4-pbacxacml的优势与适用场景>4. PBAC/XACML的优势与适用场景<a hidden class=anchor aria-hidden=true href=#4-pbacxacml的优势与适用场景>#</a></h3><p><strong>优势：</strong></p><ul><li><strong>高度灵活性和动态性：</strong> 能够处理极其复杂和动态的授权规则，远超RBAC和简单ABAC的表达能力。</li><li><strong>解耦性：</strong> 将授权逻辑从应用代码中完全分离，实现业务逻辑和安全逻辑的独立演进。</li><li><strong>细粒度控制：</strong> 可以实现对数据字段、API参数甚至时间、地理位置等上下文的超细粒度授权。</li><li><strong>集中化管理：</strong> 所有策略集中管理，便于审计、一致性部署和变更控制。</li><li><strong>可审计性和透明度：</strong> 策略的声明性使得决策过程可理解、可追溯。</li><li><strong>跨平台/语言：</strong> XACML作为XML标准，可以跨越不同的编程语言和技术栈实现互操作性。</li></ul><p><strong>适用场景：</strong></p><ul><li><strong>高合规性要求行业：</strong> 金融、医疗、政府等需要严格满足数据隔离、职责分离等复杂合规性要求的场景。</li><li><strong>大数据和微服务架构：</strong> 数据量巨大且访问模式复杂，需要基于数据属性、服务调用者属性进行动态授权。</li><li><strong>多租户SaaS平台：</strong> 租户之间数据严格隔离，且不同租户有不同定制化授权需求的场景。</li><li><strong>API安全网关：</strong> 在API层面进行精细的认证和授权控制。</li><li><strong>零信任架构：</strong> 作为零信任策略引擎的核心组成部分，实现基于上下文的动态授权。</li></ul><p><strong>挑战：</strong></p><ul><li><strong>学习曲线陡峭：</strong> XACML的语法和概念相对复杂，学习和掌握需要一定时间。</li><li><strong>初始部署和集成复杂：</strong> 搭建XACML体系架构（PDP、PIP等）可能需要专业知识和工具。</li><li><strong>性能考量：</strong> 复杂的策略评估可能会引入额外的延迟，需要进行性能优化。</li></ul><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><p>基于策略的访问控制（PBAC）代表了授权管理的未来方向，它将授权逻辑抽象为可管理、可执行的策略，实现了“策略即代码”的理念。XACML作为PBAC的工业级标准，提供了一个完善的架构（PEP、PDP、PIP、PAP）和强大的策略语言，能够处理最复杂、最动态的授权场景。</p><p>虽然PBAC和XACML的学习和实施成本相对较高，但它们带来的灵活性、精细度、可审计性和解耦性，使其成为构建高度安全、适应性强的现代IAM系统的理想选择，尤其是在需要应对复杂业务规则和严格合规性要求的企业级场景中。</p><h3></h3><p><strong>欢迎关注+点赞+推荐+转发</strong></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bsong2015.github.io/blog/>万年水的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>