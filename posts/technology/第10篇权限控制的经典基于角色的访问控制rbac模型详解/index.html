<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>万年水的博客</title><meta name=keywords content><meta name=description content="第10篇：权限控制的经典：基于角色的访问控制（RBAC）模型详解
在之前的文章中，我们详细探讨了身份认证（Authentication）的各种机制，解决了“你是谁？”的问题。然而，仅仅验证了用户的身份是不够的，我们还需要回答更关键的问题：“你能做什么？”这正是授权（Authorization） 的核心任务。授权决定了已认证的用户对系统中的哪些资源拥有何种操作权限。
在众多的授权模型中，基于角色的访问控制（Role-Based Access Control，简称RBAC） 无疑是最为经典和广泛应用的一种。它通过引入“角色”这一中间层，极大地简化了权限管理，并提升了系统的安全性和可维护性。
1. RBAC的核心概念：用户、角色、权限与会话
RBAC模型的核心在于将权限直接赋给用户，转变为将权限赋给角色，再将角色赋给用户。这种间接管理方式带来了巨大的灵活性和可伸缩性。
1.1 用户（User）
定义： 在RBAC模型中，用户是实际操作系统的实体，可以是个人、应用程序或服务账户。
在RBAC中的作用： 用户是权限的最终执行者。用户通过分配获得一个或多个角色，从而继承了这些角色所关联的权限。
1.2 角色（Role）
定义： 角色是一组具有逻辑关联的权限的集合，代表了某个职能或部门在系统中所需执行的任务。例如，“销售经理”、“财务主管”、“系统管理员”等。
在RBAC中的作用： 角色是RBAC模型的核心。它充当了用户与权限之间的桥梁。权限不直接分配给用户，而是先分配给角色，然后将用户分配给角色。这种抽象极大地简化了权限管理：当用户的职责变化时，只需调整其角色分配，而无需修改大量独立的权限。
1.3 权限（Permission/Privilege）
定义： 权限是系统允许执行的特定操作或对特定资源（对象）的访问能力。通常表示为“对某个资源执行某个操作”。例如，“读取客户信息”、“修改订单”、“删除用户”等。
在RBAC中的作用： 权限是授权的基本粒度。权限是原子性的，是最小的可授予单位。RBAC通过将这些原子权限组合成角色，从而实现更高级别的管理。
1.4 会话（Session）
定义： 会话代表了用户在某个特定时间点激活的角色集合。
在RBAC中的作用： 当用户登录系统时，他们可能被分配了多个角色。但在一个特定的会话中，用户可能只激活其中一部分角色。会话用于在用户当前访问上下文中，确定其具体可用的权限。
2. RBAC模型的变种：从基础到复杂
RBAC模型并非单一不变，而是存在一系列层次，从最基础的RBAC0到更复杂的RBAC1、RBAC2和RBAC3，它们在继承性、约束条件等方面有所区别。
2.1 RBAC0：核心RBAC

特点： 这是RBAC模型的最基本形式，定义了用户、角色和权限以及它们之间的分配关系。

用户可以被分配给一个或多个角色。
角色可以包含一个或多个权限。


用途： 适用于简单的权限管理场景，但缺乏角色继承和权限分离等高级功能。

2.2 RBAC1：带角色继承的RBAC（Hierarchical RBAC）

特点： 在RBAC0的基础上引入了角色继承（Role Hierarchy） 的概念。角色之间可以形成上下级关系，子角色自动继承父角色的所有权限。

例如，“部门经理”角色可以继承“普通员工”角色的所有权限，并在此基础上增加管理权限。


用途： 极大简化了拥有递进权限层级的组织结构（如公司层级、部门层级）的权限管理，减少了重复的权限配置。

2.3 RBAC2：带约束的RBAC（Constrained RBAC）

特点： 在RBAC0的基础上增加了各种约束（Constraints） 条件，以满足更复杂的安全策略和业务需求。这些约束可以是：

职责分离（Separation of Duty, SoD）： 强制用户不能同时拥有冲突的角色，以防止潜在的欺诈或错误。例如，一个用户不能同时拥有“创建订单”和“批准支付”的角色。
基数约束（Cardinality Constraints）： 限制用户可以拥有的角色数量、角色可以拥有的权限数量、角色中用户的最大数量等。
先决条件（Prerequisite Roles）： 在分配某个角色之前，用户必须先拥有另一个或某些角色。


用途： 适用于需要严格控制风险、防止内部欺诈、符合审计和合规性要求的复杂业务场景。

2.4 RBAC3：统一RBAC（Unified RBAC）

特点： RBAC3是RBAC1（角色继承）和RBAC2（约束）的结合体，提供了最全面的RBAC功能。
用途： 适用于大型、复杂的企业级应用，能够应对最严格的权限管理需求。

3. RBAC的设计原则与实践
成功的RBAC实施需要遵循一些设计原则和最佳实践："><meta name=author content><link rel=canonical href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC10%E7%AF%87%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E7%9A%84%E7%BB%8F%E5%85%B8%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6rbac%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://bsong2015.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bsong2015.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bsong2015.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://bsong2015.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://bsong2015.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC10%E7%AF%87%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E7%9A%84%E7%BB%8F%E5%85%B8%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6rbac%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC10%E7%AF%87%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E7%9A%84%E7%BB%8F%E5%85%B8%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6rbac%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"><meta property="og:site_name" content="万年水的博客"><meta property="og:title" content="万年水的博客"><meta property="og:description" content="第10篇：权限控制的经典：基于角色的访问控制（RBAC）模型详解 在之前的文章中，我们详细探讨了身份认证（Authentication）的各种机制，解决了“你是谁？”的问题。然而，仅仅验证了用户的身份是不够的，我们还需要回答更关键的问题：“你能做什么？”这正是授权（Authorization） 的核心任务。授权决定了已认证的用户对系统中的哪些资源拥有何种操作权限。
在众多的授权模型中，基于角色的访问控制（Role-Based Access Control，简称RBAC） 无疑是最为经典和广泛应用的一种。它通过引入“角色”这一中间层，极大地简化了权限管理，并提升了系统的安全性和可维护性。
1. RBAC的核心概念：用户、角色、权限与会话 RBAC模型的核心在于将权限直接赋给用户，转变为将权限赋给角色，再将角色赋给用户。这种间接管理方式带来了巨大的灵活性和可伸缩性。
1.1 用户（User） 定义： 在RBAC模型中，用户是实际操作系统的实体，可以是个人、应用程序或服务账户。
在RBAC中的作用： 用户是权限的最终执行者。用户通过分配获得一个或多个角色，从而继承了这些角色所关联的权限。
1.2 角色（Role） 定义： 角色是一组具有逻辑关联的权限的集合，代表了某个职能或部门在系统中所需执行的任务。例如，“销售经理”、“财务主管”、“系统管理员”等。
在RBAC中的作用： 角色是RBAC模型的核心。它充当了用户与权限之间的桥梁。权限不直接分配给用户，而是先分配给角色，然后将用户分配给角色。这种抽象极大地简化了权限管理：当用户的职责变化时，只需调整其角色分配，而无需修改大量独立的权限。
1.3 权限（Permission/Privilege） 定义： 权限是系统允许执行的特定操作或对特定资源（对象）的访问能力。通常表示为“对某个资源执行某个操作”。例如，“读取客户信息”、“修改订单”、“删除用户”等。
在RBAC中的作用： 权限是授权的基本粒度。权限是原子性的，是最小的可授予单位。RBAC通过将这些原子权限组合成角色，从而实现更高级别的管理。
1.4 会话（Session） 定义： 会话代表了用户在某个特定时间点激活的角色集合。
在RBAC中的作用： 当用户登录系统时，他们可能被分配了多个角色。但在一个特定的会话中，用户可能只激活其中一部分角色。会话用于在用户当前访问上下文中，确定其具体可用的权限。
2. RBAC模型的变种：从基础到复杂 RBAC模型并非单一不变，而是存在一系列层次，从最基础的RBAC0到更复杂的RBAC1、RBAC2和RBAC3，它们在继承性、约束条件等方面有所区别。
2.1 RBAC0：核心RBAC 特点： 这是RBAC模型的最基本形式，定义了用户、角色和权限以及它们之间的分配关系。 用户可以被分配给一个或多个角色。 角色可以包含一个或多个权限。 用途： 适用于简单的权限管理场景，但缺乏角色继承和权限分离等高级功能。 2.2 RBAC1：带角色继承的RBAC（Hierarchical RBAC） 特点： 在RBAC0的基础上引入了角色继承（Role Hierarchy） 的概念。角色之间可以形成上下级关系，子角色自动继承父角色的所有权限。 例如，“部门经理”角色可以继承“普通员工”角色的所有权限，并在此基础上增加管理权限。 用途： 极大简化了拥有递进权限层级的组织结构（如公司层级、部门层级）的权限管理，减少了重复的权限配置。 2.3 RBAC2：带约束的RBAC（Constrained RBAC） 特点： 在RBAC0的基础上增加了各种约束（Constraints） 条件，以满足更复杂的安全策略和业务需求。这些约束可以是： 职责分离（Separation of Duty, SoD）： 强制用户不能同时拥有冲突的角色，以防止潜在的欺诈或错误。例如，一个用户不能同时拥有“创建订单”和“批准支付”的角色。 基数约束（Cardinality Constraints）： 限制用户可以拥有的角色数量、角色可以拥有的权限数量、角色中用户的最大数量等。 先决条件（Prerequisite Roles）： 在分配某个角色之前，用户必须先拥有另一个或某些角色。 用途： 适用于需要严格控制风险、防止内部欺诈、符合审计和合规性要求的复杂业务场景。 2.4 RBAC3：统一RBAC（Unified RBAC） 特点： RBAC3是RBAC1（角色继承）和RBAC2（约束）的结合体，提供了最全面的RBAC功能。 用途： 适用于大型、复杂的企业级应用，能够应对最严格的权限管理需求。 3. RBAC的设计原则与实践 成功的RBAC实施需要遵循一些设计原则和最佳实践："><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="第10篇：权限控制的经典：基于角色的访问控制（RBAC）模型详解
在之前的文章中，我们详细探讨了身份认证（Authentication）的各种机制，解决了“你是谁？”的问题。然而，仅仅验证了用户的身份是不够的，我们还需要回答更关键的问题：“你能做什么？”这正是授权（Authorization） 的核心任务。授权决定了已认证的用户对系统中的哪些资源拥有何种操作权限。
在众多的授权模型中，基于角色的访问控制（Role-Based Access Control，简称RBAC） 无疑是最为经典和广泛应用的一种。它通过引入“角色”这一中间层，极大地简化了权限管理，并提升了系统的安全性和可维护性。
1. RBAC的核心概念：用户、角色、权限与会话
RBAC模型的核心在于将权限直接赋给用户，转变为将权限赋给角色，再将角色赋给用户。这种间接管理方式带来了巨大的灵活性和可伸缩性。
1.1 用户（User）
定义： 在RBAC模型中，用户是实际操作系统的实体，可以是个人、应用程序或服务账户。
在RBAC中的作用： 用户是权限的最终执行者。用户通过分配获得一个或多个角色，从而继承了这些角色所关联的权限。
1.2 角色（Role）
定义： 角色是一组具有逻辑关联的权限的集合，代表了某个职能或部门在系统中所需执行的任务。例如，“销售经理”、“财务主管”、“系统管理员”等。
在RBAC中的作用： 角色是RBAC模型的核心。它充当了用户与权限之间的桥梁。权限不直接分配给用户，而是先分配给角色，然后将用户分配给角色。这种抽象极大地简化了权限管理：当用户的职责变化时，只需调整其角色分配，而无需修改大量独立的权限。
1.3 权限（Permission/Privilege）
定义： 权限是系统允许执行的特定操作或对特定资源（对象）的访问能力。通常表示为“对某个资源执行某个操作”。例如，“读取客户信息”、“修改订单”、“删除用户”等。
在RBAC中的作用： 权限是授权的基本粒度。权限是原子性的，是最小的可授予单位。RBAC通过将这些原子权限组合成角色，从而实现更高级别的管理。
1.4 会话（Session）
定义： 会话代表了用户在某个特定时间点激活的角色集合。
在RBAC中的作用： 当用户登录系统时，他们可能被分配了多个角色。但在一个特定的会话中，用户可能只激活其中一部分角色。会话用于在用户当前访问上下文中，确定其具体可用的权限。
2. RBAC模型的变种：从基础到复杂
RBAC模型并非单一不变，而是存在一系列层次，从最基础的RBAC0到更复杂的RBAC1、RBAC2和RBAC3，它们在继承性、约束条件等方面有所区别。
2.1 RBAC0：核心RBAC

特点： 这是RBAC模型的最基本形式，定义了用户、角色和权限以及它们之间的分配关系。

用户可以被分配给一个或多个角色。
角色可以包含一个或多个权限。


用途： 适用于简单的权限管理场景，但缺乏角色继承和权限分离等高级功能。

2.2 RBAC1：带角色继承的RBAC（Hierarchical RBAC）

特点： 在RBAC0的基础上引入了角色继承（Role Hierarchy） 的概念。角色之间可以形成上下级关系，子角色自动继承父角色的所有权限。

例如，“部门经理”角色可以继承“普通员工”角色的所有权限，并在此基础上增加管理权限。


用途： 极大简化了拥有递进权限层级的组织结构（如公司层级、部门层级）的权限管理，减少了重复的权限配置。

2.3 RBAC2：带约束的RBAC（Constrained RBAC）

特点： 在RBAC0的基础上增加了各种约束（Constraints） 条件，以满足更复杂的安全策略和业务需求。这些约束可以是：

职责分离（Separation of Duty, SoD）： 强制用户不能同时拥有冲突的角色，以防止潜在的欺诈或错误。例如，一个用户不能同时拥有“创建订单”和“批准支付”的角色。
基数约束（Cardinality Constraints）： 限制用户可以拥有的角色数量、角色可以拥有的权限数量、角色中用户的最大数量等。
先决条件（Prerequisite Roles）： 在分配某个角色之前，用户必须先拥有另一个或某些角色。


用途： 适用于需要严格控制风险、防止内部欺诈、符合审计和合规性要求的复杂业务场景。

2.4 RBAC3：统一RBAC（Unified RBAC）

特点： RBAC3是RBAC1（角色继承）和RBAC2（约束）的结合体，提供了最全面的RBAC功能。
用途： 适用于大型、复杂的企业级应用，能够应对最严格的权限管理需求。

3. RBAC的设计原则与实践
成功的RBAC实施需要遵循一些设计原则和最佳实践："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bsong2015.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"技术实践","item":"https://bsong2015.github.io/blog/posts/technology/"},{"@type":"ListItem","position":3,"name":"","item":"https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC10%E7%AF%87%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E7%9A%84%E7%BB%8F%E5%85%B8%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6rbac%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"第10篇：权限控制的经典：基于角色的访问控制（RBAC）模型详解 在之前的文章中，我们详细探讨了身份认证（Authentication）的各种机制，解决了“你是谁？”的问题。然而，仅仅验证了用户的身份是不够的，我们还需要回答更关键的问题：“你能做什么？”这正是授权（Authorization） 的核心任务。授权决定了已认证的用户对系统中的哪些资源拥有何种操作权限。\n在众多的授权模型中，基于角色的访问控制（Role-Based Access Control，简称RBAC） 无疑是最为经典和广泛应用的一种。它通过引入“角色”这一中间层，极大地简化了权限管理，并提升了系统的安全性和可维护性。\n1. RBAC的核心概念：用户、角色、权限与会话 RBAC模型的核心在于将权限直接赋给用户，转变为将权限赋给角色，再将角色赋给用户。这种间接管理方式带来了巨大的灵活性和可伸缩性。\n1.1 用户（User） 定义： 在RBAC模型中，用户是实际操作系统的实体，可以是个人、应用程序或服务账户。\n在RBAC中的作用： 用户是权限的最终执行者。用户通过分配获得一个或多个角色，从而继承了这些角色所关联的权限。\n1.2 角色（Role） 定义： 角色是一组具有逻辑关联的权限的集合，代表了某个职能或部门在系统中所需执行的任务。例如，“销售经理”、“财务主管”、“系统管理员”等。\n在RBAC中的作用： 角色是RBAC模型的核心。它充当了用户与权限之间的桥梁。权限不直接分配给用户，而是先分配给角色，然后将用户分配给角色。这种抽象极大地简化了权限管理：当用户的职责变化时，只需调整其角色分配，而无需修改大量独立的权限。\n1.3 权限（Permission/Privilege） 定义： 权限是系统允许执行的特定操作或对特定资源（对象）的访问能力。通常表示为“对某个资源执行某个操作”。例如，“读取客户信息”、“修改订单”、“删除用户”等。\n在RBAC中的作用： 权限是授权的基本粒度。权限是原子性的，是最小的可授予单位。RBAC通过将这些原子权限组合成角色，从而实现更高级别的管理。\n1.4 会话（Session） 定义： 会话代表了用户在某个特定时间点激活的角色集合。\n在RBAC中的作用： 当用户登录系统时，他们可能被分配了多个角色。但在一个特定的会话中，用户可能只激活其中一部分角色。会话用于在用户当前访问上下文中，确定其具体可用的权限。\n2. RBAC模型的变种：从基础到复杂 RBAC模型并非单一不变，而是存在一系列层次，从最基础的RBAC0到更复杂的RBAC1、RBAC2和RBAC3，它们在继承性、约束条件等方面有所区别。\n2.1 RBAC0：核心RBAC 特点： 这是RBAC模型的最基本形式，定义了用户、角色和权限以及它们之间的分配关系。 用户可以被分配给一个或多个角色。 角色可以包含一个或多个权限。 用途： 适用于简单的权限管理场景，但缺乏角色继承和权限分离等高级功能。 2.2 RBAC1：带角色继承的RBAC（Hierarchical RBAC） 特点： 在RBAC0的基础上引入了角色继承（Role Hierarchy） 的概念。角色之间可以形成上下级关系，子角色自动继承父角色的所有权限。 例如，“部门经理”角色可以继承“普通员工”角色的所有权限，并在此基础上增加管理权限。 用途： 极大简化了拥有递进权限层级的组织结构（如公司层级、部门层级）的权限管理，减少了重复的权限配置。 2.3 RBAC2：带约束的RBAC（Constrained RBAC） 特点： 在RBAC0的基础上增加了各种约束（Constraints） 条件，以满足更复杂的安全策略和业务需求。这些约束可以是： 职责分离（Separation of Duty, SoD）： 强制用户不能同时拥有冲突的角色，以防止潜在的欺诈或错误。例如，一个用户不能同时拥有“创建订单”和“批准支付”的角色。 基数约束（Cardinality Constraints）： 限制用户可以拥有的角色数量、角色可以拥有的权限数量、角色中用户的最大数量等。 先决条件（Prerequisite Roles）： 在分配某个角色之前，用户必须先拥有另一个或某些角色。 用途： 适用于需要严格控制风险、防止内部欺诈、符合审计和合规性要求的复杂业务场景。 2.4 RBAC3：统一RBAC（Unified RBAC） 特点： RBAC3是RBAC1（角色继承）和RBAC2（约束）的结合体，提供了最全面的RBAC功能。 用途： 适用于大型、复杂的企业级应用，能够应对最严格的权限管理需求。 3. RBAC的设计原则与实践 成功的RBAC实施需要遵循一些设计原则和最佳实践：\n","keywords":[],"articleBody":"第10篇：权限控制的经典：基于角色的访问控制（RBAC）模型详解 在之前的文章中，我们详细探讨了身份认证（Authentication）的各种机制，解决了“你是谁？”的问题。然而，仅仅验证了用户的身份是不够的，我们还需要回答更关键的问题：“你能做什么？”这正是授权（Authorization） 的核心任务。授权决定了已认证的用户对系统中的哪些资源拥有何种操作权限。\n在众多的授权模型中，基于角色的访问控制（Role-Based Access Control，简称RBAC） 无疑是最为经典和广泛应用的一种。它通过引入“角色”这一中间层，极大地简化了权限管理，并提升了系统的安全性和可维护性。\n1. RBAC的核心概念：用户、角色、权限与会话 RBAC模型的核心在于将权限直接赋给用户，转变为将权限赋给角色，再将角色赋给用户。这种间接管理方式带来了巨大的灵活性和可伸缩性。\n1.1 用户（User） 定义： 在RBAC模型中，用户是实际操作系统的实体，可以是个人、应用程序或服务账户。\n在RBAC中的作用： 用户是权限的最终执行者。用户通过分配获得一个或多个角色，从而继承了这些角色所关联的权限。\n1.2 角色（Role） 定义： 角色是一组具有逻辑关联的权限的集合，代表了某个职能或部门在系统中所需执行的任务。例如，“销售经理”、“财务主管”、“系统管理员”等。\n在RBAC中的作用： 角色是RBAC模型的核心。它充当了用户与权限之间的桥梁。权限不直接分配给用户，而是先分配给角色，然后将用户分配给角色。这种抽象极大地简化了权限管理：当用户的职责变化时，只需调整其角色分配，而无需修改大量独立的权限。\n1.3 权限（Permission/Privilege） 定义： 权限是系统允许执行的特定操作或对特定资源（对象）的访问能力。通常表示为“对某个资源执行某个操作”。例如，“读取客户信息”、“修改订单”、“删除用户”等。\n在RBAC中的作用： 权限是授权的基本粒度。权限是原子性的，是最小的可授予单位。RBAC通过将这些原子权限组合成角色，从而实现更高级别的管理。\n1.4 会话（Session） 定义： 会话代表了用户在某个特定时间点激活的角色集合。\n在RBAC中的作用： 当用户登录系统时，他们可能被分配了多个角色。但在一个特定的会话中，用户可能只激活其中一部分角色。会话用于在用户当前访问上下文中，确定其具体可用的权限。\n2. RBAC模型的变种：从基础到复杂 RBAC模型并非单一不变，而是存在一系列层次，从最基础的RBAC0到更复杂的RBAC1、RBAC2和RBAC3，它们在继承性、约束条件等方面有所区别。\n2.1 RBAC0：核心RBAC 特点： 这是RBAC模型的最基本形式，定义了用户、角色和权限以及它们之间的分配关系。 用户可以被分配给一个或多个角色。 角色可以包含一个或多个权限。 用途： 适用于简单的权限管理场景，但缺乏角色继承和权限分离等高级功能。 2.2 RBAC1：带角色继承的RBAC（Hierarchical RBAC） 特点： 在RBAC0的基础上引入了角色继承（Role Hierarchy） 的概念。角色之间可以形成上下级关系，子角色自动继承父角色的所有权限。 例如，“部门经理”角色可以继承“普通员工”角色的所有权限，并在此基础上增加管理权限。 用途： 极大简化了拥有递进权限层级的组织结构（如公司层级、部门层级）的权限管理，减少了重复的权限配置。 2.3 RBAC2：带约束的RBAC（Constrained RBAC） 特点： 在RBAC0的基础上增加了各种约束（Constraints） 条件，以满足更复杂的安全策略和业务需求。这些约束可以是： 职责分离（Separation of Duty, SoD）： 强制用户不能同时拥有冲突的角色，以防止潜在的欺诈或错误。例如，一个用户不能同时拥有“创建订单”和“批准支付”的角色。 基数约束（Cardinality Constraints）： 限制用户可以拥有的角色数量、角色可以拥有的权限数量、角色中用户的最大数量等。 先决条件（Prerequisite Roles）： 在分配某个角色之前，用户必须先拥有另一个或某些角色。 用途： 适用于需要严格控制风险、防止内部欺诈、符合审计和合规性要求的复杂业务场景。 2.4 RBAC3：统一RBAC（Unified RBAC） 特点： RBAC3是RBAC1（角色继承）和RBAC2（约束）的结合体，提供了最全面的RBAC功能。 用途： 适用于大型、复杂的企业级应用，能够应对最严格的权限管理需求。 3. RBAC的设计原则与实践 成功的RBAC实施需要遵循一些设计原则和最佳实践：\n3.1 最小权限原则（Principle of Least Privilege） 原则： 用户或角色应该只被授予完成其任务所需的最小权限集合。不必要的权限会增加安全风险。 实践： 在设计角色时，仔细分析每个职能所需的具体权限。 定期审查用户和角色的权限分配，移除不再需要的权限。 3.2 职责分离（Separation of Duty, SoD） 原则： 避免单个用户拥有执行关键业务流程中所有步骤的权限，以防止欺诈、错误和滥用。 实践： 识别关键业务流程中的冲突权限（例如，“创建付款”和“批准付款”）。 将这些冲突权限分配给不同的角色，并确保一个用户不能同时拥有这些冲突角色（RBAC2中的约束）。 3.3 角色粒度适中 原则： 角色不应过于宽泛（导致权限过大），也不应过于细碎（导致管理复杂）。 实践： 基于组织架构、部门职能、岗位职责来定义角色。 通过角色继承（RBAC1）来处理权限递进，避免创建大量重复角色。 当发现大量用户拥有相同的自定义权限组合时，考虑将其抽象为一个新角色。 3.4 权限粒度精细 原则： 权限应该足够精细，以便能够精确控制对资源的访问。例如，不只是“编辑文档”，而是“编辑客户A的合同文档”。 实践： 定义权限时，考虑操作（读、写、删除）、资源类型（客户、订单、报表）和可能的资源实例（特定客户ID）。 在Java实践中，这通常意味着在业务层面对权限进行细粒度控制，结合资源的拥有者、状态等属性进行二次判断。 3.5 审计与监控 原则： 对所有权限相关的操作（角色分配、权限修改、访问尝试）进行记录和监控。 实践： 确保IAM系统能够记录详细的审计日志。 定期审查审计日志，识别异常行为和潜在的安全漏洞。 3.6 结合属性和策略（为ABAC/PBAC铺垫） 原则： 对于某些极度动态或细粒度的授权场景，纯粹的RBAC可能力不从心。可以考虑与ABAC（基于属性的访问控制）或PBAC（基于策略的访问控制）结合。 实践： RBAC负责粗粒度的权限分配（“谁能做什么类型的操作”）。 ABAC/PBAC负责细粒度的运行时决策（“谁能在什么情况下、对哪些具体数据实例进行操作”）。例如，一个“部门经理”角色（RBAC）可能拥有“查看员工绩效”的权限，但只能查看其本部门员工的绩效（ABAC基于部门属性）。 总结 基于角色的访问控制（RBAC）是授权管理领域一个经过时间考验的经典模型。它通过引入“角色”这一抽象层，极大地简化了复杂的权限管理工作，提升了系统的安全性和可维护性。从基本的RBAC0，到支持角色继承的RBAC1，再到加入约束条件的RBAC2和融合两者的RBAC3，RBAC模型能够满足从简单到复杂的各类企业授权需求。\n理解RBAC的核心概念、不同变种及其设计原则，是成功构建任何授权系统的基石。虽然RBAC在某些极端复杂的细粒度场景下可能需要与其他授权模型（如ABAC）结合使用，但其作为权限控制的“经典”，在绝大多数企业应用中仍然是首选和核心。下一篇我们将探讨另一种日益重要的授权模型——基于属性的访问控制（ABAC）。\n欢迎关注+点赞+推荐+转发\n","wordCount":"137","inLanguage":"zh","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC10%E7%AF%87%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E7%9A%84%E7%BB%8F%E5%85%B8%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6rbac%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"},"publisher":{"@type":"Organization","name":"万年水的博客","logo":{"@type":"ImageObject","url":"https://bsong2015.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bsong2015.github.io/blog/ accesskey=h title="万年水的博客 (Alt + H)">万年水的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bsong2015.github.io/blog/posts/artificial-intelligence/ title=人工智能><span>人工智能</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/reading/ title=阅读><span>阅读</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/thinking-models/ title=思维模型><span>思维模型</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/thought-experiments/ title=思想实验><span>思想实验</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/personal-growth/ title=个人成长><span>个人成长</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/technology/ title=技术><span>技术</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/current-affairs/ title=时事><span>时事</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/others/ title=其它><span>其它</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent"></h1><div class=post-meta></div></header><div class=post-content><h2 id=第10篇权限控制的经典基于角色的访问控制rbac模型详解>第10篇：权限控制的经典：基于角色的访问控制（RBAC）模型详解<a hidden class=anchor aria-hidden=true href=#第10篇权限控制的经典基于角色的访问控制rbac模型详解>#</a></h2><p>在之前的文章中，我们详细探讨了身份认证（Authentication）的各种机制，解决了“你是谁？”的问题。然而，仅仅验证了用户的身份是不够的，我们还需要回答更关键的问题：“你能做什么？”这正是<strong>授权（Authorization）</strong> 的核心任务。授权决定了已认证的用户对系统中的哪些资源拥有何种操作权限。</p><p>在众多的授权模型中，<strong>基于角色的访问控制（Role-Based Access Control，简称RBAC）</strong> 无疑是最为经典和广泛应用的一种。它通过引入“角色”这一中间层，极大地简化了权限管理，并提升了系统的安全性和可维护性。</p><h3 id=1-rbac的核心概念用户角色权限与会话>1. RBAC的核心概念：用户、角色、权限与会话<a hidden class=anchor aria-hidden=true href=#1-rbac的核心概念用户角色权限与会话>#</a></h3><p>RBAC模型的核心在于将权限直接赋给用户，转变为将<strong>权限赋给角色，再将角色赋给用户</strong>。这种间接管理方式带来了巨大的灵活性和可伸缩性。</p><h4 id=11-用户user>1.1 用户（User）<a hidden class=anchor aria-hidden=true href=#11-用户user>#</a></h4><p><strong>定义：</strong> 在RBAC模型中，用户是实际操作系统的实体，可以是个人、应用程序或服务账户。</p><p><strong>在RBAC中的作用：</strong> 用户是权限的最终执行者。用户通过分配获得一个或多个角色，从而继承了这些角色所关联的权限。</p><h4 id=12-角色role>1.2 角色（Role）<a hidden class=anchor aria-hidden=true href=#12-角色role>#</a></h4><p><strong>定义：</strong> 角色是一组具有逻辑关联的权限的集合，代表了某个职能或部门在系统中所需执行的任务。例如，“销售经理”、“财务主管”、“系统管理员”等。</p><p><strong>在RBAC中的作用：</strong> 角色是RBAC模型的核心。它充当了用户与权限之间的桥梁。权限不直接分配给用户，而是先分配给角色，然后将用户分配给角色。这种抽象极大地简化了权限管理：当用户的职责变化时，只需调整其角色分配，而无需修改大量独立的权限。</p><h4 id=13-权限permissionprivilege>1.3 权限（Permission/Privilege）<a hidden class=anchor aria-hidden=true href=#13-权限permissionprivilege>#</a></h4><p><strong>定义：</strong> 权限是系统允许执行的特定操作或对特定资源（对象）的访问能力。通常表示为“对某个资源执行某个操作”。例如，“读取客户信息”、“修改订单”、“删除用户”等。</p><p><strong>在RBAC中的作用：</strong> 权限是授权的基本粒度。权限是原子性的，是最小的可授予单位。RBAC通过将这些原子权限组合成角色，从而实现更高级别的管理。</p><h4 id=14-会话session>1.4 会话（Session）<a hidden class=anchor aria-hidden=true href=#14-会话session>#</a></h4><p><strong>定义：</strong> 会话代表了用户在某个特定时间点激活的角色集合。</p><p><strong>在RBAC中的作用：</strong> 当用户登录系统时，他们可能被分配了多个角色。但在一个特定的会话中，用户可能只激活其中一部分角色。会话用于在用户当前访问上下文中，确定其具体可用的权限。</p><h3 id=2-rbac模型的变种从基础到复杂>2. RBAC模型的变种：从基础到复杂<a hidden class=anchor aria-hidden=true href=#2-rbac模型的变种从基础到复杂>#</a></h3><p>RBAC模型并非单一不变，而是存在一系列层次，从最基础的RBAC0到更复杂的RBAC1、RBAC2和RBAC3，它们在继承性、约束条件等方面有所区别。</p><h4 id=21-rbac0核心rbac>2.1 RBAC0：核心RBAC<a hidden class=anchor aria-hidden=true href=#21-rbac0核心rbac>#</a></h4><ul><li><strong>特点：</strong> 这是RBAC模型的最基本形式，定义了用户、角色和权限以及它们之间的分配关系。<ul><li>用户可以被分配给一个或多个角色。</li><li>角色可以包含一个或多个权限。</li></ul></li><li><strong>用途：</strong> 适用于简单的权限管理场景，但缺乏角色继承和权限分离等高级功能。</li></ul><h4 id=22-rbac1带角色继承的rbachierarchical-rbac>2.2 RBAC1：带角色继承的RBAC（Hierarchical RBAC）<a hidden class=anchor aria-hidden=true href=#22-rbac1带角色继承的rbachierarchical-rbac>#</a></h4><ul><li><strong>特点：</strong> 在RBAC0的基础上引入了<strong>角色继承（Role Hierarchy）</strong> 的概念。角色之间可以形成上下级关系，子角色自动继承父角色的所有权限。<ul><li>例如，“部门经理”角色可以继承“普通员工”角色的所有权限，并在此基础上增加管理权限。</li></ul></li><li><strong>用途：</strong> 极大简化了拥有递进权限层级的组织结构（如公司层级、部门层级）的权限管理，减少了重复的权限配置。</li></ul><h4 id=23-rbac2带约束的rbacconstrained-rbac>2.3 RBAC2：带约束的RBAC（Constrained RBAC）<a hidden class=anchor aria-hidden=true href=#23-rbac2带约束的rbacconstrained-rbac>#</a></h4><ul><li><strong>特点：</strong> 在RBAC0的基础上增加了各种<strong>约束（Constraints）</strong> 条件，以满足更复杂的安全策略和业务需求。这些约束可以是：<ul><li><strong>职责分离（Separation of Duty, SoD）：</strong> 强制用户不能同时拥有冲突的角色，以防止潜在的欺诈或错误。例如，一个用户不能同时拥有“创建订单”和“批准支付”的角色。</li><li><strong>基数约束（Cardinality Constraints）：</strong> 限制用户可以拥有的角色数量、角色可以拥有的权限数量、角色中用户的最大数量等。</li><li><strong>先决条件（Prerequisite Roles）：</strong> 在分配某个角色之前，用户必须先拥有另一个或某些角色。</li></ul></li><li><strong>用途：</strong> 适用于需要严格控制风险、防止内部欺诈、符合审计和合规性要求的复杂业务场景。</li></ul><h4 id=24-rbac3统一rbacunified-rbac>2.4 RBAC3：统一RBAC（Unified RBAC）<a hidden class=anchor aria-hidden=true href=#24-rbac3统一rbacunified-rbac>#</a></h4><ul><li><strong>特点：</strong> RBAC3是RBAC1（角色继承）和RBAC2（约束）的结合体，提供了最全面的RBAC功能。</li><li><strong>用途：</strong> 适用于大型、复杂的企业级应用，能够应对最严格的权限管理需求。</li></ul><h3 id=3-rbac的设计原则与实践>3. RBAC的设计原则与实践<a hidden class=anchor aria-hidden=true href=#3-rbac的设计原则与实践>#</a></h3><p>成功的RBAC实施需要遵循一些设计原则和最佳实践：</p><h4 id=31-最小权限原则principle-of-least-privilege>3.1 最小权限原则（Principle of Least Privilege）<a hidden class=anchor aria-hidden=true href=#31-最小权限原则principle-of-least-privilege>#</a></h4><ul><li><strong>原则：</strong> 用户或角色应该只被授予完成其任务所需的最小权限集合。不必要的权限会增加安全风险。</li><li><strong>实践：</strong><ul><li>在设计角色时，仔细分析每个职能所需的具体权限。</li><li>定期审查用户和角色的权限分配，移除不再需要的权限。</li></ul></li></ul><h4 id=32-职责分离separation-of-duty-sod>3.2 职责分离（Separation of Duty, SoD）<a hidden class=anchor aria-hidden=true href=#32-职责分离separation-of-duty-sod>#</a></h4><ul><li><strong>原则：</strong> 避免单个用户拥有执行关键业务流程中所有步骤的权限，以防止欺诈、错误和滥用。</li><li><strong>实践：</strong><ul><li>识别关键业务流程中的冲突权限（例如，“创建付款”和“批准付款”）。</li><li>将这些冲突权限分配给不同的角色，并确保一个用户不能同时拥有这些冲突角色（RBAC2中的约束）。</li></ul></li></ul><h4 id=33-角色粒度适中>3.3 角色粒度适中<a hidden class=anchor aria-hidden=true href=#33-角色粒度适中>#</a></h4><ul><li><strong>原则：</strong> 角色不应过于宽泛（导致权限过大），也不应过于细碎（导致管理复杂）。</li><li><strong>实践：</strong><ul><li>基于组织架构、部门职能、岗位职责来定义角色。</li><li>通过角色继承（RBAC1）来处理权限递进，避免创建大量重复角色。</li><li>当发现大量用户拥有相同的自定义权限组合时，考虑将其抽象为一个新角色。</li></ul></li></ul><h4 id=34-权限粒度精细>3.4 权限粒度精细<a hidden class=anchor aria-hidden=true href=#34-权限粒度精细>#</a></h4><ul><li><strong>原则：</strong> 权限应该足够精细，以便能够精确控制对资源的访问。例如，不只是“编辑文档”，而是“编辑客户A的合同文档”。</li><li><strong>实践：</strong><ul><li>定义权限时，考虑操作（读、写、删除）、资源类型（客户、订单、报表）和可能的资源实例（特定客户ID）。</li><li>在Java实践中，这通常意味着在业务层面对权限进行细粒度控制，结合资源的拥有者、状态等属性进行二次判断。</li></ul></li></ul><h4 id=35-审计与监控>3.5 审计与监控<a hidden class=anchor aria-hidden=true href=#35-审计与监控>#</a></h4><ul><li><strong>原则：</strong> 对所有权限相关的操作（角色分配、权限修改、访问尝试）进行记录和监控。</li><li><strong>实践：</strong><ul><li>确保IAM系统能够记录详细的审计日志。</li><li>定期审查审计日志，识别异常行为和潜在的安全漏洞。</li></ul></li></ul><h4 id=36-结合属性和策略为abacpbac铺垫>3.6 结合属性和策略（为ABAC/PBAC铺垫）<a hidden class=anchor aria-hidden=true href=#36-结合属性和策略为abacpbac铺垫>#</a></h4><ul><li><strong>原则：</strong> 对于某些极度动态或细粒度的授权场景，纯粹的RBAC可能力不从心。可以考虑与ABAC（基于属性的访问控制）或PBAC（基于策略的访问控制）结合。</li><li><strong>实践：</strong><ul><li>RBAC负责粗粒度的权限分配（“谁能做什么类型的操作”）。</li><li>ABAC/PBAC负责细粒度的运行时决策（“谁能在什么情况下、对哪些具体数据实例进行操作”）。例如，一个“部门经理”角色（RBAC）可能拥有“查看员工绩效”的权限，但只能查看其<strong>本部门</strong>员工的绩效（ABAC基于部门属性）。</li></ul></li></ul><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><p>基于角色的访问控制（RBAC）是授权管理领域一个经过时间考验的经典模型。它通过引入“角色”这一抽象层，极大地简化了复杂的权限管理工作，提升了系统的安全性和可维护性。从基本的RBAC0，到支持角色继承的RBAC1，再到加入约束条件的RBAC2和融合两者的RBAC3，RBAC模型能够满足从简单到复杂的各类企业授权需求。</p><p>理解RBAC的核心概念、不同变种及其设计原则，是成功构建任何授权系统的基石。虽然RBAC在某些极端复杂的细粒度场景下可能需要与其他授权模型（如ABAC）结合使用，但其作为权限控制的“经典”，在绝大多数企业应用中仍然是首选和核心。下一篇我们将探讨另一种日益重要的授权模型——基于属性的访问控制（ABAC）。</p><h3></h3><p><strong>欢迎关注+点赞+推荐+转发</strong></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bsong2015.github.io/blog/>万年水的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>