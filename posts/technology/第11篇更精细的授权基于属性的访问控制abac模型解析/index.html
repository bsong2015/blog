<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>万年水的博客</title><meta name=keywords content><meta name=description content='第11篇：更精细的授权：基于属性的访问控制（ABAC）模型解析
在上一篇文章中，我们详细讲解了基于角色的访问控制（RBAC）模型，它通过将权限与角色关联，再将角色分配给用户，极大地简化了权限管理。然而，在面对日益复杂、动态变化的业务场景时，仅仅依靠预定义的角色可能显得力不从心。例如，“一个部门经理只能查看其本部门员工的绩效报告”——这个“本部门”的限制，是RBAC难以直接表达的。
为了实现更灵活、更细粒度、更动态的授权决策，基于属性的访问控制（Attribute-Based Access Control，简称ABAC） 模型应运而生。ABAC不依赖于固定的角色，而是通过评估请求中各种属性（如用户属性、资源属性、环境属性）来做出访问决策。
1. ABAC的核心概念：属性与策略
ABAC模型的核心在于“属性（Attributes）”和“策略（Policies）”。它通过定义一系列策略规则，这些规则基于主体、资源和环境的属性来决定是否允许访问。
1.1 主体属性（Subject Attributes）
定义： 描述尝试访问资源的用户或实体自身的属性。这些属性定义了“谁”在尝试访问。
示例：

用户ID： user:id="alice"
角色（RBAC中的角色也可以作为ABAC的一个属性）： user:role="manager"
部门： user:department="sales"
地理位置： user:location="shanghai"
雇佣类型： user:employmentType="full-time"
安全级别： user:securityLevel="confidential"

1.2 资源属性（Resource Attributes）
定义： 描述用户尝试访问的资源本身的属性。这些属性定义了“什么”被访问。
示例：

资源类型： resource:type="document"
资源ID： resource:id="report_Q2_2024"
所有者： resource:owner="alice"
密级： resource:classification="top_secret"
部门： resource:department="finance"
创建日期： resource:createDate="2024-05-01"

1.3 环境属性（Environment Attributes）
定义： 描述访问发生时所处的上下文环境的属性。这些属性定义了“何时”、“何地”、“如何”访问。
示例：

时间/日期： environment:timeOfDay="business_hours", environment:date="2024-06-30"
网络位置： environment:ipAddress="192.168.1.x" (来自内部网络)
设备类型： environment:deviceType="corporate_laptop"
会话强度： environment:authenticationStrength="MFA_enabled"
操作类型： action:type="read", action:type="write"

1.4 策略（Policy）
定义： 策略是ABAC的核心。它是一组规则，通过评估主体属性、资源属性和环境属性来做出授权决策（允许或拒绝）。策略通常以某种结构化的语言（如XACML - eXtensible Access Control Markup Language）表达。'><meta name=author content><link rel=canonical href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC11%E7%AF%87%E6%9B%B4%E7%B2%BE%E7%BB%86%E7%9A%84%E6%8E%88%E6%9D%83%E5%9F%BA%E4%BA%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6abac%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://bsong2015.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bsong2015.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bsong2015.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://bsong2015.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://bsong2015.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC11%E7%AF%87%E6%9B%B4%E7%B2%BE%E7%BB%86%E7%9A%84%E6%8E%88%E6%9D%83%E5%9F%BA%E4%BA%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6abac%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC11%E7%AF%87%E6%9B%B4%E7%B2%BE%E7%BB%86%E7%9A%84%E6%8E%88%E6%9D%83%E5%9F%BA%E4%BA%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6abac%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/"><meta property="og:site_name" content="万年水的博客"><meta property="og:title" content="万年水的博客"><meta property="og:description" content='第11篇：更精细的授权：基于属性的访问控制（ABAC）模型解析 在上一篇文章中，我们详细讲解了基于角色的访问控制（RBAC）模型，它通过将权限与角色关联，再将角色分配给用户，极大地简化了权限管理。然而，在面对日益复杂、动态变化的业务场景时，仅仅依靠预定义的角色可能显得力不从心。例如，“一个部门经理只能查看其本部门员工的绩效报告”——这个“本部门”的限制，是RBAC难以直接表达的。
为了实现更灵活、更细粒度、更动态的授权决策，基于属性的访问控制（Attribute-Based Access Control，简称ABAC） 模型应运而生。ABAC不依赖于固定的角色，而是通过评估请求中各种属性（如用户属性、资源属性、环境属性）来做出访问决策。
1. ABAC的核心概念：属性与策略 ABAC模型的核心在于“属性（Attributes）”和“策略（Policies）”。它通过定义一系列策略规则，这些规则基于主体、资源和环境的属性来决定是否允许访问。
1.1 主体属性（Subject Attributes） 定义： 描述尝试访问资源的用户或实体自身的属性。这些属性定义了“谁”在尝试访问。
示例：
用户ID： user:id="alice" 角色（RBAC中的角色也可以作为ABAC的一个属性）： user:role="manager" 部门： user:department="sales" 地理位置： user:location="shanghai" 雇佣类型： user:employmentType="full-time" 安全级别： user:securityLevel="confidential" 1.2 资源属性（Resource Attributes） 定义： 描述用户尝试访问的资源本身的属性。这些属性定义了“什么”被访问。
示例：
资源类型： resource:type="document" 资源ID： resource:id="report_Q2_2024" 所有者： resource:owner="alice" 密级： resource:classification="top_secret" 部门： resource:department="finance" 创建日期： resource:createDate="2024-05-01" 1.3 环境属性（Environment Attributes） 定义： 描述访问发生时所处的上下文环境的属性。这些属性定义了“何时”、“何地”、“如何”访问。
示例：
时间/日期： environment:timeOfDay="business_hours", environment:date="2024-06-30" 网络位置： environment:ipAddress="192.168.1.x" (来自内部网络) 设备类型： environment:deviceType="corporate_laptop" 会话强度： environment:authenticationStrength="MFA_enabled" 操作类型： action:type="read", action:type="write" 1.4 策略（Policy） 定义： 策略是ABAC的核心。它是一组规则，通过评估主体属性、资源属性和环境属性来做出授权决策（允许或拒绝）。策略通常以某种结构化的语言（如XACML - eXtensible Access Control Markup Language）表达。'><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content='第11篇：更精细的授权：基于属性的访问控制（ABAC）模型解析
在上一篇文章中，我们详细讲解了基于角色的访问控制（RBAC）模型，它通过将权限与角色关联，再将角色分配给用户，极大地简化了权限管理。然而，在面对日益复杂、动态变化的业务场景时，仅仅依靠预定义的角色可能显得力不从心。例如，“一个部门经理只能查看其本部门员工的绩效报告”——这个“本部门”的限制，是RBAC难以直接表达的。
为了实现更灵活、更细粒度、更动态的授权决策，基于属性的访问控制（Attribute-Based Access Control，简称ABAC） 模型应运而生。ABAC不依赖于固定的角色，而是通过评估请求中各种属性（如用户属性、资源属性、环境属性）来做出访问决策。
1. ABAC的核心概念：属性与策略
ABAC模型的核心在于“属性（Attributes）”和“策略（Policies）”。它通过定义一系列策略规则，这些规则基于主体、资源和环境的属性来决定是否允许访问。
1.1 主体属性（Subject Attributes）
定义： 描述尝试访问资源的用户或实体自身的属性。这些属性定义了“谁”在尝试访问。
示例：

用户ID： user:id="alice"
角色（RBAC中的角色也可以作为ABAC的一个属性）： user:role="manager"
部门： user:department="sales"
地理位置： user:location="shanghai"
雇佣类型： user:employmentType="full-time"
安全级别： user:securityLevel="confidential"

1.2 资源属性（Resource Attributes）
定义： 描述用户尝试访问的资源本身的属性。这些属性定义了“什么”被访问。
示例：

资源类型： resource:type="document"
资源ID： resource:id="report_Q2_2024"
所有者： resource:owner="alice"
密级： resource:classification="top_secret"
部门： resource:department="finance"
创建日期： resource:createDate="2024-05-01"

1.3 环境属性（Environment Attributes）
定义： 描述访问发生时所处的上下文环境的属性。这些属性定义了“何时”、“何地”、“如何”访问。
示例：

时间/日期： environment:timeOfDay="business_hours", environment:date="2024-06-30"
网络位置： environment:ipAddress="192.168.1.x" (来自内部网络)
设备类型： environment:deviceType="corporate_laptop"
会话强度： environment:authenticationStrength="MFA_enabled"
操作类型： action:type="read", action:type="write"

1.4 策略（Policy）
定义： 策略是ABAC的核心。它是一组规则，通过评估主体属性、资源属性和环境属性来做出授权决策（允许或拒绝）。策略通常以某种结构化的语言（如XACML - eXtensible Access Control Markup Language）表达。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bsong2015.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"技术实践","item":"https://bsong2015.github.io/blog/posts/technology/"},{"@type":"ListItem","position":3,"name":"","item":"https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC11%E7%AF%87%E6%9B%B4%E7%B2%BE%E7%BB%86%E7%9A%84%E6%8E%88%E6%9D%83%E5%9F%BA%E4%BA%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6abac%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"第11篇：更精细的授权：基于属性的访问控制（ABAC）模型解析 在上一篇文章中，我们详细讲解了基于角色的访问控制（RBAC）模型，它通过将权限与角色关联，再将角色分配给用户，极大地简化了权限管理。然而，在面对日益复杂、动态变化的业务场景时，仅仅依靠预定义的角色可能显得力不从心。例如，“一个部门经理只能查看其本部门员工的绩效报告”——这个“本部门”的限制，是RBAC难以直接表达的。\n为了实现更灵活、更细粒度、更动态的授权决策，基于属性的访问控制（Attribute-Based Access Control，简称ABAC） 模型应运而生。ABAC不依赖于固定的角色，而是通过评估请求中各种属性（如用户属性、资源属性、环境属性）来做出访问决策。\n1. ABAC的核心概念：属性与策略 ABAC模型的核心在于“属性（Attributes）”和“策略（Policies）”。它通过定义一系列策略规则，这些规则基于主体、资源和环境的属性来决定是否允许访问。\n1.1 主体属性（Subject Attributes） 定义： 描述尝试访问资源的用户或实体自身的属性。这些属性定义了“谁”在尝试访问。\n示例：\n用户ID： user:id=\u0026quot;alice\u0026quot; 角色（RBAC中的角色也可以作为ABAC的一个属性）： user:role=\u0026quot;manager\u0026quot; 部门： user:department=\u0026quot;sales\u0026quot; 地理位置： user:location=\u0026quot;shanghai\u0026quot; 雇佣类型： user:employmentType=\u0026quot;full-time\u0026quot; 安全级别： user:securityLevel=\u0026quot;confidential\u0026quot; 1.2 资源属性（Resource Attributes） 定义： 描述用户尝试访问的资源本身的属性。这些属性定义了“什么”被访问。\n示例：\n资源类型： resource:type=\u0026quot;document\u0026quot; 资源ID： resource:id=\u0026quot;report_Q2_2024\u0026quot; 所有者： resource:owner=\u0026quot;alice\u0026quot; 密级： resource:classification=\u0026quot;top_secret\u0026quot; 部门： resource:department=\u0026quot;finance\u0026quot; 创建日期： resource:createDate=\u0026quot;2024-05-01\u0026quot; 1.3 环境属性（Environment Attributes） 定义： 描述访问发生时所处的上下文环境的属性。这些属性定义了“何时”、“何地”、“如何”访问。\n示例：\n时间/日期： environment:timeOfDay=\u0026quot;business_hours\u0026quot;, environment:date=\u0026quot;2024-06-30\u0026quot; 网络位置： environment:ipAddress=\u0026quot;192.168.1.x\u0026quot; (来自内部网络) 设备类型： environment:deviceType=\u0026quot;corporate_laptop\u0026quot; 会话强度： environment:authenticationStrength=\u0026quot;MFA_enabled\u0026quot; 操作类型： action:type=\u0026quot;read\u0026quot;, action:type=\u0026quot;write\u0026quot; 1.4 策略（Policy） 定义： 策略是ABAC的核心。它是一组规则，通过评估主体属性、资源属性和环境属性来做出授权决策（允许或拒绝）。策略通常以某种结构化的语言（如XACML - eXtensible Access Control Markup Language）表达。\n","keywords":[],"articleBody":"第11篇：更精细的授权：基于属性的访问控制（ABAC）模型解析 在上一篇文章中，我们详细讲解了基于角色的访问控制（RBAC）模型，它通过将权限与角色关联，再将角色分配给用户，极大地简化了权限管理。然而，在面对日益复杂、动态变化的业务场景时，仅仅依靠预定义的角色可能显得力不从心。例如，“一个部门经理只能查看其本部门员工的绩效报告”——这个“本部门”的限制，是RBAC难以直接表达的。\n为了实现更灵活、更细粒度、更动态的授权决策，基于属性的访问控制（Attribute-Based Access Control，简称ABAC） 模型应运而生。ABAC不依赖于固定的角色，而是通过评估请求中各种属性（如用户属性、资源属性、环境属性）来做出访问决策。\n1. ABAC的核心概念：属性与策略 ABAC模型的核心在于“属性（Attributes）”和“策略（Policies）”。它通过定义一系列策略规则，这些规则基于主体、资源和环境的属性来决定是否允许访问。\n1.1 主体属性（Subject Attributes） 定义： 描述尝试访问资源的用户或实体自身的属性。这些属性定义了“谁”在尝试访问。\n示例：\n用户ID： user:id=\"alice\" 角色（RBAC中的角色也可以作为ABAC的一个属性）： user:role=\"manager\" 部门： user:department=\"sales\" 地理位置： user:location=\"shanghai\" 雇佣类型： user:employmentType=\"full-time\" 安全级别： user:securityLevel=\"confidential\" 1.2 资源属性（Resource Attributes） 定义： 描述用户尝试访问的资源本身的属性。这些属性定义了“什么”被访问。\n示例：\n资源类型： resource:type=\"document\" 资源ID： resource:id=\"report_Q2_2024\" 所有者： resource:owner=\"alice\" 密级： resource:classification=\"top_secret\" 部门： resource:department=\"finance\" 创建日期： resource:createDate=\"2024-05-01\" 1.3 环境属性（Environment Attributes） 定义： 描述访问发生时所处的上下文环境的属性。这些属性定义了“何时”、“何地”、“如何”访问。\n示例：\n时间/日期： environment:timeOfDay=\"business_hours\", environment:date=\"2024-06-30\" 网络位置： environment:ipAddress=\"192.168.1.x\" (来自内部网络) 设备类型： environment:deviceType=\"corporate_laptop\" 会话强度： environment:authenticationStrength=\"MFA_enabled\" 操作类型： action:type=\"read\", action:type=\"write\" 1.4 策略（Policy） 定义： 策略是ABAC的核心。它是一组规则，通过评估主体属性、资源属性和环境属性来做出授权决策（允许或拒绝）。策略通常以某种结构化的语言（如XACML - eXtensible Access Control Markup Language）表达。\n策略结构示例： Permit if (Subject.department == Resource.department AND Subject.role == \"manager\" AND Action.type == \"read\")\n工作流程：\n用户尝试执行某个操作（Action）访问某个资源（Resource）。 授权系统收集请求中主体、资源和环境的所有相关属性。 授权决策引擎根据预定义的策略评估这些属性。 如果所有策略条件都满足，则允许访问；否则，拒绝访问。 2. ABAC与RBAC的对比 ABAC和RBAC都是重要的授权模型，但它们在设计理念、灵活性和适用场景上存在显著差异。\n特征 基于角色的访问控制（RBAC） 基于属性的访问控制（ABAC） 核心理念 将权限分配给角色，用户分配给角色 基于属性和策略动态评估访问请求 管理粒度 粗粒度到中粒度，通过角色进行抽象 精细到极细粒度，直接操作属性，可控制到单个数据实例 灵活性/动态性 较低，角色预定义，新增或变更规则需修改角色或重新分配 极高，可根据实时上下文和属性动态决策，无需修改角色 复杂性 相对简单，易于理解和管理 较高，策略设计和属性管理可能很复杂 规则变更 变更规则可能需要调整角色定义和用户-角色分配 只需修改或添加策略规则，无需改变用户或角色结构 合规性 难以直接表达复杂的合规性规则（如职责分离） 能更精确地表达和强制复杂的合规性规则 适用场景 静态、层级明确的权限场景（如组织架构、部门职责） 动态、高变化、细粒度需求、大量用户/资源、合规性要求高的场景 可读性 通常较高，角色名称直观 策略可能较抽象，需要专业知识理解 简而言之：\nRBAC： “你是销售经理，所以你可以查看所有销售报告。”（基于角色定义权限） ABAC： “如果你是销售部门的经理，并且当前访问时间在工作日，并且你请求的是你所在销售部门的客户报告，那么你可以查看。”（基于属性动态组合权限） 3. ABAC的优势 极高的灵活性和精细度： 能够应对各种复杂的授权场景，实现数据层面、操作层面甚至上下文层面的细粒度控制。 动态适应性： 当业务需求、用户属性或环境发生变化时，只需修改策略，无需调整大量的角色和用户分配。这在弹性、敏捷的云计算和微服务环境中尤为重要。 降低管理负担（长期）： 虽然初始策略设计可能复杂，但一旦策略建立，管理大量用户和资源的权限变更会变得更加自动化和高效。 更强的可表达性： 能够清晰地表达“如果A，并且B，并且C，那么允许X”这样的复杂业务规则。 零信任（Zero Trust）模型的理想授权方式： ABAC的动态、上下文感知特性与零信任架构中“永不信任，始终验证”的原则高度契合。 4. ABAC的适用场景 ABAC并非万能药，其复杂性也意味着并非所有场景都适合。它最适用于以下情况：\n大数据和多租户环境： 需要根据数据的拥有者、敏感度、租户ID等属性进行动态隔离和访问控制。例如，医疗健康平台中，医生只能查看其负责病人的医疗记录。 微服务架构： 微服务之间需要基于服务ID、API类型、请求上下文等属性进行细粒度授权。 物联网（IoT）安全： 根据设备类型、位置、状态、传感器数据等属性，决定哪些用户或服务可以控制哪些设备。 金融、医疗等强合规性行业： 需要强制执行复杂的合规性规则，如职责分离（SoD）、数据隔离等。 动态和弹性环境： 用户数量、资源类型、业务规则频繁变化的云原生应用场景。 联邦身份管理： 跨组织共享资源时，可以基于外部用户的属性进行授权。 结合RBAC： 在很多实际应用中，ABAC并非完全取代RBAC，而是作为其补充。常见的做法是：\nRBAC处理粗粒度权限： 将大部分用户归入基于职责的角色，处理通用权限。 ABAC处理细粒度权限： 针对特定的高敏感资源或复杂业务逻辑，通过属性策略进行额外的过滤和控制。例如，“一个拥有‘订单查看员’角色（RBAC）的用户，只能查看他自己创建或他所在区域的订单（ABAC基于订单所有者/区域属性）”。 总结 基于属性的访问控制（ABAC）模型为我们提供了比RBAC更灵活、更精细的授权能力。它通过在运行时评估主体、资源和环境的各种属性，根据预定义的策略动态地做出访问决策。虽然其初始设计和管理复杂度较高，但在面对动态、大规模、高合规性要求以及需要细粒度控制的现代应用场景时，ABAC的优势尤为突出。\n欢迎关注+点赞+推荐+转发\n","wordCount":"165","inLanguage":"zh","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC11%E7%AF%87%E6%9B%B4%E7%B2%BE%E7%BB%86%E7%9A%84%E6%8E%88%E6%9D%83%E5%9F%BA%E4%BA%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6abac%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/"},"publisher":{"@type":"Organization","name":"万年水的博客","logo":{"@type":"ImageObject","url":"https://bsong2015.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bsong2015.github.io/blog/ accesskey=h title="万年水的博客 (Alt + H)">万年水的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bsong2015.github.io/blog/posts/artificial-intelligence/ title=人工智能><span>人工智能</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/reading/ title=阅读><span>阅读</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/thinking-models/ title=思维模型><span>思维模型</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/thought-experiments/ title=思想实验><span>思想实验</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/personal-growth/ title=个人成长><span>个人成长</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/technology/ title=技术><span>技术</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/current-affairs/ title=时事><span>时事</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/others/ title=其它><span>其它</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent"></h1><div class=post-meta></div></header><div class=post-content><h2 id=第11篇更精细的授权基于属性的访问控制abac模型解析>第11篇：更精细的授权：基于属性的访问控制（ABAC）模型解析<a hidden class=anchor aria-hidden=true href=#第11篇更精细的授权基于属性的访问控制abac模型解析>#</a></h2><p>在上一篇文章中，我们详细讲解了基于角色的访问控制（RBAC）模型，它通过将权限与角色关联，再将角色分配给用户，极大地简化了权限管理。然而，在面对日益复杂、动态变化的业务场景时，仅仅依靠预定义的角色可能显得力不从心。例如，“一个部门经理只能查看其<strong>本部门</strong>员工的绩效报告”——这个“本部门”的限制，是RBAC难以直接表达的。</p><p>为了实现更灵活、更细粒度、更动态的授权决策，<strong>基于属性的访问控制（Attribute-Based Access Control，简称ABAC）</strong> 模型应运而生。ABAC不依赖于固定的角色，而是通过评估请求中各种属性（如用户属性、资源属性、环境属性）来做出访问决策。</p><h3 id=1-abac的核心概念属性与策略>1. ABAC的核心概念：属性与策略<a hidden class=anchor aria-hidden=true href=#1-abac的核心概念属性与策略>#</a></h3><p>ABAC模型的核心在于“属性（Attributes）”和“策略（Policies）”。它通过定义一系列策略规则，这些规则基于主体、资源和环境的属性来决定是否允许访问。</p><h4 id=11-主体属性subject-attributes>1.1 主体属性（Subject Attributes）<a hidden class=anchor aria-hidden=true href=#11-主体属性subject-attributes>#</a></h4><p><strong>定义：</strong> 描述尝试访问资源的用户或实体自身的属性。这些属性定义了“谁”在尝试访问。</p><p><strong>示例：</strong></p><ul><li><strong>用户ID：</strong> <code>user:id="alice"</code></li><li><strong>角色（RBAC中的角色也可以作为ABAC的一个属性）：</strong> <code>user:role="manager"</code></li><li><strong>部门：</strong> <code>user:department="sales"</code></li><li><strong>地理位置：</strong> <code>user:location="shanghai"</code></li><li><strong>雇佣类型：</strong> <code>user:employmentType="full-time"</code></li><li><strong>安全级别：</strong> <code>user:securityLevel="confidential"</code></li></ul><h4 id=12-资源属性resource-attributes>1.2 资源属性（Resource Attributes）<a hidden class=anchor aria-hidden=true href=#12-资源属性resource-attributes>#</a></h4><p><strong>定义：</strong> 描述用户尝试访问的资源本身的属性。这些属性定义了“什么”被访问。</p><p><strong>示例：</strong></p><ul><li><strong>资源类型：</strong> <code>resource:type="document"</code></li><li><strong>资源ID：</strong> <code>resource:id="report_Q2_2024"</code></li><li><strong>所有者：</strong> <code>resource:owner="alice"</code></li><li><strong>密级：</strong> <code>resource:classification="top_secret"</code></li><li><strong>部门：</strong> <code>resource:department="finance"</code></li><li><strong>创建日期：</strong> <code>resource:createDate="2024-05-01"</code></li></ul><h4 id=13-环境属性environment-attributes>1.3 环境属性（Environment Attributes）<a hidden class=anchor aria-hidden=true href=#13-环境属性environment-attributes>#</a></h4><p><strong>定义：</strong> 描述访问发生时所处的上下文环境的属性。这些属性定义了“何时”、“何地”、“如何”访问。</p><p><strong>示例：</strong></p><ul><li><strong>时间/日期：</strong> <code>environment:timeOfDay="business_hours"</code>, <code>environment:date="2024-06-30"</code></li><li><strong>网络位置：</strong> <code>environment:ipAddress="192.168.1.x"</code> (来自内部网络)</li><li><strong>设备类型：</strong> <code>environment:deviceType="corporate_laptop"</code></li><li><strong>会话强度：</strong> <code>environment:authenticationStrength="MFA_enabled"</code></li><li><strong>操作类型：</strong> <code>action:type="read"</code>, <code>action:type="write"</code></li></ul><h4 id=14-策略policy>1.4 策略（Policy）<a hidden class=anchor aria-hidden=true href=#14-策略policy>#</a></h4><p><strong>定义：</strong> 策略是ABAC的核心。它是一组规则，通过评估主体属性、资源属性和环境属性来做出授权决策（允许或拒绝）。策略通常以某种结构化的语言（如XACML - eXtensible Access Control Markup Language）表达。</p><p><strong>策略结构示例：</strong>
<code>Permit if (Subject.department == Resource.department AND Subject.role == "manager" AND Action.type == "read")</code></p><p><strong>工作流程：</strong></p><ol><li>用户尝试执行某个操作（Action）访问某个资源（Resource）。</li><li>授权系统收集请求中主体、资源和环境的所有相关属性。</li><li>授权决策引擎根据预定义的策略评估这些属性。</li><li>如果所有策略条件都满足，则允许访问；否则，拒绝访问。</li></ol><h3 id=2-abac与rbac的对比>2. ABAC与RBAC的对比<a hidden class=anchor aria-hidden=true href=#2-abac与rbac的对比>#</a></h3><p>ABAC和RBAC都是重要的授权模型，但它们在设计理念、灵活性和适用场景上存在显著差异。</p><table><thead><tr><th style=text-align:left>特征</th><th style=text-align:left>基于角色的访问控制（RBAC）</th><th style=text-align:left>基于属性的访问控制（ABAC）</th></tr></thead><tbody><tr><td style=text-align:left><strong>核心理念</strong></td><td style=text-align:left>将权限分配给<strong>角色</strong>，用户分配给角色</td><td style=text-align:left>基于<strong>属性</strong>和<strong>策略</strong>动态评估访问请求</td></tr><tr><td style=text-align:left><strong>管理粒度</strong></td><td style=text-align:left>粗粒度到中粒度，通过角色进行抽象</td><td style=text-align:left>精细到极细粒度，直接操作属性，可控制到单个数据实例</td></tr><tr><td style=text-align:left><strong>灵活性/动态性</strong></td><td style=text-align:left>较低，角色预定义，新增或变更规则需修改角色或重新分配</td><td style=text-align:left>极高，可根据实时上下文和属性动态决策，无需修改角色</td></tr><tr><td style=text-align:left><strong>复杂性</strong></td><td style=text-align:left>相对简单，易于理解和管理</td><td style=text-align:left>较高，策略设计和属性管理可能很复杂</td></tr><tr><td style=text-align:left><strong>规则变更</strong></td><td style=text-align:left>变更规则可能需要调整角色定义和用户-角色分配</td><td style=text-align:left>只需修改或添加策略规则，无需改变用户或角色结构</td></tr><tr><td style=text-align:left><strong>合规性</strong></td><td style=text-align:left>难以直接表达复杂的合规性规则（如职责分离）</td><td style=text-align:left>能更精确地表达和强制复杂的合规性规则</td></tr><tr><td style=text-align:left><strong>适用场景</strong></td><td style=text-align:left>静态、层级明确的权限场景（如组织架构、部门职责）</td><td style=text-align:left>动态、高变化、细粒度需求、大量用户/资源、合规性要求高的场景</td></tr><tr><td style=text-align:left><strong>可读性</strong></td><td style=text-align:left>通常较高，角色名称直观</td><td style=text-align:left>策略可能较抽象，需要专业知识理解</td></tr></tbody></table><p><strong>简而言之：</strong></p><ul><li><strong>RBAC：</strong> “你是销售经理，所以你可以查看所有销售报告。”（基于角色定义权限）</li><li><strong>ABAC：</strong> “如果你是销售部门的经理，并且当前访问时间在工作日，并且你请求的是你所在销售部门的客户报告，那么你可以查看。”（基于属性动态组合权限）</li></ul><h3 id=3-abac的优势>3. ABAC的优势<a hidden class=anchor aria-hidden=true href=#3-abac的优势>#</a></h3><ul><li><strong>极高的灵活性和精细度：</strong> 能够应对各种复杂的授权场景，实现数据层面、操作层面甚至上下文层面的细粒度控制。</li><li><strong>动态适应性：</strong> 当业务需求、用户属性或环境发生变化时，只需修改策略，无需调整大量的角色和用户分配。这在弹性、敏捷的云计算和微服务环境中尤为重要。</li><li><strong>降低管理负担（长期）：</strong> 虽然初始策略设计可能复杂，但一旦策略建立，管理大量用户和资源的权限变更会变得更加自动化和高效。</li><li><strong>更强的可表达性：</strong> 能够清晰地表达“如果A，并且B，并且C，那么允许X”这样的复杂业务规则。</li><li><strong>零信任（Zero Trust）模型的理想授权方式：</strong> ABAC的动态、上下文感知特性与零信任架构中“永不信任，始终验证”的原则高度契合。</li></ul><h3 id=4-abac的适用场景>4. ABAC的适用场景<a hidden class=anchor aria-hidden=true href=#4-abac的适用场景>#</a></h3><p>ABAC并非万能药，其复杂性也意味着并非所有场景都适合。它最适用于以下情况：</p><ul><li><strong>大数据和多租户环境：</strong> 需要根据数据的拥有者、敏感度、租户ID等属性进行动态隔离和访问控制。例如，医疗健康平台中，医生只能查看其负责病人的医疗记录。</li><li><strong>微服务架构：</strong> 微服务之间需要基于服务ID、API类型、请求上下文等属性进行细粒度授权。</li><li><strong>物联网（IoT）安全：</strong> 根据设备类型、位置、状态、传感器数据等属性，决定哪些用户或服务可以控制哪些设备。</li><li><strong>金融、医疗等强合规性行业：</strong> 需要强制执行复杂的合规性规则，如职责分离（SoD）、数据隔离等。</li><li><strong>动态和弹性环境：</strong> 用户数量、资源类型、业务规则频繁变化的云原生应用场景。</li><li><strong>联邦身份管理：</strong> 跨组织共享资源时，可以基于外部用户的属性进行授权。</li></ul><p><strong>结合RBAC：</strong> 在很多实际应用中，ABAC并非完全取代RBAC，而是作为其补充。常见的做法是：</p><ul><li><strong>RBAC处理粗粒度权限：</strong> 将大部分用户归入基于职责的角色，处理通用权限。</li><li><strong>ABAC处理细粒度权限：</strong> 针对特定的高敏感资源或复杂业务逻辑，通过属性策略进行额外的过滤和控制。例如，“一个拥有‘订单查看员’角色（RBAC）的用户，只能查看<strong>他自己创建或他所在区域</strong>的订单（ABAC基于订单所有者/区域属性）”。</li></ul><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><p>基于属性的访问控制（ABAC）模型为我们提供了比RBAC更灵活、更精细的授权能力。它通过在运行时评估主体、资源和环境的各种属性，根据预定义的策略动态地做出访问决策。虽然其初始设计和管理复杂度较高，但在面对动态、大规模、高合规性要求以及需要细粒度控制的现代应用场景时，ABAC的优势尤为突出。</p><h3></h3><p><strong>欢迎关注+点赞+推荐+转发</strong></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bsong2015.github.io/blog/>万年水的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>