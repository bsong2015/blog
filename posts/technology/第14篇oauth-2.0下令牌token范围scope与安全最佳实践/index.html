<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>万年水的博客</title><meta name=keywords content><meta name=description content='第14篇：OAuth 2.0（下）：令牌（Token）、范围（Scope）与安全最佳实践
在上一篇文章中，我们介绍了OAuth 2.0作为授权框架的背景、核心角色以及四种主要的授权模式。我们了解到，OAuth 2.0的核心目标是在不共享用户凭证的前提下，安全地实现第三方应用对用户资源的访问。而实现这一目标的关键，正是其所颁发的各种令牌（Token） 以及对授权范围（Scope） 的精确控制。
本篇将深入探讨OAuth 2.0中的令牌类型、作用域概念，并重点讲解确保OAuth 2.0流程安全的关键机制和最佳实践，帮助你构建更健壮、更安全的授权体系。
1. 核心令牌类型：授权的凭证
OAuth 2.0主要定义了两种核心令牌，它们在授权流程中扮演着不同的角色：
1.1 访问令牌（Access Token）

定义： 访问令牌是客户端访问受保护资源的凭证。它是一个短生命周期的字符串，代表了用户授权客户端访问特定资源和执行特定操作的许可。
特性：

不透明性（Opaque）： 对于客户端而言，访问令牌通常是不透明的字符串（可以是随机字符串、JWT等）。客户端不需要解析其内部结构，只需将其作为凭证传递给资源服务器。
生命周期： 访问令牌通常具有较短的有效期（例如，几分钟到几小时）。过期后，客户端需要通过其他方式获取新的访问令牌。
承载者令牌（Bearer Token）： 大多数情况下，访问令牌是“承载者令牌”。这意味着任何持有该令牌的实体都可以访问相应的资源，如同持有现金一样。因此，访问令牌的保密性至关重要。


用途： 客户端在向资源服务器发送请求时，通常会在HTTP请求的"Authorization"头中携带访问令牌，例如：&ldquo;Authorization: Bearer <access_token>"。资源服务器会验证该令牌的有效性（包括是否过期、是否伪造、是否有权限），然后响应请求。

1.2 刷新令牌（Refresh Token）

定义： 刷新令牌是客户端用于获取新的访问令牌的凭证。它是一个长生命周期的令牌，通常只颁发给那些能够安全存储它的客户端（例如，服务器端应用）。
特性：

生命周期： 刷新令牌通常具有较长的有效期，甚至可以是永久的，直到被显式撤销或用户修改密码。
保密性： 由于刷新令牌的生命周期长，且能够获取新的访问令牌，其安全存储（通常在服务器端，不暴露给浏览器或移动应用）是至关重要的。
一次性使用或旋转： 为增强安全性，有些实现会强制刷新令牌在每次使用后即失效，并返回一个新的刷新令牌（刷新令牌旋转），以降低泄露风险。


用途： 当访问令牌过期时，客户端可以使用刷新令牌向授权服务器的令牌端点再次请求获取新的访问令牌（以及可能的新刷新令牌），而无需用户再次进行授权。这提升了用户体验，减少了用户重复登录的频率。

2. 精确授权范围：作用域（Scope）与用户同意（Consent）
2.1 作用域（Scope）

定义： Scope是OAuth 2.0中用于指定客户端所请求的访问权限范围的字符串。它定义了客户端可以访问哪些资源以及可以执行哪些操作。
重要性： Scope实现了最小权限原则。客户端不应获得超过其完成任务所需的权限。例如，一个客户端可能只请求“读取用户相册”的权限，而不是“修改用户所有数据”的权限。
示例： &ldquo;read_photos&rdquo;、&ldquo;write_posts&rdquo;、&ldquo;email&rdquo;、&ldquo;profile"等。授权服务器会维护一个可用的Scope列表。
工作原理：

客户端在向授权服务器请求授权时，会带上其所需的"scope"参数。
授权服务器会根据客户端请求的Scope，向用户展示一个用户同意（Consent） 页面。
如果用户同意，授权服务器颁发的访问令牌将仅包含用户授权的Scope，资源服务器在验证令牌时也会检查其Scope是否满足请求操作所需权限。



2.2 用户同意（Consent）

定义： 用户同意是指在OAuth 2.0流程中，授权服务器向资源所有者展示一个明确的界面，说明客户端正在请求哪些权限（通过Scope），并征得用户的同意。
重要性： 用户同意是OAuth 2.0委托授权理念的直接体现。它确保用户对自己的数据和隐私拥有控制权，知道自己的数据将如何被第三方应用使用。
工作原理： 用户在授权服务器的同意页面上，可以看到客户端请求的"scope&rdquo;，并选择“同意”或“拒绝”。只有当用户明确同意后，授权服务器才会继续颁发令牌。

3. OAuth 2.0安全最佳实践：铸就铜墙铁壁
尽管OAuth 2.0框架本身具有较高的安全性，但错误的实现或忽视某些安全细节仍可能导致严重漏洞。以下是一些重要的安全考量和最佳实践：'><meta name=author content><link rel=canonical href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC14%E7%AF%87oauth-2.0%E4%B8%8B%E4%BB%A4%E7%89%8Ctoken%E8%8C%83%E5%9B%B4scope%E4%B8%8E%E5%AE%89%E5%85%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://bsong2015.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bsong2015.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bsong2015.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://bsong2015.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://bsong2015.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC14%E7%AF%87oauth-2.0%E4%B8%8B%E4%BB%A4%E7%89%8Ctoken%E8%8C%83%E5%9B%B4scope%E4%B8%8E%E5%AE%89%E5%85%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC14%E7%AF%87oauth-2.0%E4%B8%8B%E4%BB%A4%E7%89%8Ctoken%E8%8C%83%E5%9B%B4scope%E4%B8%8E%E5%AE%89%E5%85%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"><meta property="og:site_name" content="万年水的博客"><meta property="og:title" content="万年水的博客"><meta property="og:description" content='第14篇：OAuth 2.0（下）：令牌（Token）、范围（Scope）与安全最佳实践 在上一篇文章中，我们介绍了OAuth 2.0作为授权框架的背景、核心角色以及四种主要的授权模式。我们了解到，OAuth 2.0的核心目标是在不共享用户凭证的前提下，安全地实现第三方应用对用户资源的访问。而实现这一目标的关键，正是其所颁发的各种令牌（Token） 以及对授权范围（Scope） 的精确控制。
本篇将深入探讨OAuth 2.0中的令牌类型、作用域概念，并重点讲解确保OAuth 2.0流程安全的关键机制和最佳实践，帮助你构建更健壮、更安全的授权体系。
1. 核心令牌类型：授权的凭证 OAuth 2.0主要定义了两种核心令牌，它们在授权流程中扮演着不同的角色：
1.1 访问令牌（Access Token） 定义： 访问令牌是客户端访问受保护资源的凭证。它是一个短生命周期的字符串，代表了用户授权客户端访问特定资源和执行特定操作的许可。 特性： 不透明性（Opaque）： 对于客户端而言，访问令牌通常是不透明的字符串（可以是随机字符串、JWT等）。客户端不需要解析其内部结构，只需将其作为凭证传递给资源服务器。 生命周期： 访问令牌通常具有较短的有效期（例如，几分钟到几小时）。过期后，客户端需要通过其他方式获取新的访问令牌。 承载者令牌（Bearer Token）： 大多数情况下，访问令牌是“承载者令牌”。这意味着任何持有该令牌的实体都可以访问相应的资源，如同持有现金一样。因此，访问令牌的保密性至关重要。 用途： 客户端在向资源服务器发送请求时，通常会在HTTP请求的"Authorization"头中携带访问令牌，例如：“Authorization: Bearer <access_token>"。资源服务器会验证该令牌的有效性（包括是否过期、是否伪造、是否有权限），然后响应请求。 1.2 刷新令牌（Refresh Token） 定义： 刷新令牌是客户端用于获取新的访问令牌的凭证。它是一个长生命周期的令牌，通常只颁发给那些能够安全存储它的客户端（例如，服务器端应用）。 特性： 生命周期： 刷新令牌通常具有较长的有效期，甚至可以是永久的，直到被显式撤销或用户修改密码。 保密性： 由于刷新令牌的生命周期长，且能够获取新的访问令牌，其安全存储（通常在服务器端，不暴露给浏览器或移动应用）是至关重要的。 一次性使用或旋转： 为增强安全性，有些实现会强制刷新令牌在每次使用后即失效，并返回一个新的刷新令牌（刷新令牌旋转），以降低泄露风险。 用途： 当访问令牌过期时，客户端可以使用刷新令牌向授权服务器的令牌端点再次请求获取新的访问令牌（以及可能的新刷新令牌），而无需用户再次进行授权。这提升了用户体验，减少了用户重复登录的频率。 2. 精确授权范围：作用域（Scope）与用户同意（Consent） 2.1 作用域（Scope） 定义： Scope是OAuth 2.0中用于指定客户端所请求的访问权限范围的字符串。它定义了客户端可以访问哪些资源以及可以执行哪些操作。 重要性： Scope实现了最小权限原则。客户端不应获得超过其完成任务所需的权限。例如，一个客户端可能只请求“读取用户相册”的权限，而不是“修改用户所有数据”的权限。 示例： “read_photos”、“write_posts”、“email”、“profile"等。授权服务器会维护一个可用的Scope列表。 工作原理： 客户端在向授权服务器请求授权时，会带上其所需的"scope"参数。 授权服务器会根据客户端请求的Scope，向用户展示一个用户同意（Consent） 页面。 如果用户同意，授权服务器颁发的访问令牌将仅包含用户授权的Scope，资源服务器在验证令牌时也会检查其Scope是否满足请求操作所需权限。 2.2 用户同意（Consent） 定义： 用户同意是指在OAuth 2.0流程中，授权服务器向资源所有者展示一个明确的界面，说明客户端正在请求哪些权限（通过Scope），并征得用户的同意。 重要性： 用户同意是OAuth 2.0委托授权理念的直接体现。它确保用户对自己的数据和隐私拥有控制权，知道自己的数据将如何被第三方应用使用。 工作原理： 用户在授权服务器的同意页面上，可以看到客户端请求的"scope”，并选择“同意”或“拒绝”。只有当用户明确同意后，授权服务器才会继续颁发令牌。 3. OAuth 2.0安全最佳实践：铸就铜墙铁壁 尽管OAuth 2.0框架本身具有较高的安全性，但错误的实现或忽视某些安全细节仍可能导致严重漏洞。以下是一些重要的安全考量和最佳实践：'><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content='第14篇：OAuth 2.0（下）：令牌（Token）、范围（Scope）与安全最佳实践
在上一篇文章中，我们介绍了OAuth 2.0作为授权框架的背景、核心角色以及四种主要的授权模式。我们了解到，OAuth 2.0的核心目标是在不共享用户凭证的前提下，安全地实现第三方应用对用户资源的访问。而实现这一目标的关键，正是其所颁发的各种令牌（Token） 以及对授权范围（Scope） 的精确控制。
本篇将深入探讨OAuth 2.0中的令牌类型、作用域概念，并重点讲解确保OAuth 2.0流程安全的关键机制和最佳实践，帮助你构建更健壮、更安全的授权体系。
1. 核心令牌类型：授权的凭证
OAuth 2.0主要定义了两种核心令牌，它们在授权流程中扮演着不同的角色：
1.1 访问令牌（Access Token）

定义： 访问令牌是客户端访问受保护资源的凭证。它是一个短生命周期的字符串，代表了用户授权客户端访问特定资源和执行特定操作的许可。
特性：

不透明性（Opaque）： 对于客户端而言，访问令牌通常是不透明的字符串（可以是随机字符串、JWT等）。客户端不需要解析其内部结构，只需将其作为凭证传递给资源服务器。
生命周期： 访问令牌通常具有较短的有效期（例如，几分钟到几小时）。过期后，客户端需要通过其他方式获取新的访问令牌。
承载者令牌（Bearer Token）： 大多数情况下，访问令牌是“承载者令牌”。这意味着任何持有该令牌的实体都可以访问相应的资源，如同持有现金一样。因此，访问令牌的保密性至关重要。


用途： 客户端在向资源服务器发送请求时，通常会在HTTP请求的"Authorization"头中携带访问令牌，例如：&ldquo;Authorization: Bearer <access_token>"。资源服务器会验证该令牌的有效性（包括是否过期、是否伪造、是否有权限），然后响应请求。

1.2 刷新令牌（Refresh Token）

定义： 刷新令牌是客户端用于获取新的访问令牌的凭证。它是一个长生命周期的令牌，通常只颁发给那些能够安全存储它的客户端（例如，服务器端应用）。
特性：

生命周期： 刷新令牌通常具有较长的有效期，甚至可以是永久的，直到被显式撤销或用户修改密码。
保密性： 由于刷新令牌的生命周期长，且能够获取新的访问令牌，其安全存储（通常在服务器端，不暴露给浏览器或移动应用）是至关重要的。
一次性使用或旋转： 为增强安全性，有些实现会强制刷新令牌在每次使用后即失效，并返回一个新的刷新令牌（刷新令牌旋转），以降低泄露风险。


用途： 当访问令牌过期时，客户端可以使用刷新令牌向授权服务器的令牌端点再次请求获取新的访问令牌（以及可能的新刷新令牌），而无需用户再次进行授权。这提升了用户体验，减少了用户重复登录的频率。

2. 精确授权范围：作用域（Scope）与用户同意（Consent）
2.1 作用域（Scope）

定义： Scope是OAuth 2.0中用于指定客户端所请求的访问权限范围的字符串。它定义了客户端可以访问哪些资源以及可以执行哪些操作。
重要性： Scope实现了最小权限原则。客户端不应获得超过其完成任务所需的权限。例如，一个客户端可能只请求“读取用户相册”的权限，而不是“修改用户所有数据”的权限。
示例： &ldquo;read_photos&rdquo;、&ldquo;write_posts&rdquo;、&ldquo;email&rdquo;、&ldquo;profile"等。授权服务器会维护一个可用的Scope列表。
工作原理：

客户端在向授权服务器请求授权时，会带上其所需的"scope"参数。
授权服务器会根据客户端请求的Scope，向用户展示一个用户同意（Consent） 页面。
如果用户同意，授权服务器颁发的访问令牌将仅包含用户授权的Scope，资源服务器在验证令牌时也会检查其Scope是否满足请求操作所需权限。



2.2 用户同意（Consent）

定义： 用户同意是指在OAuth 2.0流程中，授权服务器向资源所有者展示一个明确的界面，说明客户端正在请求哪些权限（通过Scope），并征得用户的同意。
重要性： 用户同意是OAuth 2.0委托授权理念的直接体现。它确保用户对自己的数据和隐私拥有控制权，知道自己的数据将如何被第三方应用使用。
工作原理： 用户在授权服务器的同意页面上，可以看到客户端请求的"scope&rdquo;，并选择“同意”或“拒绝”。只有当用户明确同意后，授权服务器才会继续颁发令牌。

3. OAuth 2.0安全最佳实践：铸就铜墙铁壁
尽管OAuth 2.0框架本身具有较高的安全性，但错误的实现或忽视某些安全细节仍可能导致严重漏洞。以下是一些重要的安全考量和最佳实践：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bsong2015.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"技术实践","item":"https://bsong2015.github.io/blog/posts/technology/"},{"@type":"ListItem","position":3,"name":"","item":"https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC14%E7%AF%87oauth-2.0%E4%B8%8B%E4%BB%A4%E7%89%8Ctoken%E8%8C%83%E5%9B%B4scope%E4%B8%8E%E5%AE%89%E5%85%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"第14篇：OAuth 2.0（下）：令牌（Token）、范围（Scope）与安全最佳实践 在上一篇文章中，我们介绍了OAuth 2.0作为授权框架的背景、核心角色以及四种主要的授权模式。我们了解到，OAuth 2.0的核心目标是在不共享用户凭证的前提下，安全地实现第三方应用对用户资源的访问。而实现这一目标的关键，正是其所颁发的各种令牌（Token） 以及对授权范围（Scope） 的精确控制。\n本篇将深入探讨OAuth 2.0中的令牌类型、作用域概念，并重点讲解确保OAuth 2.0流程安全的关键机制和最佳实践，帮助你构建更健壮、更安全的授权体系。\n1. 核心令牌类型：授权的凭证 OAuth 2.0主要定义了两种核心令牌，它们在授权流程中扮演着不同的角色：\n1.1 访问令牌（Access Token） 定义： 访问令牌是客户端访问受保护资源的凭证。它是一个短生命周期的字符串，代表了用户授权客户端访问特定资源和执行特定操作的许可。 特性： 不透明性（Opaque）： 对于客户端而言，访问令牌通常是不透明的字符串（可以是随机字符串、JWT等）。客户端不需要解析其内部结构，只需将其作为凭证传递给资源服务器。 生命周期： 访问令牌通常具有较短的有效期（例如，几分钟到几小时）。过期后，客户端需要通过其他方式获取新的访问令牌。 承载者令牌（Bearer Token）： 大多数情况下，访问令牌是“承载者令牌”。这意味着任何持有该令牌的实体都可以访问相应的资源，如同持有现金一样。因此，访问令牌的保密性至关重要。 用途： 客户端在向资源服务器发送请求时，通常会在HTTP请求的\u0026quot;Authorization\u0026quot;头中携带访问令牌，例如：\u0026ldquo;Authorization: Bearer \u0026lt;access_token\u0026gt;\u0026quot;。资源服务器会验证该令牌的有效性（包括是否过期、是否伪造、是否有权限），然后响应请求。 1.2 刷新令牌（Refresh Token） 定义： 刷新令牌是客户端用于获取新的访问令牌的凭证。它是一个长生命周期的令牌，通常只颁发给那些能够安全存储它的客户端（例如，服务器端应用）。 特性： 生命周期： 刷新令牌通常具有较长的有效期，甚至可以是永久的，直到被显式撤销或用户修改密码。 保密性： 由于刷新令牌的生命周期长，且能够获取新的访问令牌，其安全存储（通常在服务器端，不暴露给浏览器或移动应用）是至关重要的。 一次性使用或旋转： 为增强安全性，有些实现会强制刷新令牌在每次使用后即失效，并返回一个新的刷新令牌（刷新令牌旋转），以降低泄露风险。 用途： 当访问令牌过期时，客户端可以使用刷新令牌向授权服务器的令牌端点再次请求获取新的访问令牌（以及可能的新刷新令牌），而无需用户再次进行授权。这提升了用户体验，减少了用户重复登录的频率。 2. 精确授权范围：作用域（Scope）与用户同意（Consent） 2.1 作用域（Scope） 定义： Scope是OAuth 2.0中用于指定客户端所请求的访问权限范围的字符串。它定义了客户端可以访问哪些资源以及可以执行哪些操作。 重要性： Scope实现了最小权限原则。客户端不应获得超过其完成任务所需的权限。例如，一个客户端可能只请求“读取用户相册”的权限，而不是“修改用户所有数据”的权限。 示例： \u0026ldquo;read_photos\u0026rdquo;、\u0026ldquo;write_posts\u0026rdquo;、\u0026ldquo;email\u0026rdquo;、\u0026ldquo;profile\u0026quot;等。授权服务器会维护一个可用的Scope列表。 工作原理： 客户端在向授权服务器请求授权时，会带上其所需的\u0026quot;scope\u0026quot;参数。 授权服务器会根据客户端请求的Scope，向用户展示一个用户同意（Consent） 页面。 如果用户同意，授权服务器颁发的访问令牌将仅包含用户授权的Scope，资源服务器在验证令牌时也会检查其Scope是否满足请求操作所需权限。 2.2 用户同意（Consent） 定义： 用户同意是指在OAuth 2.0流程中，授权服务器向资源所有者展示一个明确的界面，说明客户端正在请求哪些权限（通过Scope），并征得用户的同意。 重要性： 用户同意是OAuth 2.0委托授权理念的直接体现。它确保用户对自己的数据和隐私拥有控制权，知道自己的数据将如何被第三方应用使用。 工作原理： 用户在授权服务器的同意页面上，可以看到客户端请求的\u0026quot;scope\u0026rdquo;，并选择“同意”或“拒绝”。只有当用户明确同意后，授权服务器才会继续颁发令牌。 3. OAuth 2.0安全最佳实践：铸就铜墙铁壁 尽管OAuth 2.0框架本身具有较高的安全性，但错误的实现或忽视某些安全细节仍可能导致严重漏洞。以下是一些重要的安全考量和最佳实践：\n","keywords":[],"articleBody":"第14篇：OAuth 2.0（下）：令牌（Token）、范围（Scope）与安全最佳实践 在上一篇文章中，我们介绍了OAuth 2.0作为授权框架的背景、核心角色以及四种主要的授权模式。我们了解到，OAuth 2.0的核心目标是在不共享用户凭证的前提下，安全地实现第三方应用对用户资源的访问。而实现这一目标的关键，正是其所颁发的各种令牌（Token） 以及对授权范围（Scope） 的精确控制。\n本篇将深入探讨OAuth 2.0中的令牌类型、作用域概念，并重点讲解确保OAuth 2.0流程安全的关键机制和最佳实践，帮助你构建更健壮、更安全的授权体系。\n1. 核心令牌类型：授权的凭证 OAuth 2.0主要定义了两种核心令牌，它们在授权流程中扮演着不同的角色：\n1.1 访问令牌（Access Token） 定义： 访问令牌是客户端访问受保护资源的凭证。它是一个短生命周期的字符串，代表了用户授权客户端访问特定资源和执行特定操作的许可。 特性： 不透明性（Opaque）： 对于客户端而言，访问令牌通常是不透明的字符串（可以是随机字符串、JWT等）。客户端不需要解析其内部结构，只需将其作为凭证传递给资源服务器。 生命周期： 访问令牌通常具有较短的有效期（例如，几分钟到几小时）。过期后，客户端需要通过其他方式获取新的访问令牌。 承载者令牌（Bearer Token）： 大多数情况下，访问令牌是“承载者令牌”。这意味着任何持有该令牌的实体都可以访问相应的资源，如同持有现金一样。因此，访问令牌的保密性至关重要。 用途： 客户端在向资源服务器发送请求时，通常会在HTTP请求的\"Authorization\"头中携带访问令牌，例如：“Authorization: Bearer \"。资源服务器会验证该令牌的有效性（包括是否过期、是否伪造、是否有权限），然后响应请求。 1.2 刷新令牌（Refresh Token） 定义： 刷新令牌是客户端用于获取新的访问令牌的凭证。它是一个长生命周期的令牌，通常只颁发给那些能够安全存储它的客户端（例如，服务器端应用）。 特性： 生命周期： 刷新令牌通常具有较长的有效期，甚至可以是永久的，直到被显式撤销或用户修改密码。 保密性： 由于刷新令牌的生命周期长，且能够获取新的访问令牌，其安全存储（通常在服务器端，不暴露给浏览器或移动应用）是至关重要的。 一次性使用或旋转： 为增强安全性，有些实现会强制刷新令牌在每次使用后即失效，并返回一个新的刷新令牌（刷新令牌旋转），以降低泄露风险。 用途： 当访问令牌过期时，客户端可以使用刷新令牌向授权服务器的令牌端点再次请求获取新的访问令牌（以及可能的新刷新令牌），而无需用户再次进行授权。这提升了用户体验，减少了用户重复登录的频率。 2. 精确授权范围：作用域（Scope）与用户同意（Consent） 2.1 作用域（Scope） 定义： Scope是OAuth 2.0中用于指定客户端所请求的访问权限范围的字符串。它定义了客户端可以访问哪些资源以及可以执行哪些操作。 重要性： Scope实现了最小权限原则。客户端不应获得超过其完成任务所需的权限。例如，一个客户端可能只请求“读取用户相册”的权限，而不是“修改用户所有数据”的权限。 示例： “read_photos”、“write_posts”、“email”、“profile\"等。授权服务器会维护一个可用的Scope列表。 工作原理： 客户端在向授权服务器请求授权时，会带上其所需的\"scope\"参数。 授权服务器会根据客户端请求的Scope，向用户展示一个用户同意（Consent） 页面。 如果用户同意，授权服务器颁发的访问令牌将仅包含用户授权的Scope，资源服务器在验证令牌时也会检查其Scope是否满足请求操作所需权限。 2.2 用户同意（Consent） 定义： 用户同意是指在OAuth 2.0流程中，授权服务器向资源所有者展示一个明确的界面，说明客户端正在请求哪些权限（通过Scope），并征得用户的同意。 重要性： 用户同意是OAuth 2.0委托授权理念的直接体现。它确保用户对自己的数据和隐私拥有控制权，知道自己的数据将如何被第三方应用使用。 工作原理： 用户在授权服务器的同意页面上，可以看到客户端请求的\"scope”，并选择“同意”或“拒绝”。只有当用户明确同意后，授权服务器才会继续颁发令牌。 3. OAuth 2.0安全最佳实践：铸就铜墙铁壁 尽管OAuth 2.0框架本身具有较高的安全性，但错误的实现或忽视某些安全细节仍可能导致严重漏洞。以下是一些重要的安全考量和最佳实践：\n3.1 PKCE（Proof Key for Code Exchange） 问题： 授权码模式在SPA或移动应用等公共客户端（无法安全存储\"client_secret”）中，可能面临“授权码拦截攻击”：恶意应用可能拦截授权码，然后用它来交换访问令牌。 PKCE解决方案： PKCE是一种扩展，通过在授权请求和令牌交换过程中加入一个动态生成的“验证器”（“code_verifier”）和其哈希值（“code_challenge”）来缓解此问题。 客户端在发起授权请求前，生成一个随机字符串\"code_verifier\"及其哈希值\"code_challenge\"。 客户端在授权请求中携带\"code_challenge\"。 授权服务器将授权码返回给客户端。 客户端在用授权码交换令牌时，必须同时发送原始的\"code_verifier\"。 授权服务器验证收到的\"code_verifier\"的哈希值是否与最初收到的\"code_challenge\"匹配。如果匹配，才颁发令牌。 优势： 即使授权码被拦截，攻击者也无法获取访问令牌，因为他们没有\"code_verifier\"。PKCE已成为公共客户端（如SPA和移动应用）使用授权码模式时的强制要求。 3.2 State 参数 问题： 在授权码模式和隐式模式中，攻击者可能利用**CSRF（跨站请求伪造）**攻击，或将用户重定向到恶意网站，进行会话固定攻击或冒充授权响应。 State 参数解决方案： “state\"参数是一个由客户端生成的、在授权请求和重定向回调过程中保持不变的随机字符串。 客户端在生成授权请求URI时，生成一个唯一的\"state\"值，并将其存储在客户端的会话中。 授权服务器在处理完授权后，会将这个\"state\"值原封不动地返回给客户端的重定向URI。 客户端收到重定向后，必须验证返回的\"state\"值是否与自己之前存储的\"state\"值匹配。 优势： 如果\"state\"值不匹配，客户端应拒绝处理响应，从而有效防止CSRF攻击和恶意重定向。“state\"参数的使用是强制性的安全要求。 3.3 Redirect URI 验证 问题： 攻击者可能通过伪造\"redirect_uri\"参数，将授权码或访问令牌重定向到恶意服务器。 解决方案： 客户端在授权服务器处注册时，必须预先注册其所有合法的\"redirect_uri”。 授权服务器在处理授权请求时，必须严格验证请求中提供的\"redirect_uri\"是否与预注册的URI之一完全匹配。 优势： 防止开放重定向漏洞，确保令牌只发送到受信任的客户端回调地址。 3.4 Token 存储与传输 访问令牌： 传输： 始终通过HTTPS/TLS加密通道传输令牌，防止窃听。 存储： 客户端不应在不安全的客户端存储（如浏览器Local Storage）中长期存储访问令牌，尤其是在SPA中。可以考虑使用内存存储或HttpOnly Cookie（对于后端颁发给前端的会话令牌）。 刷新令牌： 存储： 刷新令牌必须安全地存储在服务器端（例如，加密的数据库或安全的密钥管理系统），绝不能暴露给浏览器或其他不安全的客户端。 使用： 刷新令牌的请求必须使用客户端凭证（“client_secret”），并通过后端与授权服务器直接通信，确保安全。 3.5 作用域（Scope）的最小化与清晰定义 原则： 客户端只请求其完成任务所需的最小权限集合。 实践： 授权服务器应清晰地定义并文档化其支持的Scope，并确保用户在同意页面上能清楚理解每个Scope的含义。 3.6 令牌撤销（Token Revocation） 重要性： 当用户撤销授权、客户端被禁用、或令牌被泄露时，需要能够及时撤销已颁发的访问令牌和刷新令牌。 实践： 授权服务器应提供一个撤销端点（Revocation Endpoint），允许客户端或资源所有者请求撤销特定令牌。 总结 OAuth 2.0是一个强大而复杂的授权框架，其安全性的实现依赖于对访问令牌、刷新令牌、作用域等核心概念的深入理解，以及对一系列安全最佳实践的严格遵循。通过PKCE、State参数、严格的重定向URI验证、安全的令牌存储与传输，以及细粒度的作用域管理和令牌撤销机制，我们可以大幅提升OAuth 2.0授权流程的安全性，有效抵御各种攻击。\n掌握这些细节，不仅能帮助你更好地设计和实现OAuth 2.0应用，也是构建健壮且符合现代安全标准IAM系统的关键一步。在下一篇中，我们将探讨OpenID Connect如何在OAuth 2.0的基础上提供身份认证功能，实现真正的单点登录。\n欢迎关注+点赞+推荐+转发\n","wordCount":"155","inLanguage":"zh","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC14%E7%AF%87oauth-2.0%E4%B8%8B%E4%BB%A4%E7%89%8Ctoken%E8%8C%83%E5%9B%B4scope%E4%B8%8E%E5%AE%89%E5%85%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},"publisher":{"@type":"Organization","name":"万年水的博客","logo":{"@type":"ImageObject","url":"https://bsong2015.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bsong2015.github.io/blog/ accesskey=h title="万年水的博客 (Alt + H)">万年水的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bsong2015.github.io/blog/posts/artificial-intelligence/ title=人工智能><span>人工智能</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/reading/ title=阅读><span>阅读</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/thinking-models/ title=思维模型><span>思维模型</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/thought-experiments/ title=思想实验><span>思想实验</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/personal-growth/ title=个人成长><span>个人成长</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/technology/ title=技术><span>技术</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/current-affairs/ title=时事><span>时事</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/others/ title=其它><span>其它</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent"></h1><div class=post-meta></div></header><div class=post-content><h2 id=第14篇oauth-20下令牌token范围scope与安全最佳实践>第14篇：OAuth 2.0（下）：令牌（Token）、范围（Scope）与安全最佳实践<a hidden class=anchor aria-hidden=true href=#第14篇oauth-20下令牌token范围scope与安全最佳实践>#</a></h2><p>在上一篇文章中，我们介绍了OAuth 2.0作为授权框架的背景、核心角色以及四种主要的授权模式。我们了解到，OAuth 2.0的核心目标是在不共享用户凭证的前提下，安全地实现第三方应用对用户资源的访问。而实现这一目标的关键，正是其所颁发的各种<strong>令牌（Token）</strong> 以及对<strong>授权范围（Scope）</strong> 的精确控制。</p><p>本篇将深入探讨OAuth 2.0中的令牌类型、作用域概念，并重点讲解确保OAuth 2.0流程安全的关键机制和最佳实践，帮助你构建更健壮、更安全的授权体系。</p><h3 id=1-核心令牌类型授权的凭证>1. 核心令牌类型：授权的凭证<a hidden class=anchor aria-hidden=true href=#1-核心令牌类型授权的凭证>#</a></h3><p>OAuth 2.0主要定义了两种核心令牌，它们在授权流程中扮演着不同的角色：</p><h4 id=11-访问令牌access-token>1.1 访问令牌（Access Token）<a hidden class=anchor aria-hidden=true href=#11-访问令牌access-token>#</a></h4><ul><li><strong>定义：</strong> 访问令牌是客户端访问<strong>受保护资源</strong>的凭证。它是一个短生命周期的字符串，代表了用户授权客户端访问特定资源和执行特定操作的许可。</li><li><strong>特性：</strong><ul><li><strong>不透明性（Opaque）：</strong> 对于客户端而言，访问令牌通常是<strong>不透明</strong>的字符串（可以是随机字符串、JWT等）。客户端不需要解析其内部结构，只需将其作为凭证传递给资源服务器。</li><li><strong>生命周期：</strong> 访问令牌通常具有较短的有效期（例如，几分钟到几小时）。过期后，客户端需要通过其他方式获取新的访问令牌。</li><li><strong>承载者令牌（Bearer Token）：</strong> 大多数情况下，访问令牌是“承载者令牌”。这意味着任何持有该令牌的实体都可以访问相应的资源，如同持有现金一样。因此，访问令牌的保密性至关重要。</li></ul></li><li><strong>用途：</strong> 客户端在向资源服务器发送请求时，通常会在HTTP请求的"Authorization"头中携带访问令牌，例如：&ldquo;Authorization: Bearer &lt;access_token>"。资源服务器会验证该令牌的有效性（包括是否过期、是否伪造、是否有权限），然后响应请求。</li></ul><h4 id=12-刷新令牌refresh-token>1.2 刷新令牌（Refresh Token）<a hidden class=anchor aria-hidden=true href=#12-刷新令牌refresh-token>#</a></h4><ul><li><strong>定义：</strong> 刷新令牌是客户端用于获取<strong>新的访问令牌</strong>的凭证。它是一个长生命周期的令牌，通常只颁发给那些能够安全存储它的客户端（例如，服务器端应用）。</li><li><strong>特性：</strong><ul><li><strong>生命周期：</strong> 刷新令牌通常具有较长的有效期，甚至可以是永久的，直到被显式撤销或用户修改密码。</li><li><strong>保密性：</strong> 由于刷新令牌的生命周期长，且能够获取新的访问令牌，其安全存储（通常在服务器端，不暴露给浏览器或移动应用）是至关重要的。</li><li><strong>一次性使用或旋转：</strong> 为增强安全性，有些实现会强制刷新令牌在每次使用后即失效，并返回一个新的刷新令牌（刷新令牌旋转），以降低泄露风险。</li></ul></li><li><strong>用途：</strong> 当访问令牌过期时，客户端可以使用刷新令牌向授权服务器的令牌端点再次请求获取新的访问令牌（以及可能的新刷新令牌），而无需用户再次进行授权。这提升了用户体验，减少了用户重复登录的频率。</li></ul><h3 id=2-精确授权范围作用域scope与用户同意consent>2. 精确授权范围：作用域（Scope）与用户同意（Consent）<a hidden class=anchor aria-hidden=true href=#2-精确授权范围作用域scope与用户同意consent>#</a></h3><h4 id=21-作用域scope>2.1 作用域（Scope）<a hidden class=anchor aria-hidden=true href=#21-作用域scope>#</a></h4><ul><li><strong>定义：</strong> Scope是OAuth 2.0中用于指定客户端所请求的<strong>访问权限范围</strong>的字符串。它定义了客户端可以访问哪些资源以及可以执行哪些操作。</li><li><strong>重要性：</strong> Scope实现了<strong>最小权限原则</strong>。客户端不应获得超过其完成任务所需的权限。例如，一个客户端可能只请求“读取用户相册”的权限，而不是“修改用户所有数据”的权限。</li><li><strong>示例：</strong> &ldquo;read_photos&rdquo;、&ldquo;write_posts&rdquo;、&ldquo;email&rdquo;、&ldquo;profile"等。授权服务器会维护一个可用的Scope列表。</li><li><strong>工作原理：</strong><ol><li>客户端在向授权服务器请求授权时，会带上其所需的"scope"参数。</li><li>授权服务器会根据客户端请求的Scope，向用户展示一个<strong>用户同意（Consent）</strong> 页面。</li><li>如果用户同意，授权服务器颁发的访问令牌将仅包含用户授权的Scope，资源服务器在验证令牌时也会检查其Scope是否满足请求操作所需权限。</li></ol></li></ul><h4 id=22-用户同意consent>2.2 用户同意（Consent）<a hidden class=anchor aria-hidden=true href=#22-用户同意consent>#</a></h4><ul><li><strong>定义：</strong> 用户同意是指在OAuth 2.0流程中，授权服务器向资源所有者展示一个明确的界面，说明客户端正在请求哪些权限（通过Scope），并征得用户的同意。</li><li><strong>重要性：</strong> 用户同意是OAuth 2.0<strong>委托授权</strong>理念的直接体现。它确保用户对自己的数据和隐私拥有控制权，知道自己的数据将如何被第三方应用使用。</li><li><strong>工作原理：</strong> 用户在授权服务器的同意页面上，可以看到客户端请求的"scope&rdquo;，并选择“同意”或“拒绝”。只有当用户明确同意后，授权服务器才会继续颁发令牌。</li></ul><h3 id=3-oauth-20安全最佳实践铸就铜墙铁壁>3. OAuth 2.0安全最佳实践：铸就铜墙铁壁<a hidden class=anchor aria-hidden=true href=#3-oauth-20安全最佳实践铸就铜墙铁壁>#</a></h3><p>尽管OAuth 2.0框架本身具有较高的安全性，但错误的实现或忽视某些安全细节仍可能导致严重漏洞。以下是一些重要的安全考量和最佳实践：</p><h4 id=31-pkceproof-key-for-code-exchange>3.1 PKCE（Proof Key for Code Exchange）<a hidden class=anchor aria-hidden=true href=#31-pkceproof-key-for-code-exchange>#</a></h4><ul><li><strong>问题：</strong> 授权码模式在SPA或移动应用等公共客户端（无法安全存储"client_secret&rdquo;）中，可能面临“授权码拦截攻击”：恶意应用可能拦截授权码，然后用它来交换访问令牌。</li><li><strong>PKCE解决方案：</strong> PKCE是一种扩展，通过在授权请求和令牌交换过程中加入一个动态生成的“验证器”（&ldquo;code_verifier&rdquo;）和其哈希值（&ldquo;code_challenge&rdquo;）来缓解此问题。<ol><li>客户端在发起授权请求前，生成一个随机字符串"code_verifier"及其哈希值"code_challenge"。</li><li>客户端在授权请求中携带"code_challenge"。</li><li>授权服务器将授权码返回给客户端。</li><li>客户端在用授权码交换令牌时，必须同时发送原始的"code_verifier"。</li><li>授权服务器验证收到的"code_verifier"的哈希值是否与最初收到的"code_challenge"匹配。如果匹配，才颁发令牌。</li></ol></li><li><strong>优势：</strong> 即使授权码被拦截，攻击者也无法获取访问令牌，因为他们没有"code_verifier"。<strong>PKCE已成为公共客户端（如SPA和移动应用）使用授权码模式时的强制要求。</strong></li></ul><h4 id=32-state-参数>3.2 State 参数<a hidden class=anchor aria-hidden=true href=#32-state-参数>#</a></h4><ul><li><strong>问题：</strong> 在授权码模式和隐式模式中，攻击者可能利用**CSRF（跨站请求伪造）**攻击，或将用户重定向到恶意网站，进行会话固定攻击或冒充授权响应。</li><li><strong>State 参数解决方案：</strong> &ldquo;state"参数是一个由客户端生成的、在授权请求和重定向回调过程中保持不变的随机字符串。<ol><li>客户端在生成授权请求URI时，生成一个唯一的"state"值，并将其存储在客户端的会话中。</li><li>授权服务器在处理完授权后，会将这个"state"值原封不动地返回给客户端的重定向URI。</li><li>客户端收到重定向后，必须验证返回的"state"值是否与自己之前存储的"state"值匹配。</li></ol></li><li><strong>优势：</strong> 如果"state"值不匹配，客户端应拒绝处理响应，从而有效防止CSRF攻击和恶意重定向。<strong>&ldquo;state"参数的使用是强制性的安全要求。</strong></li></ul><h4 id=33-redirect-uri-验证>3.3 Redirect URI 验证<a hidden class=anchor aria-hidden=true href=#33-redirect-uri-验证>#</a></h4><ul><li><strong>问题：</strong> 攻击者可能通过伪造"redirect_uri"参数，将授权码或访问令牌重定向到恶意服务器。</li><li><strong>解决方案：</strong><ol><li>客户端在授权服务器处注册时，必须预先注册其所有合法的"redirect_uri&rdquo;。</li><li>授权服务器在处理授权请求时，必须严格验证请求中提供的"redirect_uri"是否与预注册的URI之一完全匹配。</li></ol></li><li><strong>优势：</strong> 防止开放重定向漏洞，确保令牌只发送到受信任的客户端回调地址。</li></ul><h4 id=34-token-存储与传输>3.4 Token 存储与传输<a hidden class=anchor aria-hidden=true href=#34-token-存储与传输>#</a></h4><ul><li><strong>访问令牌：</strong><ul><li><strong>传输：</strong> 始终通过HTTPS/TLS加密通道传输令牌，防止窃听。</li><li><strong>存储：</strong> 客户端不应在不安全的客户端存储（如浏览器Local Storage）中长期存储访问令牌，尤其是在SPA中。可以考虑使用内存存储或HttpOnly Cookie（对于后端颁发给前端的会话令牌）。</li></ul></li><li><strong>刷新令牌：</strong><ul><li><strong>存储：</strong> 刷新令牌必须安全地存储在<strong>服务器端</strong>（例如，加密的数据库或安全的密钥管理系统），绝不能暴露给浏览器或其他不安全的客户端。</li><li><strong>使用：</strong> 刷新令牌的请求必须使用客户端凭证（&ldquo;client_secret&rdquo;），并通过后端与授权服务器直接通信，确保安全。</li></ul></li></ul><h4 id=35-作用域scope的最小化与清晰定义>3.5 作用域（Scope）的最小化与清晰定义<a hidden class=anchor aria-hidden=true href=#35-作用域scope的最小化与清晰定义>#</a></h4><ul><li><strong>原则：</strong> 客户端只请求其完成任务所需的最小权限集合。</li><li><strong>实践：</strong> 授权服务器应清晰地定义并文档化其支持的Scope，并确保用户在同意页面上能清楚理解每个Scope的含义。</li></ul><h4 id=36-令牌撤销token-revocation>3.6 令牌撤销（Token Revocation）<a hidden class=anchor aria-hidden=true href=#36-令牌撤销token-revocation>#</a></h4><ul><li><strong>重要性：</strong> 当用户撤销授权、客户端被禁用、或令牌被泄露时，需要能够及时撤销已颁发的访问令牌和刷新令牌。</li><li><strong>实践：</strong> 授权服务器应提供一个<strong>撤销端点（Revocation Endpoint）</strong>，允许客户端或资源所有者请求撤销特定令牌。</li></ul><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><p>OAuth 2.0是一个强大而复杂的授权框架，其安全性的实现依赖于对访问令牌、刷新令牌、作用域等核心概念的深入理解，以及对一系列安全最佳实践的严格遵循。通过PKCE、State参数、严格的重定向URI验证、安全的令牌存储与传输，以及细粒度的作用域管理和令牌撤销机制，我们可以大幅提升OAuth 2.0授权流程的安全性，有效抵御各种攻击。</p><p>掌握这些细节，不仅能帮助你更好地设计和实现OAuth 2.0应用，也是构建健壮且符合现代安全标准IAM系统的关键一步。在下一篇中，我们将探讨OpenID Connect如何在OAuth 2.0的基础上提供身份认证功能，实现真正的单点登录。</p><h3></h3><p><strong>欢迎关注+点赞+推荐+转发</strong></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bsong2015.github.io/blog/>万年水的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>