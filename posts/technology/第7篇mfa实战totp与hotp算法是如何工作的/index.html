<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>万年水的博客</title><meta name=keywords content><meta name=description content="第7篇：MFA实战：TOTP与HOTP算法是如何工作的？
在上一篇中，我们概览了多因素认证（MFA）的重要性及常见类型。其中，一次性密码（OTP）因其便捷性和较高的安全性而成为MFA的基石。而OTP家族中，基于时间的一次性密码（TOTP） 和基于HMAC的一次性密码（HOTP） 是应用最广泛的两种算法。
你可能已经在Google Authenticator、Microsoft Authenticator等应用中体验过TOTP，或者在一些物理令牌上见过HOTP。那么，这些看似随机却又能被服务器正确验证的6位或8位数字是如何生成的呢？本篇文章将深入揭示TOTP和HOTP的算法原理，并结合Java代码片段进行说明。
1. HOTP（HMAC-based One-Time Password）：基于HMAC的计数器同步
HOTP是OTP的基础，它通过一个秘密密钥和一个递增的计数器来生成一次性密码。
1.1 HOTP算法原理
HOTP的核心思想是：客户端和服务器共享一个秘密密钥（Shared Secret Key）K和一个计数器（Counter）C。每次生成OTP时，计数器C递增1，然后将K和C作为输入，通过一个加密哈希函数（通常是HMAC-SHA1）来生成一个哈希值，最后从这个哈希值中提取出固定位数的数字作为OTP。
算法步骤：

共享秘密密钥 (K)： 客户端（如Authenticator应用）和服务器预先协商并存储一个只有双方知道的秘密密钥。这个密钥通常以Base32编码形式展示给用户，用于在Authenticator应用中进行扫描或手动输入。
计数器 (C)： 客户端和服务器都维护一个独立的计数器，初始值通常为0或1。每次生成或验证OTP时，计数器都会递增。
计算HMAC值： 使用HMAC-SHA1算法，以共享秘密密钥K作为HMAC的密钥，以计数器C的字节表示作为HMAC的消息。

HS = HMAC-SHA1(K, C)
这里需要注意，计数器C是一个64位的整数，需要将其转换为字节数组。


动态截取（Dynamic Truncation）： 从HMAC-SHA1生成的20字节（160位）哈希值HS中，提取出一个31位（非符号位）的数字。这个过程是为了从二进制哈希值中获得一个可读的数字OTP。

取HS的最后一个字节的低4位（HS[19] & 0xF）作为偏移量offset。
从HS中offset位置开始，连续取4个字节（HS[offset...offset+3]）。
将这4个字节转换为一个32位整数，并将其最高位清零（避免负数）。
Snum = (HS[offset] & 0x7f) << 24 | (HS[offset+1] & 0xff) << 16 | (HS[offset+2] & 0xff) << 8 | (HS[offset+3] & 0xff)


生成OTP： 将上一步得到的31位数字Snum对10^D取模，其中D是OTP的位数（通常是6位或8位），然后补足前导零。

OTP = Snum % (10^D)



1.2 HOTP的挑战：计数器同步
HOTP的主要挑战在于客户端和服务器的计数器必须严格同步。如果用户在客户端多次生成OTP但没有在服务器端验证（例如，生成了两次但只提交了一次），或者服务器因为某些原因重置了计数器，都可能导致计数器不同步，从而无法通过验证。"><meta name=author content><link rel=canonical href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC7%E7%AF%87mfa%E5%AE%9E%E6%88%98totp%E4%B8%8Ehotp%E7%AE%97%E6%B3%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://bsong2015.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bsong2015.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bsong2015.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://bsong2015.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://bsong2015.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC7%E7%AF%87mfa%E5%AE%9E%E6%88%98totp%E4%B8%8Ehotp%E7%AE%97%E6%B3%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC7%E7%AF%87mfa%E5%AE%9E%E6%88%98totp%E4%B8%8Ehotp%E7%AE%97%E6%B3%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"><meta property="og:site_name" content="万年水的博客"><meta property="og:title" content="万年水的博客"><meta property="og:description" content="第7篇：MFA实战：TOTP与HOTP算法是如何工作的？ 在上一篇中，我们概览了多因素认证（MFA）的重要性及常见类型。其中，一次性密码（OTP）因其便捷性和较高的安全性而成为MFA的基石。而OTP家族中，基于时间的一次性密码（TOTP） 和基于HMAC的一次性密码（HOTP） 是应用最广泛的两种算法。
你可能已经在Google Authenticator、Microsoft Authenticator等应用中体验过TOTP，或者在一些物理令牌上见过HOTP。那么，这些看似随机却又能被服务器正确验证的6位或8位数字是如何生成的呢？本篇文章将深入揭示TOTP和HOTP的算法原理，并结合Java代码片段进行说明。
1. HOTP（HMAC-based One-Time Password）：基于HMAC的计数器同步 HOTP是OTP的基础，它通过一个秘密密钥和一个递增的计数器来生成一次性密码。
1.1 HOTP算法原理 HOTP的核心思想是：客户端和服务器共享一个秘密密钥（Shared Secret Key）K和一个计数器（Counter）C。每次生成OTP时，计数器C递增1，然后将K和C作为输入，通过一个加密哈希函数（通常是HMAC-SHA1）来生成一个哈希值，最后从这个哈希值中提取出固定位数的数字作为OTP。
算法步骤：
共享秘密密钥 (K)： 客户端（如Authenticator应用）和服务器预先协商并存储一个只有双方知道的秘密密钥。这个密钥通常以Base32编码形式展示给用户，用于在Authenticator应用中进行扫描或手动输入。 计数器 (C)： 客户端和服务器都维护一个独立的计数器，初始值通常为0或1。每次生成或验证OTP时，计数器都会递增。 计算HMAC值： 使用HMAC-SHA1算法，以共享秘密密钥K作为HMAC的密钥，以计数器C的字节表示作为HMAC的消息。 HS = HMAC-SHA1(K, C) 这里需要注意，计数器C是一个64位的整数，需要将其转换为字节数组。 动态截取（Dynamic Truncation）： 从HMAC-SHA1生成的20字节（160位）哈希值HS中，提取出一个31位（非符号位）的数字。这个过程是为了从二进制哈希值中获得一个可读的数字OTP。 取HS的最后一个字节的低4位（HS[19] & 0xF）作为偏移量offset。 从HS中offset位置开始，连续取4个字节（HS[offset...offset+3]）。 将这4个字节转换为一个32位整数，并将其最高位清零（避免负数）。 Snum = (HS[offset] & 0x7f) << 24 | (HS[offset+1] & 0xff) << 16 | (HS[offset+2] & 0xff) << 8 | (HS[offset+3] & 0xff) 生成OTP： 将上一步得到的31位数字Snum对10^D取模，其中D是OTP的位数（通常是6位或8位），然后补足前导零。 OTP = Snum % (10^D) 1.2 HOTP的挑战：计数器同步 HOTP的主要挑战在于客户端和服务器的计数器必须严格同步。如果用户在客户端多次生成OTP但没有在服务器端验证（例如，生成了两次但只提交了一次），或者服务器因为某些原因重置了计数器，都可能导致计数器不同步，从而无法通过验证。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="第7篇：MFA实战：TOTP与HOTP算法是如何工作的？
在上一篇中，我们概览了多因素认证（MFA）的重要性及常见类型。其中，一次性密码（OTP）因其便捷性和较高的安全性而成为MFA的基石。而OTP家族中，基于时间的一次性密码（TOTP） 和基于HMAC的一次性密码（HOTP） 是应用最广泛的两种算法。
你可能已经在Google Authenticator、Microsoft Authenticator等应用中体验过TOTP，或者在一些物理令牌上见过HOTP。那么，这些看似随机却又能被服务器正确验证的6位或8位数字是如何生成的呢？本篇文章将深入揭示TOTP和HOTP的算法原理，并结合Java代码片段进行说明。
1. HOTP（HMAC-based One-Time Password）：基于HMAC的计数器同步
HOTP是OTP的基础，它通过一个秘密密钥和一个递增的计数器来生成一次性密码。
1.1 HOTP算法原理
HOTP的核心思想是：客户端和服务器共享一个秘密密钥（Shared Secret Key）K和一个计数器（Counter）C。每次生成OTP时，计数器C递增1，然后将K和C作为输入，通过一个加密哈希函数（通常是HMAC-SHA1）来生成一个哈希值，最后从这个哈希值中提取出固定位数的数字作为OTP。
算法步骤：

共享秘密密钥 (K)： 客户端（如Authenticator应用）和服务器预先协商并存储一个只有双方知道的秘密密钥。这个密钥通常以Base32编码形式展示给用户，用于在Authenticator应用中进行扫描或手动输入。
计数器 (C)： 客户端和服务器都维护一个独立的计数器，初始值通常为0或1。每次生成或验证OTP时，计数器都会递增。
计算HMAC值： 使用HMAC-SHA1算法，以共享秘密密钥K作为HMAC的密钥，以计数器C的字节表示作为HMAC的消息。

HS = HMAC-SHA1(K, C)
这里需要注意，计数器C是一个64位的整数，需要将其转换为字节数组。


动态截取（Dynamic Truncation）： 从HMAC-SHA1生成的20字节（160位）哈希值HS中，提取出一个31位（非符号位）的数字。这个过程是为了从二进制哈希值中获得一个可读的数字OTP。

取HS的最后一个字节的低4位（HS[19] & 0xF）作为偏移量offset。
从HS中offset位置开始，连续取4个字节（HS[offset...offset+3]）。
将这4个字节转换为一个32位整数，并将其最高位清零（避免负数）。
Snum = (HS[offset] & 0x7f) << 24 | (HS[offset+1] & 0xff) << 16 | (HS[offset+2] & 0xff) << 8 | (HS[offset+3] & 0xff)


生成OTP： 将上一步得到的31位数字Snum对10^D取模，其中D是OTP的位数（通常是6位或8位），然后补足前导零。

OTP = Snum % (10^D)



1.2 HOTP的挑战：计数器同步
HOTP的主要挑战在于客户端和服务器的计数器必须严格同步。如果用户在客户端多次生成OTP但没有在服务器端验证（例如，生成了两次但只提交了一次），或者服务器因为某些原因重置了计数器，都可能导致计数器不同步，从而无法通过验证。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bsong2015.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"技术实践","item":"https://bsong2015.github.io/blog/posts/technology/"},{"@type":"ListItem","position":3,"name":"","item":"https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC7%E7%AF%87mfa%E5%AE%9E%E6%88%98totp%E4%B8%8Ehotp%E7%AE%97%E6%B3%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"第7篇：MFA实战：TOTP与HOTP算法是如何工作的？ 在上一篇中，我们概览了多因素认证（MFA）的重要性及常见类型。其中，一次性密码（OTP）因其便捷性和较高的安全性而成为MFA的基石。而OTP家族中，基于时间的一次性密码（TOTP） 和基于HMAC的一次性密码（HOTP） 是应用最广泛的两种算法。\n你可能已经在Google Authenticator、Microsoft Authenticator等应用中体验过TOTP，或者在一些物理令牌上见过HOTP。那么，这些看似随机却又能被服务器正确验证的6位或8位数字是如何生成的呢？本篇文章将深入揭示TOTP和HOTP的算法原理，并结合Java代码片段进行说明。\n1. HOTP（HMAC-based One-Time Password）：基于HMAC的计数器同步 HOTP是OTP的基础，它通过一个秘密密钥和一个递增的计数器来生成一次性密码。\n1.1 HOTP算法原理 HOTP的核心思想是：客户端和服务器共享一个秘密密钥（Shared Secret Key）K和一个计数器（Counter）C。每次生成OTP时，计数器C递增1，然后将K和C作为输入，通过一个加密哈希函数（通常是HMAC-SHA1）来生成一个哈希值，最后从这个哈希值中提取出固定位数的数字作为OTP。\n算法步骤：\n共享秘密密钥 (K)： 客户端（如Authenticator应用）和服务器预先协商并存储一个只有双方知道的秘密密钥。这个密钥通常以Base32编码形式展示给用户，用于在Authenticator应用中进行扫描或手动输入。 计数器 (C)： 客户端和服务器都维护一个独立的计数器，初始值通常为0或1。每次生成或验证OTP时，计数器都会递增。 计算HMAC值： 使用HMAC-SHA1算法，以共享秘密密钥K作为HMAC的密钥，以计数器C的字节表示作为HMAC的消息。 HS = HMAC-SHA1(K, C) 这里需要注意，计数器C是一个64位的整数，需要将其转换为字节数组。 动态截取（Dynamic Truncation）： 从HMAC-SHA1生成的20字节（160位）哈希值HS中，提取出一个31位（非符号位）的数字。这个过程是为了从二进制哈希值中获得一个可读的数字OTP。 取HS的最后一个字节的低4位（HS[19] \u0026amp; 0xF）作为偏移量offset。 从HS中offset位置开始，连续取4个字节（HS[offset...offset+3]）。 将这4个字节转换为一个32位整数，并将其最高位清零（避免负数）。 Snum = (HS[offset] \u0026amp; 0x7f) \u0026lt;\u0026lt; 24 | (HS[offset+1] \u0026amp; 0xff) \u0026lt;\u0026lt; 16 | (HS[offset+2] \u0026amp; 0xff) \u0026lt;\u0026lt; 8 | (HS[offset+3] \u0026amp; 0xff) 生成OTP： 将上一步得到的31位数字Snum对10^D取模，其中D是OTP的位数（通常是6位或8位），然后补足前导零。 OTP = Snum % (10^D) 1.2 HOTP的挑战：计数器同步 HOTP的主要挑战在于客户端和服务器的计数器必须严格同步。如果用户在客户端多次生成OTP但没有在服务器端验证（例如，生成了两次但只提交了一次），或者服务器因为某些原因重置了计数器，都可能导致计数器不同步，从而无法通过验证。\n","keywords":[],"articleBody":"第7篇：MFA实战：TOTP与HOTP算法是如何工作的？ 在上一篇中，我们概览了多因素认证（MFA）的重要性及常见类型。其中，一次性密码（OTP）因其便捷性和较高的安全性而成为MFA的基石。而OTP家族中，基于时间的一次性密码（TOTP） 和基于HMAC的一次性密码（HOTP） 是应用最广泛的两种算法。\n你可能已经在Google Authenticator、Microsoft Authenticator等应用中体验过TOTP，或者在一些物理令牌上见过HOTP。那么，这些看似随机却又能被服务器正确验证的6位或8位数字是如何生成的呢？本篇文章将深入揭示TOTP和HOTP的算法原理，并结合Java代码片段进行说明。\n1. HOTP（HMAC-based One-Time Password）：基于HMAC的计数器同步 HOTP是OTP的基础，它通过一个秘密密钥和一个递增的计数器来生成一次性密码。\n1.1 HOTP算法原理 HOTP的核心思想是：客户端和服务器共享一个秘密密钥（Shared Secret Key）K和一个计数器（Counter）C。每次生成OTP时，计数器C递增1，然后将K和C作为输入，通过一个加密哈希函数（通常是HMAC-SHA1）来生成一个哈希值，最后从这个哈希值中提取出固定位数的数字作为OTP。\n算法步骤：\n共享秘密密钥 (K)： 客户端（如Authenticator应用）和服务器预先协商并存储一个只有双方知道的秘密密钥。这个密钥通常以Base32编码形式展示给用户，用于在Authenticator应用中进行扫描或手动输入。 计数器 (C)： 客户端和服务器都维护一个独立的计数器，初始值通常为0或1。每次生成或验证OTP时，计数器都会递增。 计算HMAC值： 使用HMAC-SHA1算法，以共享秘密密钥K作为HMAC的密钥，以计数器C的字节表示作为HMAC的消息。 HS = HMAC-SHA1(K, C) 这里需要注意，计数器C是一个64位的整数，需要将其转换为字节数组。 动态截取（Dynamic Truncation）： 从HMAC-SHA1生成的20字节（160位）哈希值HS中，提取出一个31位（非符号位）的数字。这个过程是为了从二进制哈希值中获得一个可读的数字OTP。 取HS的最后一个字节的低4位（HS[19] \u0026 0xF）作为偏移量offset。 从HS中offset位置开始，连续取4个字节（HS[offset...offset+3]）。 将这4个字节转换为一个32位整数，并将其最高位清零（避免负数）。 Snum = (HS[offset] \u0026 0x7f) \u003c\u003c 24 | (HS[offset+1] \u0026 0xff) \u003c\u003c 16 | (HS[offset+2] \u0026 0xff) \u003c\u003c 8 | (HS[offset+3] \u0026 0xff) 生成OTP： 将上一步得到的31位数字Snum对10^D取模，其中D是OTP的位数（通常是6位或8位），然后补足前导零。 OTP = Snum % (10^D) 1.2 HOTP的挑战：计数器同步 HOTP的主要挑战在于客户端和服务器的计数器必须严格同步。如果用户在客户端多次生成OTP但没有在服务器端验证（例如，生成了两次但只提交了一次），或者服务器因为某些原因重置了计数器，都可能导致计数器不同步，从而无法通过验证。\n为了解决这个问题，服务器通常会维护一个“窗口”（Look-ahead Window）。当用户提交一个OTP时，服务器不仅检查当前计数器C的OTP，还会检查C+1、C+2…C+W（W为窗口大小）的OTP。一旦在窗口内找到匹配的OTP，服务器就会将自己的计数器更新到匹配的那个值，以实现“漂移”同步。\n1.3 HOTP Java代码片段示例 下面是一个简化的HOTP实现示例。在实际应用中，通常会使用现有的库。\nimport javax.crypto.Mac; import javax.crypto.spec.SecretKeySpec; import java.nio.ByteBuffer; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.util.Arrays; public class HotpUtil { private static final String ALGORITHM = \"HmacSHA1\"; // RFC 4226 推荐使用HMAC-SHA1 /** * 生成HOTP * @param secretKey 共享秘密密钥 * @param counter 计数器值 * @param digits OTP位数 (通常是6或8) * @return 生成的OTP字符串 */ public static String generateHOTP(byte[] secretKey, long counter, int digits) throws NoSuchAlgorithmException, InvalidKeyException { // 1. 将计数器转换为8字节的字节数组 ByteBuffer buffer = ByteBuffer.allocate(8); buffer.putLong(counter); byte[] counterBytes = buffer.array(); // 2. 计算HMAC-SHA1值 Mac hmac = Mac.getInstance(ALGORITHM); SecretKeySpec keySpec = new SecretKeySpec(secretKey, ALGORITHM); hmac.init(keySpec); byte[] hash = hmac.doFinal(counterBytes); // 3. 动态截取 (Dynamic Truncation) // 取最后一个字节的低4位作为偏移量 int offset = hash[hash.length - 1] \u0026 0xF; // 从偏移量处取4个字节 int binary = ((hash[offset] \u0026 0x7f) \u003c\u003c 24) | ((hash[offset + 1] \u0026 0xff) \u003c\u003c 16) | ((hash[offset + 2] \u0026 0xff) \u003c\u003c 8) | (hash[offset + 3] \u0026 0xff); // 4. 生成OTP (对10^digits取模) int otp = binary % (int) Math.pow(10, digits); // 格式化为指定位数，不足前面补零 return String.format(\"%0\" + digits + \"d\", otp); } public static void main(String[] args) throws Exception { // 示例：密钥和计数器 byte[] secret = \"12345678901234567890\".getBytes(); // 示例密钥，实际应是随机且安全的 long counter = 0; // 初始计数器 for (int i = 0; i \u003c 5; i++) { String otp = generateHOTP(secret, counter + i, 6); System.out.println(\"Counter: \" + (counter + i) + \", OTP: \" + otp); } // 验证示例：服务器端接收到用户提交的OTP // 假设用户提交了第一个OTP \"755224\" String userSubmittedOtp = \"755224\"; long serverCounter = 0; // 服务器当前计数器 int lookAheadWindow = 5; // 窗口大小 boolean verified = false; long verifiedCounter = -1; for (int i = 0; i \u003c= lookAheadWindow; i++) { String expectedOtp = generateHOTP(secret, serverCounter + i, 6); if (expectedOtp.equals(userSubmittedOtp)) { verified = true; verifiedCounter = serverCounter + i; break; } } if (verified) { System.out.println(\"OTP Verified successfully. Counter updated to: \" + (verifiedCounter + 1)); // 成功验证后，服务器需要更新其计数器到 verifiedCounter + 1 serverCounter = verifiedCounter + 1; } else { System.out.println(\"OTP Verification failed.\"); } } } 2. TOTP（Time-based One-Time Password）：基于时间的动态密码 TOTP是HOTP的变体，它用基于时间的值（通常是当前时间戳的离散化）代替了递增的计数器，从而消除了计数器同步的复杂性。\n2.1 TOTP算法原理 TOTP的核心思想是：客户端和服务器共享一个秘密密钥K，并且都依赖于当前时间。时间被划分为固定长度的“时间步长”（Time Step，通常为30秒或60秒）。在这个时间步长内，OTP是固定的。\n算法步骤：\n共享秘密密钥 (K)： 同HOTP，客户端和服务器共享一个秘密密钥。 时间步长 (X)： 定义一个时间窗口的长度，例如30秒。 当前时间戳 (T)： 获取当前的Unix时间戳（自UTC 1970年1月1日0时0分0秒以来的秒数）。 计算时间计数器 (TC)： 将当前时间戳除以时间步长X，得到一个整数值，作为时间计数器。 TC = floor(Current_Unix_Time / X) 这个TC值在整个时间步长X内是固定的。 HMAC计算和截取： 接下来，步骤与HOTP完全相同，只是将TC作为HOTP算法中的计数器C： OTP = HOTP(K, TC) 即：HS = HMAC-SHA1(K, TC)，然后进行动态截取和取模运算。 2.2 TOTP的优势与考虑 优势：\n无需计数器同步： 这是TOTP最大的优势。只要客户端和服务器的时间大致同步（通常允许几分钟的偏差），就能生成相同的OTP。这大大简化了实现和用户体验。 更广泛的应用： 适合移动Authenticator应用，用户无需每次操作后都通知服务器。 考虑因素：\n时间同步： 客户端设备和服务器的时间必须相对准确。如果偏差过大（超过一个或两个时间步长），OTP将无法匹配。通常允许+-1个时间步长的偏差进行验证，即服务器会尝试TC-1, TC, TC+1三个值。 重放攻击： 虽然OTP是基于时间的，但如果攻击者在OTP有效期内（例如30秒内）截获并重放，仍可能成功。因此，服务器端应确保每个OTP在成功使用一次后即失效。 2.3 TOTP Java代码片段示例 import javax.crypto.Mac; import javax.crypto.spec.SecretKeySpec; import java.nio.ByteBuffer; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.util.Base64; // 用于解码Base32密钥 public class TotpUtil { private static final String ALGORITHM = \"HmacSHA1\"; // RFC 6238 推荐使用HMAC-SHA1 private static final int TIME_STEP = 30; // 时间步长，通常30秒 /** * 生成TOTP * @param secretKey 共享秘密密钥 (字节数组) * @param currentTimeMillis 当前时间戳 (毫秒) * @param digits OTP位数 (通常是6或8) * @return 生成的OTP字符串 */ public static String generateTOTP(byte[] secretKey, long currentTimeMillis, int digits) throws NoSuchAlgorithmException, InvalidKeyException { // 1. 计算时间计数器 TC long T = currentTimeMillis / 1000; // 转换为秒 long TC = T / TIME_STEP; // 获取时间步长对应的整数值 // 2. 调用HOTP逻辑生成OTP // HOTPUtil中的generateHOTP方法可以直接复用 return HotpUtil.generateHOTP(secretKey, TC, digits); } /** * 将Base32编码的密钥转换为字节数组 * @param base32Key Base32编码的密钥字符串 * @return 字节数组密钥 */ public static byte[] decodeBase32(String base32Key) { // Base32 编码通常不包含填充字符'='，但如果包含，需要处理 base32Key = base32Key.toUpperCase().replace(\" \", \"\").replace(\"=\", \"\"); // 清理空格和填充 // JDK中没有直接的Base32解码器，通常需要引入第三方库（如Apache Commons Codec）， // 这里为了示例简化，假设是一个简单的Base32编码（或手动转换，实际生产不推荐） // 实际上，RFC 4648 Base32 是有固定字符集的，以下只是一个示意。 // 对于真实项目，请使用 org.apache.commons.codec.binary.Base32.decode() // 或 com.google.zxing.client.result.ParsedResult.decodeBase32() 等库 // 这是一个简化的、非标准的Base32解码，仅用于演示概念。 // 实际使用请引入成熟的Base32库。 // byte[] decoded = Base32.decode(base32Key); // 假设存在这样的标准方法 // 由于JDK原生不支持，这里用一个非常粗略的Base64替代（仅为演示数据流，并非真实的Base32解码） // 请勿在生产环境使用此方法进行Base32解码！ System.err.println(\"Warning: Using non-standard Base32 decoding for demo. Use a proper library like Apache Commons Codec for production.\"); return Base64.getDecoder().decode(base32Key.getBytes()); // 这是一个错误的Base32解码示例，仅为编译通过 } public static void main(String[] args) throws Exception { // 示例：Google Authenticator的密钥通常以Base32编码 // 假设这是一个通过二维码扫描或手动输入的密钥（通常是20字节的随机数据） // 注意：Base32密钥通常是16到20个字符，对应10到12.5字节的秘密数据 // RFC 6238 推荐至少128位（16字节）的秘密密钥 String base32EncodedSecret = \"JBSWY3DPEHPK3PXP\"; // 对应secretKey.getBytes() if it's 10 bytes // For a real 16-byte secret, example: Base32.encode(new byte[16]) -\u003e \"GEZDGNBVGYQTCMZXGEZDGNBVGYQTCMZX\" // 在真实项目中，应该使用一个标准的Base32解码库，例如： // byte[] secret = new Base32().decode(base32EncodedSecret); // 这里为了示例能运行，我们直接使用一个固定的字节数组作为secret，因为它与上述generateHOTP的secretKey参数类型一致 byte[] secret = \"abcdefghijklmnop\".getBytes(); // 16字节的示例密钥，确保长度足够 System.out.println(\"---- TOTP Generation ----\"); // 服务器端生成并验证OTP long currentUnixTime = System.currentTimeMillis(); String otp = generateTOTP(secret, currentUnixTime, 6); System.out.println(\"Current Time: \" + currentUnixTime + \", Generated OTP: \" + otp); // 模拟客户端在几秒后提交OTP long clientSubmitTime = System.currentTimeMillis() + 5 * 1000; // 5秒后提交 String clientOtp = generateTOTP(secret, clientSubmitTime, 6); // 客户端生成的OTP System.out.println(\"Client Time (5s later): \" + clientSubmitTime + \", Client Generated OTP: \" + clientOtp); // 服务器端验证：通常会检查当前时间步长及其前后一个步长的OTP System.out.println(\"\\n---- TOTP Verification ----\"); boolean verified = false; long serverTime = System.currentTimeMillis(); // 服务器当前时间 int timeWindowTolerance = 1; // 允许前后一个时间步长的偏差 for (int i = -timeWindowTolerance; i \u003c= timeWindowTolerance; i++) { long targetTime = serverTime + (long)i * TIME_STEP * 1000; // 计算目标时间 String expectedOtp = generateTOTP(secret, targetTime, 6); if (expectedOtp.equals(clientOtp)) { verified = true; System.out.println(\"Verification successful for time offset: \" + i); break; } } if (verified) { System.out.println(\"TOTP Verified successfully.\"); } else { System.out.println(\"TOTP Verification failed.\"); } } } 重要提示： 上述 decodeBase32 方法仅为示例代码的编译通过而提供了一个错误且不安全的实现（使用了Base64代替）。在生产环境中，请务必使用成熟的第三方Base32解码库，例如 Apache Commons Codec 库中的 org.apache.commons.codec.binary.Base32。\n总结 TOTP和HOTP算法虽然复杂，但其核心思想都离不开共享秘密密钥和动态变化的输入（计数器或时间戳），并通过加密哈希函数（HMAC-SHA1）来生成不可预测的一次性密码。\nHOTP 依赖于严格的计数器同步，适用于物理令牌等场景，但需要考虑同步漂移问题。 TOTP 则通过引入时间因素，大大简化了同步的复杂性，成为目前最主流的基于软件的一次性密码解决方案（如Google Authenticator）。 理解这些算法的底层工作原理，有助于我们更好地设计和集成MFA功能到IAM系统中，并对其安全性有更深刻的认识。在实际开发中，强烈建议使用经过充分测试和审计的第三方安全库来处理OTP的生成和验证，避免自己实现可能引入的漏洞。下一篇我们将探讨FIDO与WebAuthn技术。\n欢迎关注+点赞+推荐+转发\n","wordCount":"845","inLanguage":"zh","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC7%E7%AF%87mfa%E5%AE%9E%E6%88%98totp%E4%B8%8Ehotp%E7%AE%97%E6%B3%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},"publisher":{"@type":"Organization","name":"万年水的博客","logo":{"@type":"ImageObject","url":"https://bsong2015.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bsong2015.github.io/blog/ accesskey=h title="万年水的博客 (Alt + H)">万年水的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bsong2015.github.io/blog/posts/artificial-intelligence/ title=人工智能><span>人工智能</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/reading/ title=阅读><span>阅读</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/thinking-models/ title=思维模型><span>思维模型</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/thought-experiments/ title=思想实验><span>思想实验</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/personal-growth/ title=个人成长><span>个人成长</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/technology/ title=技术><span>技术</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/current-affairs/ title=时事><span>时事</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/others/ title=其它><span>其它</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent"></h1><div class=post-meta></div></header><div class=post-content><h2 id=第7篇mfa实战totp与hotp算法是如何工作的>第7篇：MFA实战：TOTP与HOTP算法是如何工作的？<a hidden class=anchor aria-hidden=true href=#第7篇mfa实战totp与hotp算法是如何工作的>#</a></h2><p>在上一篇中，我们概览了多因素认证（MFA）的重要性及常见类型。其中，一次性密码（OTP）因其便捷性和较高的安全性而成为MFA的基石。而OTP家族中，<strong>基于时间的一次性密码（TOTP）</strong> 和<strong>基于HMAC的一次性密码（HOTP）</strong> 是应用最广泛的两种算法。</p><p>你可能已经在Google Authenticator、Microsoft Authenticator等应用中体验过TOTP，或者在一些物理令牌上见过HOTP。那么，这些看似随机却又能被服务器正确验证的6位或8位数字是如何生成的呢？本篇文章将深入揭示TOTP和HOTP的算法原理，并结合Java代码片段进行说明。</p><h3 id=1-hotphmac-based-one-time-password基于hmac的计数器同步>1. HOTP（HMAC-based One-Time Password）：基于HMAC的计数器同步<a hidden class=anchor aria-hidden=true href=#1-hotphmac-based-one-time-password基于hmac的计数器同步>#</a></h3><p>HOTP是OTP的基础，它通过一个秘密密钥和一个递增的计数器来生成一次性密码。</p><h4 id=11-hotp算法原理>1.1 HOTP算法原理<a hidden class=anchor aria-hidden=true href=#11-hotp算法原理>#</a></h4><p>HOTP的核心思想是：客户端和服务器共享一个<strong>秘密密钥（Shared Secret Key）K</strong>和一个<strong>计数器（Counter）C</strong>。每次生成OTP时，计数器C递增1，然后将K和C作为输入，通过一个加密哈希函数（通常是HMAC-SHA1）来生成一个哈希值，最后从这个哈希值中提取出固定位数的数字作为OTP。</p><p><strong>算法步骤：</strong></p><ol><li><strong>共享秘密密钥 (K)：</strong> 客户端（如Authenticator应用）和服务器预先协商并存储一个只有双方知道的秘密密钥。这个密钥通常以Base32编码形式展示给用户，用于在Authenticator应用中进行扫描或手动输入。</li><li><strong>计数器 (C)：</strong> 客户端和服务器都维护一个独立的计数器，初始值通常为0或1。每次生成或验证OTP时，计数器都会递增。</li><li><strong>计算HMAC值：</strong> 使用HMAC-SHA1算法，以共享秘密密钥K作为HMAC的密钥，以计数器C的字节表示作为HMAC的消息。<ul><li><code>HS = HMAC-SHA1(K, C)</code></li><li>这里需要注意，计数器C是一个64位的整数，需要将其转换为字节数组。</li></ul></li><li><strong>动态截取（Dynamic Truncation）：</strong> 从HMAC-SHA1生成的20字节（160位）哈希值<code>HS</code>中，提取出一个31位（非符号位）的数字。这个过程是为了从二进制哈希值中获得一个可读的数字OTP。<ul><li>取<code>HS</code>的最后一个字节的低4位（<code>HS[19] & 0xF</code>）作为偏移量<code>offset</code>。</li><li>从<code>HS</code>中<code>offset</code>位置开始，连续取4个字节（<code>HS[offset...offset+3]</code>）。</li><li>将这4个字节转换为一个32位整数，并将其最高位清零（避免负数）。</li><li><code>Snum = (HS[offset] & 0x7f) &lt;&lt; 24 | (HS[offset+1] & 0xff) &lt;&lt; 16 | (HS[offset+2] & 0xff) &lt;&lt; 8 | (HS[offset+3] & 0xff)</code></li></ul></li><li><strong>生成OTP：</strong> 将上一步得到的31位数字<code>Snum</code>对<code>10^D</code>取模，其中<code>D</code>是OTP的位数（通常是6位或8位），然后补足前导零。<ul><li><code>OTP = Snum % (10^D)</code></li></ul></li></ol><h4 id=12-hotp的挑战计数器同步>1.2 HOTP的挑战：计数器同步<a hidden class=anchor aria-hidden=true href=#12-hotp的挑战计数器同步>#</a></h4><p>HOTP的主要挑战在于客户端和服务器的计数器必须严格同步。如果用户在客户端多次生成OTP但没有在服务器端验证（例如，生成了两次但只提交了一次），或者服务器因为某些原因重置了计数器，都可能导致计数器不同步，从而无法通过验证。</p><p>为了解决这个问题，服务器通常会维护一个“窗口”（Look-ahead Window）。当用户提交一个OTP时，服务器不仅检查当前计数器C的OTP，还会检查C+1、C+2&mldr;C+W（W为窗口大小）的OTP。一旦在窗口内找到匹配的OTP，服务器就会将自己的计数器更新到匹配的那个值，以实现“漂移”同步。</p><h4 id=13-hotp-java代码片段示例>1.3 HOTP Java代码片段示例<a hidden class=anchor aria-hidden=true href=#13-hotp-java代码片段示例>#</a></h4><p>下面是一个简化的HOTP实现示例。在实际应用中，通常会使用现有的库。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> javax.crypto.Mac;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> javax.crypto.spec.SecretKeySpec;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.nio.ByteBuffer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.security.InvalidKeyException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.security.NoSuchAlgorithmException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Arrays;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HotpUtil</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String ALGORITHM <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;HmacSHA1&#34;</span>; <span style=color:#75715e>// RFC 4226 推荐使用HMAC-SHA1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 生成HOTP
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param secretKey 共享秘密密钥
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param counter 计数器值
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param digits OTP位数 (通常是6或8)
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @return 生成的OTP字符串
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>generateHOTP</span>(<span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> secretKey, <span style=color:#66d9ef>long</span> counter, <span style=color:#66d9ef>int</span> digits)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throws</span> NoSuchAlgorithmException, InvalidKeyException {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 1. 将计数器转换为8字节的字节数组</span>
</span></span><span style=display:flex><span>        ByteBuffer buffer <span style=color:#f92672>=</span> ByteBuffer.<span style=color:#a6e22e>allocate</span>(8);
</span></span><span style=display:flex><span>        buffer.<span style=color:#a6e22e>putLong</span>(counter);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> counterBytes <span style=color:#f92672>=</span> buffer.<span style=color:#a6e22e>array</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 2. 计算HMAC-SHA1值</span>
</span></span><span style=display:flex><span>        Mac hmac <span style=color:#f92672>=</span> Mac.<span style=color:#a6e22e>getInstance</span>(ALGORITHM);
</span></span><span style=display:flex><span>        SecretKeySpec keySpec <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SecretKeySpec(secretKey, ALGORITHM);
</span></span><span style=display:flex><span>        hmac.<span style=color:#a6e22e>init</span>(keySpec);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> hash <span style=color:#f92672>=</span> hmac.<span style=color:#a6e22e>doFinal</span>(counterBytes);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 3. 动态截取 (Dynamic Truncation)</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 取最后一个字节的低4位作为偏移量</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> offset <span style=color:#f92672>=</span> hash<span style=color:#f92672>[</span>hash.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span> <span style=color:#f92672>&amp;</span> 0xF;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 从偏移量处取4个字节</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> binary <span style=color:#f92672>=</span> ((hash<span style=color:#f92672>[</span>offset<span style=color:#f92672>]</span> <span style=color:#f92672>&amp;</span> 0x7f) <span style=color:#f92672>&lt;&lt;</span> 24) <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>                     ((hash<span style=color:#f92672>[</span>offset <span style=color:#f92672>+</span> 1<span style=color:#f92672>]</span> <span style=color:#f92672>&amp;</span> 0xff) <span style=color:#f92672>&lt;&lt;</span> 16) <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>                     ((hash<span style=color:#f92672>[</span>offset <span style=color:#f92672>+</span> 2<span style=color:#f92672>]</span> <span style=color:#f92672>&amp;</span> 0xff) <span style=color:#f92672>&lt;&lt;</span> 8) <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>                     (hash<span style=color:#f92672>[</span>offset <span style=color:#f92672>+</span> 3<span style=color:#f92672>]</span> <span style=color:#f92672>&amp;</span> 0xff);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 4. 生成OTP (对10^digits取模)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> otp <span style=color:#f92672>=</span> binary <span style=color:#f92672>%</span> (<span style=color:#66d9ef>int</span>) Math.<span style=color:#a6e22e>pow</span>(10, digits);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 格式化为指定位数，不足前面补零</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> String.<span style=color:#a6e22e>format</span>(<span style=color:#e6db74>&#34;%0&#34;</span> <span style=color:#f92672>+</span> digits <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;d&#34;</span>, otp);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 示例：密钥和计数器</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> secret <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;12345678901234567890&#34;</span>.<span style=color:#a6e22e>getBytes</span>(); <span style=color:#75715e>// 示例密钥，实际应是随机且安全的</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> counter <span style=color:#f92672>=</span> 0; <span style=color:#75715e>// 初始计数器</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 5; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            String otp <span style=color:#f92672>=</span> generateHOTP(secret, counter <span style=color:#f92672>+</span> i, 6);
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Counter: &#34;</span> <span style=color:#f92672>+</span> (counter <span style=color:#f92672>+</span> i) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;, OTP: &#34;</span> <span style=color:#f92672>+</span> otp);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 验证示例：服务器端接收到用户提交的OTP </span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 假设用户提交了第一个OTP &#34;755224&#34;</span>
</span></span><span style=display:flex><span>        String userSubmittedOtp <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;755224&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> serverCounter <span style=color:#f92672>=</span> 0; <span style=color:#75715e>// 服务器当前计数器</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> lookAheadWindow <span style=color:#f92672>=</span> 5; <span style=color:#75715e>// 窗口大小</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> verified <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> verifiedCounter <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;=</span> lookAheadWindow; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            String expectedOtp <span style=color:#f92672>=</span> generateHOTP(secret, serverCounter <span style=color:#f92672>+</span> i, 6);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (expectedOtp.<span style=color:#a6e22e>equals</span>(userSubmittedOtp)) {
</span></span><span style=display:flex><span>                verified <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                verifiedCounter <span style=color:#f92672>=</span> serverCounter <span style=color:#f92672>+</span> i;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (verified) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;OTP Verified successfully. Counter updated to: &#34;</span> <span style=color:#f92672>+</span> (verifiedCounter <span style=color:#f92672>+</span> 1));
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 成功验证后，服务器需要更新其计数器到 verifiedCounter + 1</span>
</span></span><span style=display:flex><span>            serverCounter <span style=color:#f92672>=</span> verifiedCounter <span style=color:#f92672>+</span> 1; 
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;OTP Verification failed.&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-totptime-based-one-time-password基于时间的动态密码>2. TOTP（Time-based One-Time Password）：基于时间的动态密码<a hidden class=anchor aria-hidden=true href=#2-totptime-based-one-time-password基于时间的动态密码>#</a></h3><p>TOTP是HOTP的变体，它用基于时间的值（通常是当前时间戳的离散化）代替了递增的计数器，从而消除了计数器同步的复杂性。</p><h4 id=21-totp算法原理>2.1 TOTP算法原理<a hidden class=anchor aria-hidden=true href=#21-totp算法原理>#</a></h4><p>TOTP的核心思想是：客户端和服务器共享一个<strong>秘密密钥K</strong>，并且都依赖于<strong>当前时间</strong>。时间被划分为固定长度的“时间步长”（Time Step，通常为30秒或60秒）。在这个时间步长内，OTP是固定的。</p><p><strong>算法步骤：</strong></p><ol><li><strong>共享秘密密钥 (K)：</strong> 同HOTP，客户端和服务器共享一个秘密密钥。</li><li><strong>时间步长 (X)：</strong> 定义一个时间窗口的长度，例如30秒。</li><li><strong>当前时间戳 (T)：</strong> 获取当前的Unix时间戳（自UTC 1970年1月1日0时0分0秒以来的秒数）。</li><li><strong>计算时间计数器 (TC)：</strong> 将当前时间戳除以时间步长X，得到一个整数值，作为时间计数器。<ul><li><code>TC = floor(Current_Unix_Time / X)</code></li><li>这个<code>TC</code>值在整个时间步长X内是固定的。</li></ul></li><li><strong>HMAC计算和截取：</strong> 接下来，步骤与HOTP完全相同，只是将<code>TC</code>作为HOTP算法中的计数器<code>C</code>：<ul><li><code>OTP = HOTP(K, TC)</code></li><li>即：<code>HS = HMAC-SHA1(K, TC)</code>，然后进行动态截取和取模运算。</li></ul></li></ol><h4 id=22-totp的优势与考虑>2.2 TOTP的优势与考虑<a hidden class=anchor aria-hidden=true href=#22-totp的优势与考虑>#</a></h4><p><strong>优势：</strong></p><ul><li><strong>无需计数器同步：</strong> 这是TOTP最大的优势。只要客户端和服务器的时间大致同步（通常允许几分钟的偏差），就能生成相同的OTP。这大大简化了实现和用户体验。</li><li><strong>更广泛的应用：</strong> 适合移动Authenticator应用，用户无需每次操作后都通知服务器。</li></ul><p><strong>考虑因素：</strong></p><ul><li><strong>时间同步：</strong> 客户端设备和服务器的时间必须相对准确。如果偏差过大（超过一个或两个时间步长），OTP将无法匹配。通常允许+-1个时间步长的偏差进行验证，即服务器会尝试<code>TC-1</code>, <code>TC</code>, <code>TC+1</code>三个值。</li><li><strong>重放攻击：</strong> 虽然OTP是基于时间的，但如果攻击者在OTP有效期内（例如30秒内）截获并重放，仍可能成功。因此，服务器端应确保每个OTP在成功使用一次后即失效。</li></ul><h4 id=23-totp-java代码片段示例>2.3 TOTP Java代码片段示例<a hidden class=anchor aria-hidden=true href=#23-totp-java代码片段示例>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> javax.crypto.Mac;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> javax.crypto.spec.SecretKeySpec;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.nio.ByteBuffer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.security.InvalidKeyException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.security.NoSuchAlgorithmException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Base64; <span style=color:#75715e>// 用于解码Base32密钥</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TotpUtil</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String ALGORITHM <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;HmacSHA1&#34;</span>; <span style=color:#75715e>// RFC 6238 推荐使用HMAC-SHA1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> TIME_STEP <span style=color:#f92672>=</span> 30; <span style=color:#75715e>// 时间步长，通常30秒</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 生成TOTP
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param secretKey 共享秘密密钥 (字节数组)
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param currentTimeMillis 当前时间戳 (毫秒)
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param digits OTP位数 (通常是6或8)
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @return 生成的OTP字符串
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>generateTOTP</span>(<span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> secretKey, <span style=color:#66d9ef>long</span> currentTimeMillis, <span style=color:#66d9ef>int</span> digits)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throws</span> NoSuchAlgorithmException, InvalidKeyException {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 1. 计算时间计数器 TC</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> T <span style=color:#f92672>=</span> currentTimeMillis <span style=color:#f92672>/</span> 1000; <span style=color:#75715e>// 转换为秒</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> TC <span style=color:#f92672>=</span> T <span style=color:#f92672>/</span> TIME_STEP; <span style=color:#75715e>// 获取时间步长对应的整数值</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 2. 调用HOTP逻辑生成OTP</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// HOTPUtil中的generateHOTP方法可以直接复用</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> HotpUtil.<span style=color:#a6e22e>generateHOTP</span>(secretKey, TC, digits);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 将Base32编码的密钥转换为字节数组
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param base32Key Base32编码的密钥字符串
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @return 字节数组密钥
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> <span style=color:#a6e22e>decodeBase32</span>(String base32Key) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Base32 编码通常不包含填充字符&#39;=&#39;，但如果包含，需要处理</span>
</span></span><span style=display:flex><span>        base32Key <span style=color:#f92672>=</span> base32Key.<span style=color:#a6e22e>toUpperCase</span>().<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>&#34; &#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>).<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>&#34;=&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>); <span style=color:#75715e>// 清理空格和填充</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// JDK中没有直接的Base32解码器，通常需要引入第三方库（如Apache Commons Codec），</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这里为了示例简化，假设是一个简单的Base32编码（或手动转换，实际生产不推荐）</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 实际上，RFC 4648 Base32 是有固定字符集的，以下只是一个示意。</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对于真实项目，请使用 org.apache.commons.codec.binary.Base32.decode()</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 或 com.google.zxing.client.result.ParsedResult.decodeBase32() 等库</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这是一个简化的、非标准的Base32解码，仅用于演示概念。</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 实际使用请引入成熟的Base32库。</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// byte[] decoded = Base32.decode(base32Key); // 假设存在这样的标准方法</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 由于JDK原生不支持，这里用一个非常粗略的Base64替代（仅为演示数据流，并非真实的Base32解码）</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 请勿在生产环境使用此方法进行Base32解码！</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Warning: Using non-standard Base32 decoding for demo. Use a proper library like Apache Commons Codec for production.&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Base64.<span style=color:#a6e22e>getDecoder</span>().<span style=color:#a6e22e>decode</span>(base32Key.<span style=color:#a6e22e>getBytes</span>()); <span style=color:#75715e>// 这是一个错误的Base32解码示例，仅为编译通过</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 示例：Google Authenticator的密钥通常以Base32编码</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 假设这是一个通过二维码扫描或手动输入的密钥（通常是20字节的随机数据）</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 注意：Base32密钥通常是16到20个字符，对应10到12.5字节的秘密数据</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// RFC 6238 推荐至少128位（16字节）的秘密密钥</span>
</span></span><span style=display:flex><span>        String base32EncodedSecret <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;JBSWY3DPEHPK3PXP&#34;</span>; <span style=color:#75715e>// 对应secretKey.getBytes() if it&#39;s 10 bytes</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// For a real 16-byte secret, example: Base32.encode(new byte[16]) -&gt; &#34;GEZDGNBVGYQTCMZXGEZDGNBVGYQTCMZX&#34;</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 在真实项目中，应该使用一个标准的Base32解码库，例如：</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// byte[] secret = new Base32().decode(base32EncodedSecret);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这里为了示例能运行，我们直接使用一个固定的字节数组作为secret，因为它与上述generateHOTP的secretKey参数类型一致</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> secret <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;abcdefghijklmnop&#34;</span>.<span style=color:#a6e22e>getBytes</span>(); <span style=color:#75715e>// 16字节的示例密钥，确保长度足够</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;---- TOTP Generation ----&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 服务器端生成并验证OTP</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> currentUnixTime <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();
</span></span><span style=display:flex><span>        String otp <span style=color:#f92672>=</span> generateTOTP(secret, currentUnixTime, 6);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Current Time: &#34;</span> <span style=color:#f92672>+</span> currentUnixTime <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;, Generated OTP: &#34;</span> <span style=color:#f92672>+</span> otp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 模拟客户端在几秒后提交OTP</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> clientSubmitTime <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>() <span style=color:#f92672>+</span> 5 <span style=color:#f92672>*</span> 1000; <span style=color:#75715e>// 5秒后提交</span>
</span></span><span style=display:flex><span>        String clientOtp <span style=color:#f92672>=</span> generateTOTP(secret, clientSubmitTime, 6); <span style=color:#75715e>// 客户端生成的OTP</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Client Time (5s later): &#34;</span> <span style=color:#f92672>+</span> clientSubmitTime <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;, Client Generated OTP: &#34;</span> <span style=color:#f92672>+</span> clientOtp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 服务器端验证：通常会检查当前时间步长及其前后一个步长的OTP</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;\n---- TOTP Verification ----&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> verified <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> serverTime <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>(); <span style=color:#75715e>// 服务器当前时间</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> timeWindowTolerance <span style=color:#f92672>=</span> 1; <span style=color:#75715e>// 允许前后一个时间步长的偏差</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>timeWindowTolerance; i <span style=color:#f92672>&lt;=</span> timeWindowTolerance; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>long</span> targetTime <span style=color:#f92672>=</span> serverTime <span style=color:#f92672>+</span> (<span style=color:#66d9ef>long</span>)i <span style=color:#f92672>*</span> TIME_STEP <span style=color:#f92672>*</span> 1000; <span style=color:#75715e>// 计算目标时间</span>
</span></span><span style=display:flex><span>            String expectedOtp <span style=color:#f92672>=</span> generateTOTP(secret, targetTime, 6);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (expectedOtp.<span style=color:#a6e22e>equals</span>(clientOtp)) {
</span></span><span style=display:flex><span>                verified <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Verification successful for time offset: &#34;</span> <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (verified) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;TOTP Verified successfully.&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;TOTP Verification failed.&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>重要提示：</strong> 上述 <code>decodeBase32</code> 方法仅为示例代码的编译通过而提供了一个<strong>错误且不安全</strong>的实现（使用了Base64代替）。在生产环境中，<strong>请务必使用成熟的第三方Base32解码库</strong>，例如 Apache Commons Codec 库中的 <code>org.apache.commons.codec.binary.Base32</code>。</p><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><p>TOTP和HOTP算法虽然复杂，但其核心思想都离不开共享秘密密钥和动态变化的输入（计数器或时间戳），并通过加密哈希函数（HMAC-SHA1）来生成不可预测的一次性密码。</p><ul><li><strong>HOTP</strong> 依赖于严格的<strong>计数器同步</strong>，适用于物理令牌等场景，但需要考虑同步漂移问题。</li><li><strong>TOTP</strong> 则通过引入<strong>时间因素</strong>，大大简化了同步的复杂性，成为目前最主流的基于软件的一次性密码解决方案（如Google Authenticator）。</li></ul><p>理解这些算法的底层工作原理，有助于我们更好地设计和集成MFA功能到IAM系统中，并对其安全性有更深刻的认识。在实际开发中，强烈建议使用经过充分测试和审计的第三方安全库来处理OTP的生成和验证，避免自己实现可能引入的漏洞。下一篇我们将探讨FIDO与WebAuthn技术。</p><h3></h3><p><strong>欢迎关注+点赞+推荐+转发</strong></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bsong2015.github.io/blog/>万年水的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>