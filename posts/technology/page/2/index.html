<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>技术实践 | 万年水的博客</title><meta name=keywords content><meta name=description content="编程与系统开发笔记"><meta name=author content><link rel=canonical href=https://bsong2015.github.io/blog/posts/technology/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://bsong2015.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bsong2015.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bsong2015.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://bsong2015.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://bsong2015.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://bsong2015.github.io/blog/posts/technology/index.xml><link rel=alternate hreflang=zh href=https://bsong2015.github.io/blog/posts/technology/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://bsong2015.github.io/blog/posts/technology/"><meta property="og:site_name" content="万年水的博客"><meta property="og:title" content="技术实践"><meta property="og:description" content="编程与系统开发笔记"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="技术实践"><meta name=twitter:description content="编程与系统开发笔记"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bsong2015.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"技术实践","item":"https://bsong2015.github.io/blog/posts/technology/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bsong2015.github.io/blog/ accesskey=h title="万年水的博客 (Alt + H)">万年水的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bsong2015.github.io/blog/posts/artificial-intelligence/ title=人工智能><span>人工智能</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/reading/ title=阅读><span>阅读</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/thinking-models/ title=思维模型><span>思维模型</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/thought-experiments/ title=思想实验><span>思想实验</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/personal-growth/ title=个人成长><span>个人成长</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/technology/ title=技术><span class=active>技术</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/current-affairs/ title=时事><span>时事</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/others/ title=其它><span>其它</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>技术实践</h1><div class=post-description>编程与系统开发笔记</div></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>第1篇：【开篇】为什么我们需要身份与访问管理（IAM）？ 在数字化浪潮席卷全球的今天，企业正在以前所未有的速度拥抱云计算、大数据、移动化和人工智能。这些技术带来了巨大的效率提升和业务创新，但也随之带来了前所未有的安全挑战。其中，对“身份”的管理和“访问”的控制，无疑是所有安全基石中的重中之重。正是在这样的背景下，身份与访问管理（Identity and Access Management，简称IAM）应运而生，并迅速成为现代企业安全战略不可或缺的核心组成部分。
那么，究竟什么是IAM？它为何如此重要？它解决了哪些核心问题，又为企业带来了哪些实实在在的价值呢？
1. IAM的定义：数字世界的“门卫”与“钥匙管理员” 简单来说，身份与访问管理（IAM）是一套策略、流程和技术体系，旨在确保正确的人在正确的时间、以正确的方式访问正确的资源。 它管理着数字身份的整个生命周期，从创建、维护、更新到最终的废弃，并基于这些身份来授权或拒绝其对各种系统、应用和数据的访问请求。
可以把IAM想象成一个大型组织中的“门卫”和“钥匙管理员”。
“门卫” 负责识别每一个试图进入的人（身份验证），并判断他们是否有资格进入特定区域（授权）。 “钥匙管理员” 则负责管理所有员工的“钥匙”（权限），确保他们只持有开启其工作所需房间的钥匙，并在员工离职或岗位变动时，及时收回或更换钥匙。 在数字化世界中，这个“人”可以是员工、客户、合作伙伴，甚至是机器用户（如微服务、IoT设备）。而“资源”则包括了企业内部的应用系统、数据库、文件服务器、云服务、API接口等一切有价值的信息资产。
2. IAM的重要性：安全与效率的基石 IAM的重要性可以从多个维度来理解：
2.1 应对日益严峻的网络安全威胁 每一次数据泄露事件的背后，往往都与身份认证和访问控制的薄弱环节紧密相关。弱密码、被盗凭证、权限滥用、内部人员恶意行为、未授权访问等，是导致企业遭受损失的常见攻击途径。IAM通过强制执行强认证机制（如多因素认证MFA）、精细化授权策略（如最小权限原则）和持续的访问监控，显著提升了企业的整体安全态士，有效抵御了各类基于身份的攻击。
2.2 满足合规性要求 GDPR、HIPAA、SOX、PCI DSS等日益严格的国内外法规对企业的数据保护和访问控制提出了明确要求。IAM系统能够帮助企业建立健全的访问审计记录，证明其对用户身份和数据访问的有效管理和控制，从而满足各项监管和合规性要求，避免巨额罚款和声誉损失。
2.3 提升运营效率与用户体验 在没有IAM系统的情况下，每个应用可能都需要单独管理用户账户和权限，这导致了大量的重复工作、用户体验碎片化（需要记住多个账户和密码）和高昂的运维成本。IAM通过实现单点登录（Single Sign-On, SSO）、统一用户管理和自动化流程，大大简化了用户访问和IT管理的复杂性，提升了员工和客户的使用体验。
2.4 支撑数字化转型与业务创新 随着企业业务向云端迁移，引入SaaS应用，构建微服务架构，传统的边界安全模式不再适用。IAM成为了零信任（Zero Trust）安全模型的核心支柱，它假设所有内外部访问都是不可信的，每次访问都需要验证身份和权限。这使得企业能够更安全地开放API、接入合作伙伴、扩展业务边界，加速数字化转型进程。
3. IAM解决的核心问题 IAM主要解决了以下几个核心问题：
3.1 身份管理（Identity Management） 唯一身份标识： 确保每个用户在系统中拥有唯一且可识别的数字身份。 身份生命周期管理： 自动化用户账户的创建、修改、禁用和删除流程，尤其在员工入职、转岗、离职时，确保权限的及时生效或撤销。 身份同步与集成： 将用户身份数据从各种来源（如企业目录LDAP/AD、HR系统）同步到统一的IAM平台，并分发给下游应用。 身份治理与审计： 确保身份信息的准确性、完整性，并提供详细的审计日志，记录谁在何时访问了什么资源。 3.2 认证管理（Authentication Management） 用户身份验证： 验证用户声称的身份是否真实，即“你是谁？”。 支持多种认证方式： 从传统的密码认证，到多因素认证（MFA，如OTP、指纹、人脸识别）、生物识别、数字证书、社交媒体登录等。 单点登录（SSO）： 用户一次登录即可访问所有授权的应用，无需重复输入凭证。 3.3 授权管理（Authorization Management） 访问权限控制： 决定用户可以访问哪些资源，以及可以对这些资源执行何种操作，即“你可以做什么？”。 精细化授权： 从传统的角色-权限（Role-Based Access Control, RBAC）到属性-权限（Attribute-Based Access Control, ABAC）、基于策略的访问控制（Policy-Based Access Control, PBAC），实现更灵活、更细粒度的权限管理。 权限审批与工作流： 对于敏感资源的访问，可能需要经过多级审批流程。 3.4 审计与合规（Audit & Compliance） 日志记录： 详细记录所有与身份、认证、授权相关的操作，包括登录尝试、访问请求、权限变更等。 安全报告： 提供可查询、可分析的审计日志，帮助安全团队发现异常行为，满足合规性审计要求。 风险评估： 通过分析审计数据，识别潜在的安全风险和漏洞。 此处建议插入一个IAM核心概念示意图，展示身份、认证、授权、审计这几个核心组件及其关系，以及IAM作为中心枢纽连接用户和各类资源。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC1%E7%AF%87%E5%BC%80%E7%AF%87%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E8%BA%AB%E4%BB%BD%E4%B8%8E%E8%AE%BF%E9%97%AE%E7%AE%A1%E7%90%86iam/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>第2篇：云时代的身份变革：IDaaS是什么，它与传统IAM有何不同？ 在上一篇文章中，我们深入理解了身份与访问管理（IAM）的必要性和核心价值。然而，随着企业IT架构从传统的本地数据中心向云计算环境加速迁移，IAM自身也在经历一场深刻的变革。这场变革的核心产物，就是身份即服务（Identity as a Service，简称IDaaS）。
IDaaS不仅是IAM的一种部署和交付模式的转变，更是其核心理念、架构设计和运营模式的升级。本篇文章将详细阐述IDaaS的定义、核心特性，它为企业带来的独特优势，并将其与传统的本地部署IAM进行对比，帮助读者清晰理解云时代身份管理的新范式。
1. IDaaS的定义：云端的身份管理中枢 身份即服务（IDaaS）是一种基于云计算的服务模式，它将身份和访问管理的全部或部分功能作为订阅服务，通过互联网提供给企业和个人。 简单来说，IDaaS将原本需要企业在内部自建、部署、维护的IAM基础设施，转变为由第三方服务提供商负责构建、运营和维护的云端服务。
企业不再需要购买昂贵的硬件、软件许可证，也无需组建专业的运维团队来管理复杂的IAM系统。取而代之的是，通过按需订阅的方式，即可享受到安全、可伸缩、高可用的身份管理服务。IDaaS就好比将企业的“门卫”和“钥匙管理员”外包给了专业的安保公司，由他们负责所有身份认证、授权和生命周期的管理，企业只需专注于自身核心业务。
2. IDaaS的核心特性 IDaaS之所以能够成为云时代的身份管理主流，得益于其区别于传统IAM的几个显著核心特性：
2.1 多租户架构（Multi-Tenancy） 这是云服务最典型的特征之一。一个IDaaS平台同时为多个客户（租户）提供服务，每个租户的数据和配置彼此隔离，互不影响。这种架构使得服务提供商能够通过共享基础设施和软件实例来大幅降低成本，并将这些成本优势传递给客户。对于企业而言，这意味着无需独占资源，即可享受到专业级的服务。
2.2 API优先（API-First）与集成能力 现代IDaaS平台普遍采用API优先的设计理念。这意味着其所有核心功能，从用户管理、认证、授权到审计，都通过标准化的RESTful API对外暴露。这种设计极大地简化了IDaaS与企业现有应用、SaaS应用、移动应用乃至IoT设备的集成，实现了无缝的身份同步和访问控制。强大的集成能力是IDaaS实现统一身份体验的关键。
2.3 高可用性与可伸缩性（High Availability & Scalability） IDaaS服务提供商通常在全球多个数据中心部署其服务，并通过负载均衡、故障转移等技术确保服务的高可用性，即便单一区域发生故障，服务也能持续运行。同时，由于基于云基础设施，IDaaS能够根据客户需求动态扩展计算和存储资源，轻松应对用户量激增或峰值访问的挑战，而无需客户进行额外的容量规划。
2.4 持续更新与维护（Continuous Updates & Maintenance） IDaaS服务提供商负责系统的所有底层维护、安全补丁更新、功能升级和漏洞修复。客户无需担心软件版本过时或安全漏洞，可以持续享受到最新的安全特性和功能改进。这大大减轻了企业IT团队的运维负担，使其能够更专注于业务价值创造。
2.5 快速部署与易用性（Rapid Deployment & Ease of Use） 相比于传统IAM系统漫长复杂的部署周期，IDaaS通常提供基于Web的管理界面和详尽的文档，允许企业快速配置和上线。许多IDaaS产品提供了预构建的连接器和模板，进一步简化了与常用应用（如Salesforce, Office 365等）的集成过程。
3. IDaaS的优势 基于上述核心特性，IDaaS为企业带来了显著的优势：
降低成本： 避免了硬件采购、软件许可、部署实施和日常运维的巨大前期投入和长期成本。转变为可预测的运营支出（OpEx）模式。 提升安全性： 专业的IDaaS厂商拥有顶尖的安全专家团队、先进的安全技术和持续的安全监控，其安全防护能力通常远超单一企业内部能力。 简化IT管理： 将复杂的身份基础设施管理外包，释放IT团队资源，使其专注于核心业务和创新。 加速业务创新： 快速集成新应用、扩展用户规模，为企业尝试新业务模式提供灵活、安全的身份支撑。 增强用户体验： 通过SSO、统一身份等功能，为员工和客户提供更流畅、便捷的访问体验。 满足合规性： IDaaS厂商通常具备多项国际安全和合规认证，帮助企业更容易满足合规要求。 4. IDaaS与传统本地部署IAM的对比 为了更直观地理解IDaaS的价值，我们将其与传统的本地部署IAM在多个维度进行对比：
特征 传统本地部署IAM IDaaS（身份即服务） 部署模式 企业内部数据中心部署，需要购买服务器、软件、许可证 云端订阅服务，通过互联网访问 成本模式 高昂的前期资本支出（CapEx），加上运营支出 低前期投入，按需订阅的运营支出（OpEx） 维护责任 企业IT团队负责所有硬件、软件、补丁、升级、高可用 IDaaS服务提供商负责所有底层基础设施、软件维护、安全更新、高可用 可伸缩性 受限于本地基础设施，扩展困难且成本高昂 弹性伸缩，按需扩展，轻松应对峰值或业务增长 可用性 取决于企业内部基础设施的韧性与运维水平 通常由服务提供商提供SLA保障，多区域高可用部署 集成能力 需要定制开发或复杂配置，集成难度较大 API优先设计，提供大量预置连接器，集成更便捷 功能更新 周期长，依赖于企业内部规划和资源投入 持续更新，自动获取最新功能和安全增强 安全性 取决于企业自身的安全实践和投入 专业的安全团队和先进技术，通常更安全可靠 合规性 企业自行承担合规责任 IDaaS厂商提供多项合规认证，辅助企业满足合规要求 适用场景 对数据主权有极高要求、无法接受云服务的企业 绝大多数企业，尤其是采用SaaS应用、云计算策略的企业 总结 IDaaS是云计算时代身份管理演进的必然趋势，它将复杂的IAM能力转化为一种便捷、安全、经济高效的云服务。通过多租户、API优先、高可用等核心特性，IDaaS显著降低了企业在身份管理方面的投入，提升了安全态势，并加速了企业的数字化转型进程。对于绝大多数现代企业而言，选择IDaaS而非传统本地部署IAM，已成为更具战略意义和经济效益的决策。在接下来的文章中，我们将开始深入探讨IAM/IDaaS背后的具体技术和协议，为后续的Java实践打下坚实的基础。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC2%E7%AF%87%E4%BA%91%E6%97%B6%E4%BB%A3%E7%9A%84%E8%BA%AB%E4%BB%BD%E5%8F%98%E9%9D%A9idaas%E6%98%AF%E4%BB%80%E4%B9%88%E5%AE%83%E4%B8%8E%E4%BC%A0%E7%BB%9Fiam%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>第3篇：IAM的基石：认证、授权、账户、审计（4A/5A）详解 在前面的文章中，我们了解了IAM的宏观定义、重要性以及IDaaS的云端优势。现在，是时候深入IAM系统的内部，剖析其最核心的功能模块了。无论是一个庞大的企业级IAM系统，还是一个轻量级的Web应用身份模块，它们的功能都离不开几个基本的核心要素，这些要素常被概括为“4A”或“5A”框架，即：认证（Authentication）、授权（Authorization）、账户管理（Account Management/Administration）和审计（Auditing/Accountability）。有时会额外加入应用管理（Application Management），构成“5A”。
理解这几个“A”的含义、目标及其在IAM系统中的作用，是掌握IAM原理的基石。
1. 认证（Authentication）：“你是谁？”——身份的验证 含义： 认证是验证用户（或实体）声称的身份是否真实的过程。它回答了“你是谁？”这个问题。在数字世界中，用户通过提供凭证来证明自己的身份，系统则通过预设的机制来核实这些凭证的有效性。
目标： 确保只有合法的用户才能登录系统，防止未经授权的访问。
在IAM系统中的作用：
凭证管理： 存储和管理用户的各种凭证，如密码哈希、证书、密钥、生物特征模板等。 认证协议支持： 支持多种认证协议和标准，例如用户名/密码、LDAP/AD、SAML、OAuth 2.0/OpenID Connect、Kerberos、X.509证书、RADIUS等。 多因素认证（MFA）： 提供多种MFA机制集成，如短信OTP、Authenticator应用、指纹、人脸识别、U盾/FIDO密钥等，显著提升认证强度。 会话管理： 成功认证后，创建和管理用户的会话（Session），用于后续的访问请求，避免每次请求都重复认证。 风险感知认证（Adaptive Authentication）： 根据用户的设备、地理位置、行为模式等上下文信息，动态评估风险并调整认证强度（例如，在异常地点登录时要求MFA）。 示例： 用户在登录页输入用户名和密码，系统后台将密码哈希与存储的哈希值比对，若匹配，则认证成功。若配置了MFA，还需输入短信验证码或通过指纹验证。
2. 授权（Authorization）：“你能做什么？”——权限的授予与控制 含义： 授权是决定已认证的用户（或实体）可以访问哪些资源以及可以对这些资源执行何种操作的过程。它回答了“你能做什么？”或“你有什么权限？”的问题。
目标： 确保用户只能访问其被允许的资源，并只能执行其被授予的操作，实现最小权限原则（Principle of Least Privilege）。
在IAM系统中的作用：
权限模型： 支持不同的权限控制模型： 基于角色的访问控制（RBAC - Role-Based Access Control）： 将权限分配给角色，然后将用户分配给角色。这是最常用且易于管理的模型。 基于属性的访问控制（ABAC - Attribute-Based Access Control）： 基于用户、资源、环境等属性动态评估访问请求。提供更细粒度和灵活的权限控制。 基于策略的访问控制（PBAC - Policy-Based Access Control）： 通过定义一系列策略规则来决定访问决策，通常与ABAC结合使用。 基于资源的访问控制（ReBAC - Relationship-Based Access Control）： 基于实体之间的关系来定义权限，例如“张三可以访问他创建的所有文档”。 策略执行点（Policy Enforcement Point, PEP）： 在用户尝试访问资源时，拦截请求并调用策略决策点（Policy Decision Point, PDP）进行权限判断。 集中式授权管理： 提供统一的界面和API来定义、分配和管理所有应用的权限，避免权限分散管理带来的混乱和风险。 动态授权： 能够根据实时上下文信息（如时间、位置、设备状态）动态调整用户的访问权限。 示例： 认证成功后，系统判断该用户属于“部门经理”角色。根据RBAC策略，“部门经理”角色有权查看本部门所有员工的绩效报告，但无权修改。用户尝试修改时，授权系统会拒绝此操作。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC3%E7%AF%87iam%E7%9A%84%E5%9F%BA%E7%9F%B3%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E8%B4%A6%E6%88%B7%E5%AE%A1%E8%AE%A14a5a%E8%AF%A6%E8%A7%A3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>第4篇：账户的“一生”：身份生命周期管理（ILM）概览 在上一篇文章中，我们详细探讨了IAM的四大基石：认证、授权、账户管理和审计。其中，“账户管理”是确保用户身份信息准确和权限及时性的关键。然而，一个数字身份并非一成不变，它从诞生到消亡，会经历一个完整的生命周期。高效、安全地管理这个生命周期，正是 身份生命周期管理（Identity Lifecycle Management, ILM） 的核心任务。
ILM旨在自动化和简化用户身份及其相关权限的创建、维护、变更和删除过程，确保“正确的人”始终拥有“正确的权限”。这不仅是安全性的要求，更是企业效率和合规性的体现。
1. 什么是身份生命周期管理（ILM）？ 身份生命周期管理（ILM） 是一套系统化的流程和技术，用于管理数字身份从创建到废弃的整个过程。它关注用户在组织中状态的变化，并根据这些变化自动调整其在各类系统中的账户和权限。ILM的目标是：
提升效率： 自动化账户和权限的管理，减少人工操作，降低IT管理成本和人为错误。 增强安全性： 确保用户权限在角色变动或离职时得到及时更新或撤销，堵塞安全漏洞。 满足合规性： 提供清晰的审计追踪，证明企业对用户身份和访问权限进行了有效管理，符合法规要求。 2. Joiner-Mover-Leaver (JML) 流程：身份生命周期的核心场景 ILM最典型的应用场景体现在员工（或任何身份主体）在组织中的三大状态变化：入职（Joiner）、转岗（Mover）和离职（Leaver）。这被称为 JML流程。
2.1 Joiner：新员工入职 当一名新员工加入公司时，他们需要访问一系列系统和资源才能开始工作。
场景： 员工A入职销售部门，担任销售经理。 ILM流程： 触发： HR系统录入新员工信息，并将其设置为“已入职”状态。 身份创建： ILM系统接收HR系统触发的事件，自动在企业目录（如LDAP/AD）和所有相关业务系统（如邮箱系统、CRM、ERP、协作平台等）中创建员工A的账户。 初始权限分配： 根据员工A的部门和职位（销售部门、销售经理），ILM系统自动为其分配预定义的初始角色和权限集合（例如，销售部VPN访问权限、CRM系统销售角色、共享文件服务器销售文件夹读写权限、公司邮箱和日历访问权限等）。 通知： 自动向员工发送欢迎邮件，包含账户信息和首次登录指引。 目标： 确保新员工能够快速获得工作所需的最小权限，并立即投入工作，提高入职效率。 2.2 Mover：员工转岗或角色变更 当员工在公司内部调动部门、升职或工作职责发生变化时，其所需的访问权限也应随之调整。
场景： 员工A从销售经理转岗至市场部门，担任市场总监。 ILM流程： 触发： HR系统更新员工A的部门和职位信息。 权限回收： ILM系统识别到转岗事件，自动撤销员工A原销售经理的权限（例如，撤销对销售CRM的写入权限、移除销售部门的邮件列表）。 新权限分配： 根据新的部门和职位（市场部门、市场总监），ILM系统自动为其分配新的角色和权限（例如，市场部VPN访问权限、市场营销工具访问权限、共享文件服务器市场文件夹访问权限等）。 通知： 通知相关系统和员工权限已更新。 目标： 确保员工在新的岗位上拥有正确的权限，并及时移除不再需要的权限，防止权限蔓延和滥用，同时保障业务连续性。 2.3 Leaver：员工离职 当员工离开公司时，必须立即撤销其所有系统访问权限，以防止数据泄露或恶意行为。
场景： 员工A正式离职。 ILM流程： 触发： HR系统将员工A的状态更新为“已离职”。 账户禁用/删除： ILM系统接收离职事件，立即禁用员工A在所有相关系统中的账户。在经过一定保留期后，按策略彻底删除账户。 权限回收： 自动撤销员工A在所有系统中的所有访问权限。 数据归档/转移： 如果需要，触发相关流程进行数据归档或将数据所有权转移给其他员工。 目标： 及时、彻底地回收所有权限，消除安全风险，满足合规性要求。 3. 身份供给（Provisioning）与身份回收（De-provisioning） JML流程的背后，是ILM中两个核心技术概念：身份供给和身份回收。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC4%E7%AF%87%E8%B4%A6%E6%88%B7%E7%9A%84%E4%B8%80%E7%94%9F%E8%BA%AB%E4%BB%BD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86ilm%E6%A6%82%E8%A7%88/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>第5篇：密码≠安全：现代密码存储与防护策略 在数字世界中，密码（Password）无疑是最普遍、最直观的身份认证方式。我们每天都在使用它们登录各种网站、应用和系统。然而，仅仅依靠密码来保障安全是远远不够的，甚至可以说，“密码”本身并不等同于“安全”。一旦密码被泄露或破解，攻击者便能轻而易举地冒充用户，造成无法估量的损失。
本篇文章将深入探讨现代密码的存储和防护策略，揭示为什么简单的密码已经无法满足安全需求，以及如何通过哈希、加盐、Pepper、慢哈希算法和严格的密码策略来构建更坚固的密码防线。
1. 为什么“密码≠安全”？——传统密码存储的缺陷 传统的密码存储方式简单粗暴，通常是将用户提交的密码明文存储在数据库中，或者使用一些弱加密算法进行保护。这种方式存在致命缺陷：
明文存储： 数据库一旦泄露，所有用户密码一览无余。 弱加密/可逆加密： 即使进行了“加密”，如果使用对称加密且密钥被泄露，或使用可逆哈希（如MD5、SHA1早期用途），攻击者也能轻易解密或反算出原始密码。 攻击者如何利用这些缺陷？
拖库攻击： 攻击者获取到数据库后，直接拿到大量明文密码。 彩虹表攻击： 针对已知明文-哈希对预先计算好的“彩虹表”，通过反查哈希值迅速找到对应明文密码。对于弱哈希算法，这种攻击效率极高。 为了应对这些挑战，现代密码存储和防护策略应运而生，其核心原则是：永远不要存储用户密码的明文！ 而是存储密码的哈希值。
2. 密码哈希（Hashing）：不可逆的指纹 含义： 密码哈希是将原始密码（明文）通过一个单向的数学函数（哈希算法）转换成一个固定长度的、看似随机的字符串（哈希值）。这个过程是“单向”的，意味着从哈希值几乎不可能逆向推导出原始密码。
工作原理：
用户设置密码 P。 系统计算 H = Hash(P)。 系统将 H 存储到数据库。 用户登录时，提交密码 P'。 系统计算 H' = Hash(P')。 比对 H 和 H' 是否相同。若相同，则认证成功。 常见哈希算法（早期用于密码存储，但现在不推荐单独使用）： MD5, SHA-1, SHA-256, SHA-512。
为什么单独哈希不足以安全？ 虽然哈希是单向的，但如果用户密码简单且哈希算法速度快，攻击者仍然可以通过以下方式破解：
字典攻击： 使用常见单词、短语、数字组合等构成的“字典”，逐一哈希后与泄露的哈希值比对。 彩虹表攻击： 对大量常见密码预先计算哈希值，制作成巨大的查找表。一旦数据库泄露，攻击者可以直接查表找到密码。 3. 加盐（Salting）：为每个密码定制“指纹” 为了对抗字典攻击和彩虹表攻击，加盐（Salting） 技术应运而生。
含义： “盐”（Salt）是一个随机生成的数据串。在哈希密码之前，将这个随机的“盐”与用户密码进行拼接，然后再进行哈希。
工作原理：
用户设置密码 P。 系统为该用户生成一个唯一且随机的 Salt 值。 系统计算 H = Hash(P + Salt)。 系统将 H 和 Salt 一同存储到数据库。请注意，Salt 是不需要保密的，它与哈希值一起公开存储。 用户登录时，提交密码 P'。 系统从数据库取出对应用户的 Salt 值。 系统计算 H' = Hash(P' + Salt)。 比对 H 和 H' 是否相同。 加盐的优势：
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC5%E7%AF%87%E5%AF%86%E7%A0%81%E5%AE%89%E5%85%A8%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%98%E5%82%A8%E4%B8%8E%E9%98%B2%E6%8A%A4%E7%AD%96%E7%95%A5/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>好的，我们将继续《身份认证（Authentication）深度探索》模块，本篇聚焦于为账户加上“安全锁”的关键技术——多因素认证（MFA）。
第6篇：多因素认证（MFA）：为你的账户加上“安全锁” 在上一篇文章中，我们详细探讨了如何通过哈希、加盐、慢哈希算法和密码策略来强化密码的存储与防护。然而，即使密码再复杂，存储再安全，仍无法抵御所有攻击，例如钓鱼攻击、中间人攻击、或用户不小心泄露密码等情况。当单一认证因素（如密码）被攻破时，攻击者便能长驱直入。
为了应对这些挑战，多因素认证（Multi-Factor Authentication，简称MFA） 应运而生，并已成为现代身份安全领域不可或缺的“安全锁”。它通过要求用户提供多种不同类型的认证凭证，极大地提升了账户的安全性。
1. MFA的原理：不止一个“你所知道的” MFA的定义： 多因素认证是一种安全机制，它要求用户提供至少两种不同类别的独立认证凭证才能获得访问权限。这比传统的单一因素认证（如仅凭密码）更为安全。
认证因素的三个基本类别：
你所知道的（Something You Know）： 这是最常见的因素，通常是密码（Password）、PIN码或安全问题的答案。 你所拥有的（Something You Have）： 这指的是用户物理上持有的物品，如手机（接收短信验证码、推送通知）、硬件令牌（如U盾、FIDO密钥）、智能卡或一次性密码（OTP）生成器。 你所是的（Something You Are）： 这指的是用户独特的生物学特征，如指纹、面部识别、虹膜扫描或声纹。 MFA的原理核心在于“不同类别”： 仅仅要求用户输入两次密码（两次“你所知道的”）不能算是MFA。只有当认证过程同时验证了至少两个不同类别的因素时，才能称之为多因素认证。例如，用户输入密码（你所知道的）后，还需要输入手机收到的短信验证码（你所拥有的），这就构成了MFA。
工作流程示例：
用户在登录界面输入用户名和密码（第一因素：你所知道的）。 系统验证密码的正确性。 如果密码正确，系统会提示用户提供第二个认证因素（例如，要求输入手机上Authenticator应用生成的一次性密码）。 用户输入第二个因素。 系统验证第二个因素的正确性。 如果两个因素都正确，用户成功登录。 2. MFA的重要性：账户安全的最后一道防线 MFA的重要性体现在以下几个方面：
抵御凭证盗用： 即使攻击者通过钓鱼、键盘记录器或数据泄露等方式窃取了用户的密码，如果他们无法获得第二个认证因素（如手机），也无法登录账户。这是MFA最核心的价值。 对抗暴力破解和字典攻击： 密码再强也可能被猜解，而MFA增加了额外的复杂度，使得这些攻击更难成功。 应对内部威胁： 即使内部人员获取了账户密码，MFA也能阻止其进行未经授权的操作，除非他们同时能控制第二个因素。 满足合规性要求： 许多行业标准和法规（如PCI DSS、GDPR、HIPAA）都推荐或强制要求使用MFA来保护敏感数据和系统。 提升用户信心： 用户知道自己的账户受到MFA的保护，会更有安全感。 3. 常见的MFA因素类型 MFA结合了多种技术，以下是一些最常见的MFA因素类型：
3.1 一次性密码（One-Time Password, OTP） OTP是最广泛使用的MFA形式之一，其特点是每次生成的密码只能使用一次，并且通常在短时间内失效。
短信/邮件OTP： 系统将OTP通过短信发送到用户注册的手机号码，或通过邮件发送到注册邮箱。 优点： 普及率高，用户无需额外设备。 缺点： 存在短信劫持（SIM卡欺诈）、邮件钓鱼等风险；短信发送延迟。 基于时间的一次性密码（TOTP）： 通过Authenticator应用（如Google Authenticator, Microsoft Authenticator, Authy）在用户的设备上生成。这些OTP是基于时间和共享密钥算法生成的，每30秒或60秒刷新一次。 优点： 不需要网络连接，安全性高于短信OTP，抵抗SIM卡劫持。 缺点： 如果设备丢失或同步时间不准可能导致问题。 基于HMAC的一次性密码（HOTP）： 基于HMAC和计数器生成的OTP，每次使用后计数器递增。 优点： 不依赖时间同步。 缺点： 需要客户端和服务器维护相同的计数器，同步可能出现问题。 3.2 推送通知（Push Notification） 当用户尝试登录时，系统向其注册的移动设备发送一个推送通知。用户只需点击“批准”或“拒绝”即可完成认证。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC6%E7%AF%87%E5%A4%9A%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81mfa%E4%B8%BA%E4%BD%A0%E7%9A%84%E8%B4%A6%E6%88%B7%E5%8A%A0%E4%B8%8A%E5%AE%89%E5%85%A8%E9%94%81/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>第7篇：MFA实战：TOTP与HOTP算法是如何工作的？ 在上一篇中，我们概览了多因素认证（MFA）的重要性及常见类型。其中，一次性密码（OTP）因其便捷性和较高的安全性而成为MFA的基石。而OTP家族中，基于时间的一次性密码（TOTP） 和基于HMAC的一次性密码（HOTP） 是应用最广泛的两种算法。
你可能已经在Google Authenticator、Microsoft Authenticator等应用中体验过TOTP，或者在一些物理令牌上见过HOTP。那么，这些看似随机却又能被服务器正确验证的6位或8位数字是如何生成的呢？本篇文章将深入揭示TOTP和HOTP的算法原理，并结合Java代码片段进行说明。
1. HOTP（HMAC-based One-Time Password）：基于HMAC的计数器同步 HOTP是OTP的基础，它通过一个秘密密钥和一个递增的计数器来生成一次性密码。
1.1 HOTP算法原理 HOTP的核心思想是：客户端和服务器共享一个秘密密钥（Shared Secret Key）K和一个计数器（Counter）C。每次生成OTP时，计数器C递增1，然后将K和C作为输入，通过一个加密哈希函数（通常是HMAC-SHA1）来生成一个哈希值，最后从这个哈希值中提取出固定位数的数字作为OTP。
算法步骤：
共享秘密密钥 (K)： 客户端（如Authenticator应用）和服务器预先协商并存储一个只有双方知道的秘密密钥。这个密钥通常以Base32编码形式展示给用户，用于在Authenticator应用中进行扫描或手动输入。 计数器 (C)： 客户端和服务器都维护一个独立的计数器，初始值通常为0或1。每次生成或验证OTP时，计数器都会递增。 计算HMAC值： 使用HMAC-SHA1算法，以共享秘密密钥K作为HMAC的密钥，以计数器C的字节表示作为HMAC的消息。 HS = HMAC-SHA1(K, C) 这里需要注意，计数器C是一个64位的整数，需要将其转换为字节数组。 动态截取（Dynamic Truncation）： 从HMAC-SHA1生成的20字节（160位）哈希值HS中，提取出一个31位（非符号位）的数字。这个过程是为了从二进制哈希值中获得一个可读的数字OTP。 取HS的最后一个字节的低4位（HS[19] & 0xF）作为偏移量offset。 从HS中offset位置开始，连续取4个字节（HS[offset...offset+3]）。 将这4个字节转换为一个32位整数，并将其最高位清零（避免负数）。 Snum = (HS[offset] & 0x7f) &lt;&lt; 24 | (HS[offset+1] & 0xff) &lt;&lt; 16 | (HS[offset+2] & 0xff) &lt;&lt; 8 | (HS[offset+3] & 0xff) 生成OTP： 将上一步得到的31位数字Snum对10^D取模，其中D是OTP的位数（通常是6位或8位），然后补足前导零。 OTP = Snum % (10^D) 1.2 HOTP的挑战：计数器同步 HOTP的主要挑战在于客户端和服务器的计数器必须严格同步。如果用户在客户端多次生成OTP但没有在服务器端验证（例如，生成了两次但只提交了一次），或者服务器因为某些原因重置了计数器，都可能导致计数器不同步，从而无法通过验证。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC7%E7%AF%87mfa%E5%AE%9E%E6%88%98totp%E4%B8%8Ehotp%E7%AE%97%E6%B3%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>第8篇：告别密码？FIDO与WebAuthn技术如何引领无密码认证 在过去的几篇文章中，我们深入探讨了密码存储的强化策略和多因素认证（MFA）的重要性。然而，即便有MFA的加持，密码本身固有的弱点——易被猜测、易被钓鱼、需要记忆——始终是安全和用户体验的一大痛点。用户因密码疲劳而设置弱密码，或在多个网站重复使用密码，都为攻击者留下了可乘之机。
于是，一个大胆而变革性的理念应运而生：告别密码，迈向无密码认证（Passwordless Authentication）。而引领这场变革的，正是FIDO联盟（Fast IDentity Online Alliance）及其核心标准WebAuthn。
1. 密码的“原罪”与无密码认证的召唤 为什么我们需要告别密码？密码的“原罪”主要体现在：
安全性弱点： 钓鱼攻击、中间人攻击、键盘记录器、暴力破解、字典攻击等，都以窃取或猜测密码为目标。即使有MFA，也仍需用户输入密码这一环节。 用户体验差： 用户需要记住大量复杂且独特的密码，导致密码疲劳、忘记密码、账户锁定，严重影响用户体验和生产力。 管理成本高昂： 企业在密码重置、账户解锁等客服支持上投入巨大资源。 无密码认证旨在消除对传统密码的依赖，通过更安全、更便捷的方式验证用户身份，从而提升整体安全态势和用户体验。
2. FIDO联盟：推动无密码认证的行业巨擘 FIDO联盟（Fast IDentity Online Alliance） 成立于2012年，是一个开放性行业协会，旨在解决强认证技术之间缺乏互操作性，以及用户在创建和记住多个用户名和密码时遇到的问题。其愿景是构建一个全球互操作的、基于标准的、无密码的认证生态系统。
FIDO联盟发布了一系列开放标准，其中最核心的是：
FIDO UAF (Universal Authentication Framework)： 旨在实现无需密码，即可通过指纹、面部识别、语音等生物识别技术进行强认证。 FIDO U2F (Universal Second Factor)： 旨在为现有密码认证添加一个强大的第二因素，通常通过物理安全密钥实现。 FIDO2： 这是FIDO联盟的最新且最全面的规范集合，它集成了FIDO UAF和U2F的优势，并通过WebAuthn和CTAP协议，实现了在Web和应用程序上进行原生、跨平台的无密码认证。 3. WebAuthn：无密码认证的Web标准 WebAuthn（Web Authentication） 是FIDO2标准的核心组成部分，它是由FIDO联盟与W3C（万维网联盟）合作发布的Web标准。这意味着WebAuthn是所有现代Web浏览器都应支持的API，使得任何网站都能原生集成强健的FIDO认证功能。
简单来说，WebAuthn允许Web应用程序通过浏览器的内置功能与用户设备的认证器（Authenticator）进行交互，以实现安全、便捷的无密码登录或多因素认证。
4. WebAuthn/FIDO的工作原理：公钥密码学的魔法 FIDO和WebAuthn认证的核心是公钥密码学（Public-Key Cryptography），而非共享秘密（如密码）。这与传统密码认证有本质区别，也正是其强大的安全基石。
核心组件：
用户（User）： 希望登录或进行认证的个人。 客户端/浏览器（Client/Browser）： 用户使用的设备和浏览器（支持WebAuthn API）。 认证器（Authenticator）： 存储用户私钥并进行加密操作的设备。可以是： 平台认证器： 内置在设备中（如笔记本电脑的指纹传感器、手机的Face ID），私钥安全存储在硬件安全模块（如TPM、SE）中。 漫游认证器： 可插拔的外部设备（如USB安全密钥，即FIDO U2F密钥），私钥存储在密钥内部。 依赖方（Relying Party, RP）： 提供服务的网站或应用程序（需要集成WebAuthn）。 注册（Registration）流程（绑定设备）： sequenceDiagram participant RP as 依赖方 (Relying Party) participant Client as 客户端 (浏览器) participant Authenticator as 认证器 (如指纹识别器/USB Key)
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC8%E7%AF%87%E5%91%8A%E5%88%AB%E5%AF%86%E7%A0%81fido%E4%B8%8Ewebauthn%E6%8A%80%E6%9C%AF%E5%A6%82%E4%BD%95%E5%BC%95%E9%A2%86%E6%97%A0%E5%AF%86%E7%A0%81%E8%AE%A4%E8%AF%81/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>第9篇：单点登录（SSO）：一次登录，畅行无阻的秘密 在企业日常工作中，员工可能需要访问数十个甚至上百个不同的应用系统，从内部管理系统、CRM、ERP到各种SaaS服务（如Office 365、Salesforce等）。如果每个应用都需要单独登录，用户将不得不记住大量账号密码，并频繁地重复登录操作，这不仅带来了巨大的“密码疲劳”，严重影响工作效率，也增加了密码被盗用或滥用的风险。
正是为了解决这一痛点，单点登录（Single Sign-On，简称SSO） 技术应运而生。它承诺为用户提供“一次登录，畅行无阻”的丝滑体验。
1. 什么是单点登录（SSO）？ 单点登录（SSO）是一种身份认证机制，它允许用户在一次成功的认证后，无需再次输入凭证即可访问多个相互信任的应用系统。 简而言之，用户只需登录一次，就可以在授权范围内无缝切换并使用所有关联的应用。
SSO的核心在于建立一个信任关系：用户在某个中央身份提供者（Identity Provider, IdP）处完成认证后，IdP会向用户颁发一个安全令牌（Security Token）。当用户尝试访问其他服务提供者（Service Provider, SP）时，SP会信任这个由IdP颁发的令牌，从而允许用户直接访问，而无需重新认证。
2. SSO的原理与核心角色 理解SSO的工作原理，需要明确几个核心角色：
用户（User）： 尝试访问各种应用的用户。 身份提供者（Identity Provider, IdP）： 负责集中管理用户身份、执行用户认证并颁发认证凭证（通常是安全令牌）的系统。它是SSO的核心，负责“你是谁？”的验证。常见的IdP包括企业内部的Active Directory联邦服务（AD FS）、Okta、Auth0、Ping Identity等。 服务提供者（Service Provider, SP）： 提供具体应用服务的系统。它们依赖于IdP进行用户身份验证，并根据IdP返回的认证信息来授权用户访问。SP负责“你能做什么？”的授权。 SSO的基本流程（概览）：
用户尝试访问受SSO保护的某个应用（SP）。 SP检测到用户未登录，将其重定向到IdP进行认证。 用户在IdP处输入凭证（用户名/密码，可能还有MFA）完成认证。 IdP认证成功后，生成一个包含用户身份信息的安全令牌，并将其发送回用户浏览器。 用户浏览器带着这个令牌再次重定向回原始的SP。 SP接收并验证令牌的有效性（信任来自IdP的签名），确认用户身份。 SP允许用户访问应用。 关键点： 在整个过程中，用户凭证（密码）只提交给IdP一次，SP只接收和验证由IdP签名的令牌，从而实现了无密码输入的多应用访问。
3. SSO的价值：安全、效率与体验的多赢 SSO不仅仅是技术，更是为企业带来多方面价值的战略性工具：
3.1 增强安全性 减少密码疲劳和弱密码： 用户只需记住一个强密码（IdP的密码），从而减少了在多个系统使用弱密码或重复密码的倾向。 集中式认证与MFA强制： 所有的认证都集中在IdP进行，IdP可以统一强制执行强密码策略和多因素认证（MFA），确保所有应用的登录都受到最高级别的保护。 快速账户禁用： 当员工离职时，只需在IdP中禁用其账户，即可立即切断其对所有关联应用的访问，防止权限滥用和数据泄露。 审计与合规性： 所有的登录活动都集中记录在IdP，便于进行审计和满足合规性要求。 3.2 提升用户体验 简化登录流程： 用户只需一次登录，即可无缝访问多个应用，极大地提升了工作效率和用户满意度。 降低记忆负担： 用户无需记住多个用户名和密码。 减少账户锁定： 忘记密码和账户锁定事件减少，提高了用户的自主性。 3.3 降低管理成本 减少IT支持： 大幅减少了IT部门处理密码重置和账户锁定请求的工作量。 简化应用集成： 新应用接入SSO体系后，无需单独管理用户认证逻辑，降低了开发和维护成本。 提高生产力： 员工将更多时间投入到核心业务中，而非繁琐的登录操作。 4. SSO的常见实现方式 SSO的实现方式多种多样，从简单的基于Cookie到复杂的联邦身份协议，各有其适用场景。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC9%E7%AF%87%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95sso%E4%B8%80%E6%AC%A1%E7%99%BB%E5%BD%95%E7%95%85%E8%A1%8C%E6%97%A0%E9%98%BB%E7%9A%84%E7%A7%98%E5%AF%86/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://bsong2015.github.io/blog/posts/technology/>«&nbsp;上一页&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://bsong2015.github.io/blog/>万年水的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>