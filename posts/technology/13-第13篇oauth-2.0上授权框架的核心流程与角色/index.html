<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>万年水的博客</title><meta name=keywords content><meta name=description content="第13篇：OAuth 2.0（上）：授权框架的核心流程与角色
在当今的数字生态系统中，我们经常遇到这样的场景：一个应用（例如，一个照片编辑工具）需要访问你在另一个服务（例如，Google相册）上的资源。你当然不希望把Google相册的用户名和密码直接告诉照片编辑工具，因为这不仅不安全，也意味着这个工具将拥有你账户的全部权限。
正是为了解决这种“委托授权”的问题，OAuth 2.0应运而生。它不是一个认证协议，而是一个授权框架，允许第三方应用在不获取用户凭证的情况下，安全地访问用户在服务提供者处的受保护资源。
1. OAuth 2.0的背景与目标
1.1 背景：为什么需要OAuth？
在OAuth出现之前，应用程序访问用户资源的常见方式是 “共享凭证模式”：用户直接把自己在A网站的用户名和密码提供给B网站，让B网站以用户身份登录A网站并获取数据。这种模式存在巨大弊端：

安全风险高： B网站获取了用户的真实凭证，可以对A网站进行任何操作，包括未经授权的操作。如果B网站发生数据泄露，用户的A网站凭证也将暴露。
无法细粒度授权： 无法控制B网站只能访问特定资源或执行特定操作。
凭证生命周期管理困难： 用户无法方便地撤销B网站的访问权限，除非修改A网站密码，这会影响其他所有依赖该密码的应用。

OAuth 1.0在一定程度上解决了这些问题，但其复杂性限制了广泛应用。OAuth 2.0则在1.0的基础上进行了彻底的简化和改进，使其更易于实现和部署，成为现代API授权的事实标准。
1.2 目标：委托授权与安全解耦
OAuth 2.0的核心目标是实现委托授权（Delegated Authorization），即允许用户授权第三方应用（客户端）在限定的权限（作用域/Scope）内，代表用户访问其在资源服务器上的特定资源。
它旨在实现：

安全性： 用户凭证不直接暴露给第三方应用。
授权范围控制： 用户可以明确授权第三方应用访问哪些资源，以及进行哪些操作（通过Scope）。
便捷性： 用户授权过程简化，用户体验提升。
可撤销性： 用户可以随时撤销对第三方应用的授权，而无需修改密码。

2. OAuth 2.0的核心角色
OAuth 2.0框架中定义了四个核心角色，理解它们之间的交互是理解OAuth 2.0流程的关键：
2.1 资源所有者（Resource Owner）

定义： 拥有受保护资源的个人或实体。通常是最终用户。
作用： 授权客户端应用访问其在资源服务器上的资源。

2.2 客户端（Client）

定义： 希望访问受保护资源的应用程序。可以是Web应用、移动应用、桌面应用或服务器端应用。
作用： 代表资源所有者向资源服务器请求访问受保护资源。客户端必须预先在授权服务器注册，获得client_id和client_secret。

2.3 授权服务器（Authorization Server）

定义： 负责验证资源所有者身份，并在资源所有者同意后，向客户端颁发访问令牌（Access Token）。
作用： 是OAuth 2.0流程的枢纽。它处理用户的认证和授权，管理客户端的注册，并颁发不同类型的令牌。

2.4 资源服务器（Resource Server）

定义： 存储并提供受保护资源的服务器。
作用： 接收客户端的资源请求，通过验证请求中携带的访问令牌的有效性来决定是否允许访问资源。

3. OAuth 2.0的四种主要授权模式（Grant Types）
OAuth 2.0定义了多种授权模式（Grant Types），以适应不同类型的客户端和应用场景。每种模式都有其特定的工作流程和安全考量。"><meta name=author content><link rel=canonical href=https://bsong2015.github.io/blog/posts/technology/13-%E7%AC%AC13%E7%AF%87oauth-2.0%E4%B8%8A%E6%8E%88%E6%9D%83%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%A7%92%E8%89%B2/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://bsong2015.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bsong2015.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bsong2015.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://bsong2015.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://bsong2015.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://bsong2015.github.io/blog/posts/technology/13-%E7%AC%AC13%E7%AF%87oauth-2.0%E4%B8%8A%E6%8E%88%E6%9D%83%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%A7%92%E8%89%B2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    
    
    const prepareMermaid = () => {
        document.querySelectorAll("pre code.language-mermaid").forEach(function(block) {
            const pre = block.parentNode;
            const mermaidContainer = document.createElement("div");
            mermaidContainer.className = "mermaid";
            mermaidContainer.textContent = block.textContent;
            pre.parentNode.replaceChild(mermaidContainer, pre);
        });
    };

    
    const initMermaid = () => {
        prepareMermaid();
        mermaid.initialize({ startOnLoad: true });
        mermaid.run();
    }

    initMermaid();
    document.addEventListener("astro:after-swap", initMermaid);
</script><meta property="og:url" content="https://bsong2015.github.io/blog/posts/technology/13-%E7%AC%AC13%E7%AF%87oauth-2.0%E4%B8%8A%E6%8E%88%E6%9D%83%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%A7%92%E8%89%B2/"><meta property="og:site_name" content="万年水的博客"><meta property="og:title" content="万年水的博客"><meta property="og:description" content="第13篇：OAuth 2.0（上）：授权框架的核心流程与角色 在当今的数字生态系统中，我们经常遇到这样的场景：一个应用（例如，一个照片编辑工具）需要访问你在另一个服务（例如，Google相册）上的资源。你当然不希望把Google相册的用户名和密码直接告诉照片编辑工具，因为这不仅不安全，也意味着这个工具将拥有你账户的全部权限。
正是为了解决这种“委托授权”的问题，OAuth 2.0应运而生。它不是一个认证协议，而是一个授权框架，允许第三方应用在不获取用户凭证的情况下，安全地访问用户在服务提供者处的受保护资源。
1. OAuth 2.0的背景与目标 1.1 背景：为什么需要OAuth？ 在OAuth出现之前，应用程序访问用户资源的常见方式是 “共享凭证模式”：用户直接把自己在A网站的用户名和密码提供给B网站，让B网站以用户身份登录A网站并获取数据。这种模式存在巨大弊端：
安全风险高： B网站获取了用户的真实凭证，可以对A网站进行任何操作，包括未经授权的操作。如果B网站发生数据泄露，用户的A网站凭证也将暴露。 无法细粒度授权： 无法控制B网站只能访问特定资源或执行特定操作。 凭证生命周期管理困难： 用户无法方便地撤销B网站的访问权限，除非修改A网站密码，这会影响其他所有依赖该密码的应用。 OAuth 1.0在一定程度上解决了这些问题，但其复杂性限制了广泛应用。OAuth 2.0则在1.0的基础上进行了彻底的简化和改进，使其更易于实现和部署，成为现代API授权的事实标准。
1.2 目标：委托授权与安全解耦 OAuth 2.0的核心目标是实现委托授权（Delegated Authorization），即允许用户授权第三方应用（客户端）在限定的权限（作用域/Scope）内，代表用户访问其在资源服务器上的特定资源。
它旨在实现：
安全性： 用户凭证不直接暴露给第三方应用。 授权范围控制： 用户可以明确授权第三方应用访问哪些资源，以及进行哪些操作（通过Scope）。 便捷性： 用户授权过程简化，用户体验提升。 可撤销性： 用户可以随时撤销对第三方应用的授权，而无需修改密码。 2. OAuth 2.0的核心角色 OAuth 2.0框架中定义了四个核心角色，理解它们之间的交互是理解OAuth 2.0流程的关键：
2.1 资源所有者（Resource Owner） 定义： 拥有受保护资源的个人或实体。通常是最终用户。 作用： 授权客户端应用访问其在资源服务器上的资源。 2.2 客户端（Client） 定义： 希望访问受保护资源的应用程序。可以是Web应用、移动应用、桌面应用或服务器端应用。 作用： 代表资源所有者向资源服务器请求访问受保护资源。客户端必须预先在授权服务器注册，获得client_id和client_secret。 2.3 授权服务器（Authorization Server） 定义： 负责验证资源所有者身份，并在资源所有者同意后，向客户端颁发访问令牌（Access Token）。 作用： 是OAuth 2.0流程的枢纽。它处理用户的认证和授权，管理客户端的注册，并颁发不同类型的令牌。 2.4 资源服务器（Resource Server） 定义： 存储并提供受保护资源的服务器。 作用： 接收客户端的资源请求，通过验证请求中携带的访问令牌的有效性来决定是否允许访问资源。 3. OAuth 2.0的四种主要授权模式（Grant Types） OAuth 2.0定义了多种授权模式（Grant Types），以适应不同类型的客户端和应用场景。每种模式都有其特定的工作流程和安全考量。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="第13篇：OAuth 2.0（上）：授权框架的核心流程与角色
在当今的数字生态系统中，我们经常遇到这样的场景：一个应用（例如，一个照片编辑工具）需要访问你在另一个服务（例如，Google相册）上的资源。你当然不希望把Google相册的用户名和密码直接告诉照片编辑工具，因为这不仅不安全，也意味着这个工具将拥有你账户的全部权限。
正是为了解决这种“委托授权”的问题，OAuth 2.0应运而生。它不是一个认证协议，而是一个授权框架，允许第三方应用在不获取用户凭证的情况下，安全地访问用户在服务提供者处的受保护资源。
1. OAuth 2.0的背景与目标
1.1 背景：为什么需要OAuth？
在OAuth出现之前，应用程序访问用户资源的常见方式是 “共享凭证模式”：用户直接把自己在A网站的用户名和密码提供给B网站，让B网站以用户身份登录A网站并获取数据。这种模式存在巨大弊端：

安全风险高： B网站获取了用户的真实凭证，可以对A网站进行任何操作，包括未经授权的操作。如果B网站发生数据泄露，用户的A网站凭证也将暴露。
无法细粒度授权： 无法控制B网站只能访问特定资源或执行特定操作。
凭证生命周期管理困难： 用户无法方便地撤销B网站的访问权限，除非修改A网站密码，这会影响其他所有依赖该密码的应用。

OAuth 1.0在一定程度上解决了这些问题，但其复杂性限制了广泛应用。OAuth 2.0则在1.0的基础上进行了彻底的简化和改进，使其更易于实现和部署，成为现代API授权的事实标准。
1.2 目标：委托授权与安全解耦
OAuth 2.0的核心目标是实现委托授权（Delegated Authorization），即允许用户授权第三方应用（客户端）在限定的权限（作用域/Scope）内，代表用户访问其在资源服务器上的特定资源。
它旨在实现：

安全性： 用户凭证不直接暴露给第三方应用。
授权范围控制： 用户可以明确授权第三方应用访问哪些资源，以及进行哪些操作（通过Scope）。
便捷性： 用户授权过程简化，用户体验提升。
可撤销性： 用户可以随时撤销对第三方应用的授权，而无需修改密码。

2. OAuth 2.0的核心角色
OAuth 2.0框架中定义了四个核心角色，理解它们之间的交互是理解OAuth 2.0流程的关键：
2.1 资源所有者（Resource Owner）

定义： 拥有受保护资源的个人或实体。通常是最终用户。
作用： 授权客户端应用访问其在资源服务器上的资源。

2.2 客户端（Client）

定义： 希望访问受保护资源的应用程序。可以是Web应用、移动应用、桌面应用或服务器端应用。
作用： 代表资源所有者向资源服务器请求访问受保护资源。客户端必须预先在授权服务器注册，获得client_id和client_secret。

2.3 授权服务器（Authorization Server）

定义： 负责验证资源所有者身份，并在资源所有者同意后，向客户端颁发访问令牌（Access Token）。
作用： 是OAuth 2.0流程的枢纽。它处理用户的认证和授权，管理客户端的注册，并颁发不同类型的令牌。

2.4 资源服务器（Resource Server）

定义： 存储并提供受保护资源的服务器。
作用： 接收客户端的资源请求，通过验证请求中携带的访问令牌的有效性来决定是否允许访问资源。

3. OAuth 2.0的四种主要授权模式（Grant Types）
OAuth 2.0定义了多种授权模式（Grant Types），以适应不同类型的客户端和应用场景。每种模式都有其特定的工作流程和安全考量。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bsong2015.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"技术实践","item":"https://bsong2015.github.io/blog/posts/technology/"},{"@type":"ListItem","position":3,"name":"","item":"https://bsong2015.github.io/blog/posts/technology/13-%E7%AC%AC13%E7%AF%87oauth-2.0%E4%B8%8A%E6%8E%88%E6%9D%83%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%A7%92%E8%89%B2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"第13篇：OAuth 2.0（上）：授权框架的核心流程与角色 在当今的数字生态系统中，我们经常遇到这样的场景：一个应用（例如，一个照片编辑工具）需要访问你在另一个服务（例如，Google相册）上的资源。你当然不希望把Google相册的用户名和密码直接告诉照片编辑工具，因为这不仅不安全，也意味着这个工具将拥有你账户的全部权限。\n正是为了解决这种“委托授权”的问题，OAuth 2.0应运而生。它不是一个认证协议，而是一个授权框架，允许第三方应用在不获取用户凭证的情况下，安全地访问用户在服务提供者处的受保护资源。\n1. OAuth 2.0的背景与目标 1.1 背景：为什么需要OAuth？ 在OAuth出现之前，应用程序访问用户资源的常见方式是 “共享凭证模式”：用户直接把自己在A网站的用户名和密码提供给B网站，让B网站以用户身份登录A网站并获取数据。这种模式存在巨大弊端：\n安全风险高： B网站获取了用户的真实凭证，可以对A网站进行任何操作，包括未经授权的操作。如果B网站发生数据泄露，用户的A网站凭证也将暴露。 无法细粒度授权： 无法控制B网站只能访问特定资源或执行特定操作。 凭证生命周期管理困难： 用户无法方便地撤销B网站的访问权限，除非修改A网站密码，这会影响其他所有依赖该密码的应用。 OAuth 1.0在一定程度上解决了这些问题，但其复杂性限制了广泛应用。OAuth 2.0则在1.0的基础上进行了彻底的简化和改进，使其更易于实现和部署，成为现代API授权的事实标准。\n1.2 目标：委托授权与安全解耦 OAuth 2.0的核心目标是实现委托授权（Delegated Authorization），即允许用户授权第三方应用（客户端）在限定的权限（作用域/Scope）内，代表用户访问其在资源服务器上的特定资源。\n它旨在实现：\n安全性： 用户凭证不直接暴露给第三方应用。 授权范围控制： 用户可以明确授权第三方应用访问哪些资源，以及进行哪些操作（通过Scope）。 便捷性： 用户授权过程简化，用户体验提升。 可撤销性： 用户可以随时撤销对第三方应用的授权，而无需修改密码。 2. OAuth 2.0的核心角色 OAuth 2.0框架中定义了四个核心角色，理解它们之间的交互是理解OAuth 2.0流程的关键：\n2.1 资源所有者（Resource Owner） 定义： 拥有受保护资源的个人或实体。通常是最终用户。 作用： 授权客户端应用访问其在资源服务器上的资源。 2.2 客户端（Client） 定义： 希望访问受保护资源的应用程序。可以是Web应用、移动应用、桌面应用或服务器端应用。 作用： 代表资源所有者向资源服务器请求访问受保护资源。客户端必须预先在授权服务器注册，获得client_id和client_secret。 2.3 授权服务器（Authorization Server） 定义： 负责验证资源所有者身份，并在资源所有者同意后，向客户端颁发访问令牌（Access Token）。 作用： 是OAuth 2.0流程的枢纽。它处理用户的认证和授权，管理客户端的注册，并颁发不同类型的令牌。 2.4 资源服务器（Resource Server） 定义： 存储并提供受保护资源的服务器。 作用： 接收客户端的资源请求，通过验证请求中携带的访问令牌的有效性来决定是否允许访问资源。 3. OAuth 2.0的四种主要授权模式（Grant Types） OAuth 2.0定义了多种授权模式（Grant Types），以适应不同类型的客户端和应用场景。每种模式都有其特定的工作流程和安全考量。\n","keywords":[],"articleBody":"第13篇：OAuth 2.0（上）：授权框架的核心流程与角色 在当今的数字生态系统中，我们经常遇到这样的场景：一个应用（例如，一个照片编辑工具）需要访问你在另一个服务（例如，Google相册）上的资源。你当然不希望把Google相册的用户名和密码直接告诉照片编辑工具，因为这不仅不安全，也意味着这个工具将拥有你账户的全部权限。\n正是为了解决这种“委托授权”的问题，OAuth 2.0应运而生。它不是一个认证协议，而是一个授权框架，允许第三方应用在不获取用户凭证的情况下，安全地访问用户在服务提供者处的受保护资源。\n1. OAuth 2.0的背景与目标 1.1 背景：为什么需要OAuth？ 在OAuth出现之前，应用程序访问用户资源的常见方式是 “共享凭证模式”：用户直接把自己在A网站的用户名和密码提供给B网站，让B网站以用户身份登录A网站并获取数据。这种模式存在巨大弊端：\n安全风险高： B网站获取了用户的真实凭证，可以对A网站进行任何操作，包括未经授权的操作。如果B网站发生数据泄露，用户的A网站凭证也将暴露。 无法细粒度授权： 无法控制B网站只能访问特定资源或执行特定操作。 凭证生命周期管理困难： 用户无法方便地撤销B网站的访问权限，除非修改A网站密码，这会影响其他所有依赖该密码的应用。 OAuth 1.0在一定程度上解决了这些问题，但其复杂性限制了广泛应用。OAuth 2.0则在1.0的基础上进行了彻底的简化和改进，使其更易于实现和部署，成为现代API授权的事实标准。\n1.2 目标：委托授权与安全解耦 OAuth 2.0的核心目标是实现委托授权（Delegated Authorization），即允许用户授权第三方应用（客户端）在限定的权限（作用域/Scope）内，代表用户访问其在资源服务器上的特定资源。\n它旨在实现：\n安全性： 用户凭证不直接暴露给第三方应用。 授权范围控制： 用户可以明确授权第三方应用访问哪些资源，以及进行哪些操作（通过Scope）。 便捷性： 用户授权过程简化，用户体验提升。 可撤销性： 用户可以随时撤销对第三方应用的授权，而无需修改密码。 2. OAuth 2.0的核心角色 OAuth 2.0框架中定义了四个核心角色，理解它们之间的交互是理解OAuth 2.0流程的关键：\n2.1 资源所有者（Resource Owner） 定义： 拥有受保护资源的个人或实体。通常是最终用户。 作用： 授权客户端应用访问其在资源服务器上的资源。 2.2 客户端（Client） 定义： 希望访问受保护资源的应用程序。可以是Web应用、移动应用、桌面应用或服务器端应用。 作用： 代表资源所有者向资源服务器请求访问受保护资源。客户端必须预先在授权服务器注册，获得client_id和client_secret。 2.3 授权服务器（Authorization Server） 定义： 负责验证资源所有者身份，并在资源所有者同意后，向客户端颁发访问令牌（Access Token）。 作用： 是OAuth 2.0流程的枢纽。它处理用户的认证和授权，管理客户端的注册，并颁发不同类型的令牌。 2.4 资源服务器（Resource Server） 定义： 存储并提供受保护资源的服务器。 作用： 接收客户端的资源请求，通过验证请求中携带的访问令牌的有效性来决定是否允许访问资源。 3. OAuth 2.0的四种主要授权模式（Grant Types） OAuth 2.0定义了多种授权模式（Grant Types），以适应不同类型的客户端和应用场景。每种模式都有其特定的工作流程和安全考量。\n3.1 授权码模式（Authorization Code Grant） 特点： 这是最常用、最安全、也是推荐用于Web服务器端应用的授权模式。 流程概述： 客户端请求授权： 客户端引导用户到授权服务器进行授权。 资源所有者授权： 用户在授权服务器上登录并同意授权请求。 授权服务器颁发授权码： 授权服务器将一个授权码（Authorization Code） 重定向回客户端（通过客户端预注册的重定向URI）。 客户端使用授权码换取令牌： 客户端（服务器端）使用授权码和其client_secret（客户端凭证）向授权服务器的令牌端点（Token Endpoint）发起请求，交换访问令牌。 授权服务器颁发令牌： 授权服务器验证授权码和客户端凭证，然后颁发访问令牌（Access Token）和可选的刷新令牌（Refresh Token）。 客户端使用令牌访问资源： 客户端使用访问令牌向资源服务器请求受保护资源。 安全性： 授权码通过浏览器传递，但访问令牌的交换发生在客户端服务器和授权服务器之间（后端通信），客户端凭证得以保密，避免泄露。刷新令牌可用于获取新的访问令牌，延长会话而无需用户重新授权。 适用场景： 传统的Web服务器端应用（如Java Spring Boot应用、Node.js应用）。 sequenceDiagram participant C as 客户端 (Web服务器端应用) participant U as 用户 (资源所有者) participant AS as 授权服务器 participant RS as 资源服务器 C-\u003e\u003eAS: 1. 引导用户到授权服务器进行授权 U-\u003e\u003eAS: 2. 登录并同意授权请求 AS--\u003e\u003eC: 3. 重定向授权码 (Authorization Code) 回客户端 C-\u003e\u003eAS: 4. 使用授权码和客户端凭证向令牌端点发起请求，交换访问令牌 AS--\u003e\u003eC: 5. 颁发访问令牌 (Access Token) 和可选的刷新令牌 (Refresh Token) C-\u003e\u003eRS: 6. 使用访问令牌请求受保护资源 RS--\u003e\u003eC: 7. 返回受保护资源 3.2 隐式模式（Implicit Grant） 特点： 专为单页应用（SPA）和原生移动应用设计，其特点是直接在浏览器端或移动应用中获取访问令牌。 流程概述： 客户端请求授权： 客户端引导用户到授权服务器进行授权。 资源所有者授权： 用户在授权服务器上登录并同意授权请求。 授权服务器直接颁发令牌： 授权服务器将访问令牌直接作为URI片段（#access_token=…）重定向回客户端。 客户端使用令牌访问资源： 客户端从URI中解析出访问令牌，并使用它访问资源服务器。 安全性： 令牌直接在浏览器URI中暴露，没有刷新令牌，安全性较低。在公共客户端（Public Clients，如SPA）中，客户端凭证无法安全存储。在OAuth 2.1中已被弃用，推荐使用带PKCE（Proof Key for Code Exchange）的授权码模式替代。 适用场景： 早期用于SPA和移动应用，但现在不推荐使用。 3.3 客户端凭证模式（Client Credentials Grant） 特点： 这种模式不涉及资源所有者（用户）的参与，而是用于客户端（通常是服务器端应用或服务）直接以自身身份向资源服务器请求访问。 流程概述： 客户端请求令牌： 客户端使用其client_id和client_secret直接向授权服务器的令牌端点请求访问令牌。 授权服务器颁发令牌： 授权服务器验证客户端凭证，然后颁发访问令牌。 客户端使用令牌访问资源： 客户端使用访问令牌向资源服务器请求受保护资源。 安全性： 客户端凭证必须得到严密保护，仅适用于高度受信任的服务器端客户端。 适用场景： 服务间调用（Service-to-Service Communication），例如一个微服务需要访问另一个微服务的API。 3.4 密码模式（Resource Owner Password Credentials Grant） 特点： 客户端直接要求资源所有者提供其用户名和密码，然后客户端将这些凭证发送给授权服务器以获取访问令牌。 流程概述： 客户端收集凭证： 客户端向用户请求用户名和密码。 客户端发送凭证换取令牌： 客户端将用户名、密码和其client_id和client_secret（可选）发送给授权服务器的令牌端点。 授权服务器颁发令牌： 授权服务器验证用户凭证和客户端凭证，然后颁发访问令牌和可选的刷新令牌。 客户端使用令牌访问资源： 客户端使用访问令牌访问资源服务器。 安全性： 这是最不安全的模式。 用户的真实密码直接暴露给客户端。这违背了OAuth 2.0不共享凭证的核心目标。 适用场景： 仅在客户端高度可信（例如，授权服务器自身的第一方应用）且其他模式不可用时作为最后的选择。通常不推荐使用。 总结 OAuth 2.0是一个强大而灵活的授权框架，它通过将授权过程中的各个角色职责分离，并引入访问令牌的概念，实现了安全、可控的委托授权。理解其背景、核心角色以及四种主要授权模式（授权码、隐式、客户端凭证、密码）是掌握其精髓的第一步。\n通过这些授权模式，客户端能够安全地获取代表用户访问资源的凭证，而无需直接处理用户敏感的登录凭证。然而，OAuth 2.0的强大远不止于此，其核心还在于它所颁发的令牌（Token），以及令牌背后所承载的授权范围（Scope）。这些要素共同构成了OAuth 2.0体系的安全基石，并需要结合一系列安全最佳实践才能发挥最大效用。\n在下一篇中，我们将深入探讨OAuth 2.0中的令牌机制、作用域的概念，并分享一些重要的安全最佳实践，以帮助您更全面地理解和应用这一授权框架。\n欢迎关注+点赞+推荐+转发\n","wordCount":"229","inLanguage":"zh","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bsong2015.github.io/blog/posts/technology/13-%E7%AC%AC13%E7%AF%87oauth-2.0%E4%B8%8A%E6%8E%88%E6%9D%83%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%A7%92%E8%89%B2/"},"publisher":{"@type":"Organization","name":"万年水的博客","logo":{"@type":"ImageObject","url":"https://bsong2015.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bsong2015.github.io/blog/ accesskey=h title="万年水的博客 (Alt + H)">万年水的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bsong2015.github.io/blog/posts/artificial-intelligence/ title=人工智能><span>人工智能</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/reading/ title=阅读><span>阅读</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/thinking-models/ title=思维模型><span>思维模型</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/thought-experiments/ title=思想实验><span>思想实验</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/personal-growth/ title=个人成长><span>个人成长</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/technology/ title=技术><span>技术</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/current-affairs/ title=时事><span>时事</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/others/ title=其它><span>其它</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent"></h1><div class=post-meta></div></header><div class=post-content><h2 id=第13篇oauth-20上授权框架的核心流程与角色>第13篇：OAuth 2.0（上）：授权框架的核心流程与角色<a hidden class=anchor aria-hidden=true href=#第13篇oauth-20上授权框架的核心流程与角色>#</a></h2><p>在当今的数字生态系统中，我们经常遇到这样的场景：一个应用（例如，一个照片编辑工具）需要访问你在另一个服务（例如，Google相册）上的资源。你当然不希望把Google相册的用户名和密码直接告诉照片编辑工具，因为这不仅不安全，也意味着这个工具将拥有你账户的全部权限。</p><p>正是为了解决这种“委托授权”的问题，<strong>OAuth 2.0</strong>应运而生。它不是一个认证协议，而是一个授权框架，允许第三方应用<strong>在不获取用户凭证的情况下，安全地访问用户在服务提供者处的受保护资源。</strong></p><h3 id=1-oauth-20的背景与目标>1. OAuth 2.0的背景与目标<a hidden class=anchor aria-hidden=true href=#1-oauth-20的背景与目标>#</a></h3><h4 id=11-背景为什么需要oauth>1.1 背景：为什么需要OAuth？<a hidden class=anchor aria-hidden=true href=#11-背景为什么需要oauth>#</a></h4><p>在OAuth出现之前，应用程序访问用户资源的常见方式是 <strong>“共享凭证模式”</strong>：用户直接把自己在A网站的用户名和密码提供给B网站，让B网站以用户身份登录A网站并获取数据。这种模式存在巨大弊端：</p><ul><li><strong>安全风险高：</strong> B网站获取了用户的真实凭证，可以对A网站进行任何操作，包括未经授权的操作。如果B网站发生数据泄露，用户的A网站凭证也将暴露。</li><li><strong>无法细粒度授权：</strong> 无法控制B网站只能访问特定资源或执行特定操作。</li><li><strong>凭证生命周期管理困难：</strong> 用户无法方便地撤销B网站的访问权限，除非修改A网站密码，这会影响其他所有依赖该密码的应用。</li></ul><p>OAuth 1.0在一定程度上解决了这些问题，但其复杂性限制了广泛应用。<strong>OAuth 2.0</strong>则在1.0的基础上进行了彻底的简化和改进，使其更易于实现和部署，成为现代API授权的事实标准。</p><h4 id=12-目标委托授权与安全解耦>1.2 目标：委托授权与安全解耦<a hidden class=anchor aria-hidden=true href=#12-目标委托授权与安全解耦>#</a></h4><p>OAuth 2.0的核心目标是实现<strong>委托授权（Delegated Authorization）</strong>，即允许用户授权第三方应用（客户端）在限定的权限（作用域/Scope）内，代表用户访问其在资源服务器上的特定资源。</p><p>它旨在实现：</p><ul><li><strong>安全性：</strong> 用户凭证不直接暴露给第三方应用。</li><li><strong>授权范围控制：</strong> 用户可以明确授权第三方应用访问哪些资源，以及进行哪些操作（通过Scope）。</li><li><strong>便捷性：</strong> 用户授权过程简化，用户体验提升。</li><li><strong>可撤销性：</strong> 用户可以随时撤销对第三方应用的授权，而无需修改密码。</li></ul><h3 id=2-oauth-20的核心角色>2. OAuth 2.0的核心角色<a hidden class=anchor aria-hidden=true href=#2-oauth-20的核心角色>#</a></h3><p>OAuth 2.0框架中定义了四个核心角色，理解它们之间的交互是理解OAuth 2.0流程的关键：</p><h4 id=21-资源所有者resource-owner>2.1 资源所有者（Resource Owner）<a hidden class=anchor aria-hidden=true href=#21-资源所有者resource-owner>#</a></h4><ul><li><strong>定义：</strong> 拥有受保护资源的个人或实体。通常是最终用户。</li><li><strong>作用：</strong> 授权客户端应用访问其在资源服务器上的资源。</li></ul><h4 id=22-客户端client>2.2 客户端（Client）<a hidden class=anchor aria-hidden=true href=#22-客户端client>#</a></h4><ul><li><strong>定义：</strong> 希望访问受保护资源的应用程序。可以是Web应用、移动应用、桌面应用或服务器端应用。</li><li><strong>作用：</strong> 代表资源所有者向资源服务器请求访问受保护资源。客户端必须预先在授权服务器注册，获得client_id和client_secret。</li></ul><h4 id=23-授权服务器authorization-server>2.3 授权服务器（Authorization Server）<a hidden class=anchor aria-hidden=true href=#23-授权服务器authorization-server>#</a></h4><ul><li><strong>定义：</strong> 负责验证资源所有者身份，并在资源所有者同意后，向客户端颁发访问令牌（Access Token）。</li><li><strong>作用：</strong> 是OAuth 2.0流程的枢纽。它处理用户的认证和授权，管理客户端的注册，并颁发不同类型的令牌。</li></ul><h4 id=24-资源服务器resource-server>2.4 资源服务器（Resource Server）<a hidden class=anchor aria-hidden=true href=#24-资源服务器resource-server>#</a></h4><ul><li><strong>定义：</strong> 存储并提供受保护资源的服务器。</li><li><strong>作用：</strong> 接收客户端的资源请求，通过验证请求中携带的访问令牌的有效性来决定是否允许访问资源。</li></ul><h3 id=3-oauth-20的四种主要授权模式grant-types>3. OAuth 2.0的四种主要授权模式（Grant Types）<a hidden class=anchor aria-hidden=true href=#3-oauth-20的四种主要授权模式grant-types>#</a></h3><p>OAuth 2.0定义了多种授权模式（Grant Types），以适应不同类型的客户端和应用场景。每种模式都有其特定的工作流程和安全考量。</p><h4 id=31-授权码模式authorization-code-grant>3.1 授权码模式（Authorization Code Grant）<a hidden class=anchor aria-hidden=true href=#31-授权码模式authorization-code-grant>#</a></h4><ul><li><strong>特点：</strong> 这是最常用、最安全、也是推荐用于<strong>Web服务器端应用</strong>的授权模式。</li><li><strong>流程概述：</strong><ol><li><strong>客户端请求授权：</strong> 客户端引导用户到授权服务器进行授权。</li><li><strong>资源所有者授权：</strong> 用户在授权服务器上登录并同意授权请求。</li><li><strong>授权服务器颁发授权码：</strong> 授权服务器将一个<strong>授权码（Authorization Code）</strong> 重定向回客户端（通过客户端预注册的重定向URI）。</li><li><strong>客户端使用授权码换取令牌：</strong> 客户端（服务器端）使用授权码和其client_secret（客户端凭证）向授权服务器的令牌端点（Token Endpoint）发起请求，交换访问令牌。</li><li><strong>授权服务器颁发令牌：</strong> 授权服务器验证授权码和客户端凭证，然后颁发<strong>访问令牌（Access Token）<strong>和可选的</strong>刷新令牌（Refresh Token）</strong>。</li><li><strong>客户端使用令牌访问资源：</strong> 客户端使用访问令牌向资源服务器请求受保护资源。</li></ol></li><li><strong>安全性：</strong> 授权码通过浏览器传递，但访问令牌的交换发生在客户端服务器和授权服务器之间（后端通信），客户端凭证得以保密，避免泄露。刷新令牌可用于获取新的访问令牌，延长会话而无需用户重新授权。</li><li><strong>适用场景：</strong> 传统的Web服务器端应用（如Java Spring Boot应用、Node.js应用）。</li></ul><pre tabindex=0><code class=language-mermaid data-lang=mermaid>sequenceDiagram

    participant C as 客户端 (Web服务器端应用)
    participant U as 用户 (资源所有者)
    participant AS as 授权服务器
    participant RS as 资源服务器

    C-&gt;&gt;AS: 1. 引导用户到授权服务器进行授权
    U-&gt;&gt;AS: 2. 登录并同意授权请求
    AS--&gt;&gt;C: 3. 重定向授权码 (Authorization Code) 回客户端
    C-&gt;&gt;AS: 4. 使用授权码和客户端凭证向令牌端点发起请求，交换访问令牌
    AS--&gt;&gt;C: 5. 颁发访问令牌 (Access Token) 和可选的刷新令牌 (Refresh Token)
    C-&gt;&gt;RS: 6. 使用访问令牌请求受保护资源
    RS--&gt;&gt;C: 7. 返回受保护资源
</code></pre><h4 id=32-隐式模式implicit-grant>3.2 隐式模式（Implicit Grant）<a hidden class=anchor aria-hidden=true href=#32-隐式模式implicit-grant>#</a></h4><ul><li><strong>特点：</strong> 专为<strong>单页应用（SPA）<strong>和</strong>原生移动应用</strong>设计，其特点是直接在浏览器端或移动应用中获取访问令牌。</li><li><strong>流程概述：</strong><ol><li><strong>客户端请求授权：</strong> 客户端引导用户到授权服务器进行授权。</li><li><strong>资源所有者授权：</strong> 用户在授权服务器上登录并同意授权请求。</li><li><strong>授权服务器直接颁发令牌：</strong> 授权服务器将<strong>访问令牌</strong>直接作为URI片段（#access_token=&mldr;）重定向回客户端。</li><li><strong>客户端使用令牌访问资源：</strong> 客户端从URI中解析出访问令牌，并使用它访问资源服务器。</li></ol></li><li><strong>安全性：</strong> 令牌直接在浏览器URI中暴露，没有刷新令牌，安全性较低。在公共客户端（Public Clients，如SPA）中，客户端凭证无法安全存储。<strong>在OAuth 2.1中已被弃用，推荐使用带PKCE（Proof Key for Code Exchange）的授权码模式替代。</strong></li><li><strong>适用场景：</strong> 早期用于SPA和移动应用，但现在<strong>不推荐使用</strong>。</li></ul><h4 id=33-客户端凭证模式client-credentials-grant>3.3 客户端凭证模式（Client Credentials Grant）<a hidden class=anchor aria-hidden=true href=#33-客户端凭证模式client-credentials-grant>#</a></h4><ul><li><strong>特点：</strong> 这种模式不涉及资源所有者（用户）的参与，而是用于客户端（通常是服务器端应用或服务）直接以自身身份向资源服务器请求访问。</li><li><strong>流程概述：</strong><ol><li><strong>客户端请求令牌：</strong> 客户端使用其client_id和client_secret直接向授权服务器的令牌端点请求访问令牌。</li><li><strong>授权服务器颁发令牌：</strong> 授权服务器验证客户端凭证，然后颁发<strong>访问令牌</strong>。</li><li><strong>客户端使用令牌访问资源：</strong> 客户端使用访问令牌向资源服务器请求受保护资源。</li></ol></li><li><strong>安全性：</strong> 客户端凭证必须得到严密保护，仅适用于高度受信任的服务器端客户端。</li><li><strong>适用场景：</strong> 服务间调用（Service-to-Service Communication），例如一个微服务需要访问另一个微服务的API。</li></ul><h4 id=34-密码模式resource-owner-password-credentials-grant>3.4 密码模式（Resource Owner Password Credentials Grant）<a hidden class=anchor aria-hidden=true href=#34-密码模式resource-owner-password-credentials-grant>#</a></h4><ul><li><strong>特点：</strong> 客户端直接要求资源所有者提供其用户名和密码，然后客户端将这些凭证发送给授权服务器以获取访问令牌。</li><li><strong>流程概述：</strong><ol><li><strong>客户端收集凭证：</strong> 客户端向用户请求用户名和密码。</li><li><strong>客户端发送凭证换取令牌：</strong> 客户端将用户名、密码和其client_id和client_secret（可选）发送给授权服务器的令牌端点。</li><li><strong>授权服务器颁发令牌：</strong> 授权服务器验证用户凭证和客户端凭证，然后颁发<strong>访问令牌</strong>和可选的<strong>刷新令牌</strong>。</li><li><strong>客户端使用令牌访问资源：</strong> 客户端使用访问令牌访问资源服务器。</li></ol></li><li><strong>安全性：</strong> <strong>这是最不安全的模式。</strong> 用户的真实密码直接暴露给客户端。这违背了OAuth 2.0不共享凭证的核心目标。</li><li><strong>适用场景：</strong> 仅在客户端高度可信（例如，授权服务器自身的第一方应用）且其他模式不可用时作为<strong>最后的选择</strong>。<strong>通常不推荐使用。</strong></li></ul><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><p>OAuth 2.0是一个强大而灵活的授权框架，它通过将授权过程中的各个角色职责分离，并引入访问令牌的概念，实现了安全、可控的委托授权。理解其背景、核心角色以及四种主要授权模式（授权码、隐式、客户端凭证、密码）是掌握其精髓的第一步。</p><p>通过这些授权模式，客户端能够安全地获取代表用户访问资源的凭证，而无需直接处理用户敏感的登录凭证。然而，OAuth 2.0的强大远不止于此，其核心还在于它所颁发的<strong>令牌（Token）</strong>，以及令牌背后所承载的<strong>授权范围（Scope）</strong>。这些要素共同构成了OAuth 2.0体系的安全基石，并需要结合一系列<strong>安全最佳实践</strong>才能发挥最大效用。</p><p>在下一篇中，我们将深入探讨OAuth 2.0中的<strong>令牌机制、作用域的概念</strong>，并分享一些<strong>重要的安全最佳实践</strong>，以帮助您更全面地理解和应用这一授权框架。</p><h3></h3><p><strong>欢迎关注+点赞+推荐+转发</strong></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bsong2015.github.io/blog/>万年水的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>