<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>技术实践 | 万年水的博客</title><meta name=keywords content><meta name=description content="编程与系统开发笔记"><meta name=author content><link rel=canonical href=https://bsong2015.github.io/blog/posts/technology/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://bsong2015.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bsong2015.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bsong2015.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://bsong2015.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://bsong2015.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://bsong2015.github.io/blog/posts/technology/index.xml><link rel=alternate hreflang=zh href=https://bsong2015.github.io/blog/posts/technology/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://bsong2015.github.io/blog/posts/technology/"><meta property="og:site_name" content="万年水的博客"><meta property="og:title" content="技术实践"><meta property="og:description" content="编程与系统开发笔记"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="技术实践"><meta name=twitter:description content="编程与系统开发笔记"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bsong2015.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"技术实践","item":"https://bsong2015.github.io/blog/posts/technology/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bsong2015.github.io/blog/ accesskey=h title="万年水的博客 (Alt + H)">万年水的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bsong2015.github.io/blog/posts/artificial-intelligence/ title=人工智能><span>人工智能</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/reading/ title=阅读><span>阅读</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/thinking-models/ title=思维模型><span>思维模型</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/thought-experiments/ title=思想实验><span>思想实验</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/personal-growth/ title=个人成长><span>个人成长</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/technology/ title=技术><span class=active>技术</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/current-affairs/ title=时事><span>时事</span></a></li><li><a href=https://bsong2015.github.io/blog/posts/others/ title=其它><span>其它</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>技术实践</h1><div class=post-description>编程与系统开发笔记</div></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>在刻度与脉搏间感知世界：你的“数字敏感性”有多少？ 想象一下，如果生命可以被具象化为一个数字，大概是 不到四万天。
这是一个关于“天数”的刻度。
它庞大得足以容纳无数日升月落、悲欢离合。
又微小得让人警醒，时间从指间溜走的速度，比我们以为的要快得多。
四万天。这个数字本身，就带着一种沉甸甸的重量，一种独属于生命的尺度。
当时间的刻度遇上性能的脉搏 然而，在数字世界里，我们又面对着另一套截然不同的数字体系。
快到几乎无法感知。
比如，当你敲下回车键，一个简单的数据库查询请求发出。
如果背后是 MySQL，优秀的工程师会让它在 10毫秒 (ms) 内返回结果。
10毫秒，是四万天的四亿分之一。
如果数据在内存里，像是大脑的瞬时记忆，比如通过 Redis 查询。
这个速度可以压缩到 1毫秒 (ms)，甚至 微秒 (μs) 级别。
1毫秒，是四万天的四十亿分之一。
这是系统的“脉搏”，强劲、迅捷，支撑着整个数字世界的流畅运转。
用户无感等待的背后，是工程师们对这些极小数字的斤斤计较。
多10毫秒，页面加载可能就慢一点；多100毫秒，用户可能就流失了。
这些数字，藏在代码深处，却是用户体验最直观的感受。
什么叫“数字敏感性”？ 这就是我们今天要聊的—— “数字敏感性”。
它不仅仅是知道这些数字是什么。
更是一种能力：
去 感知 这些数字背后的 意义、尺度和影响。
它意味着当你看到“不到四万天”，你能感受到生命的珍贵和紧迫，而不是一个冰冷的统计值。
它意味着当你听到“10毫秒”或“1毫秒”，你不仅仅理解它的时间长短，更能联想到背后复杂的工程、极致的优化，以及它对用户流畅体验的关键作用。
这是一种跨越不同领域的感知力。
从宏观的生命周期，到微观的系统性能。
从看得见摸得着的世界，到代码和数据构筑的隐形宇宙。
从生活到代码，处处是数字的低语 这种敏感性，体现在生活的方方面面。
一个好的设计师，知道字体大小、行间距的微小变化如何影响阅读感受。
一个优秀的运营人，懂得转化率小数点后一位的提升，可能意味着巨大的商业价值。
一个资深的开发者，不仅关注功能实现，更对接口响应时间、内存占用、并发连接数这些数字保持高度警惕。
这些数字，是世界运行的参数，是效率的度量衡，是问题的预警信号。
拥有数字敏感性的人，能听到这些数字的“低语”，提前发现趋势，优化体验，解决问题。
他们不只是看数字，而是在 感受 数字。
感受四万天里有限的可能性，感受10毫秒里蕴藏的汗水与智慧。
培养你的数字感知触角 在这个由数据和算法编织的时代，数字敏感性越来越重要。
它不是数学天赋，而是一种 对数字关联性、尺度感、以及其背后真实世界映射的洞察。
如何培养它？
从身边的数字开始。
你的手机使用时长、步数、App 消耗的流量、电脑的内存占用…
尝试去理解这些数字代表着什么，它们如何影响你的生活或工作。
当你面对一个技术名词或一个商业指标时，别只停留在概念，问问自己：
“这个数字大概是多大？它的量级如何？在什么范围内算好？差一点或好一点会有什么后果？”
将抽象的数字，锚定到具体的感受或结果上。
结语：做一个对数字有感觉的人 不到四万天，提醒我们去热爱和珍惜。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/01-%E6%95%B0%E5%AD%97%E6%95%8F%E6%84%9F%E6%80%A7/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>第10篇：权限控制的经典：基于角色的访问控制（RBAC）模型详解 在之前的文章中，我们详细探讨了身份认证（Authentication）的各种机制，解决了“你是谁？”的问题。然而，仅仅验证了用户的身份是不够的，我们还需要回答更关键的问题：“你能做什么？”这正是授权（Authorization） 的核心任务。授权决定了已认证的用户对系统中的哪些资源拥有何种操作权限。
在众多的授权模型中，基于角色的访问控制（Role-Based Access Control，简称RBAC） 无疑是最为经典和广泛应用的一种。它通过引入“角色”这一中间层，极大地简化了权限管理，并提升了系统的安全性和可维护性。
1. RBAC的核心概念：用户、角色、权限与会话 RBAC模型的核心在于将权限直接赋给用户，转变为将权限赋给角色，再将角色赋给用户。这种间接管理方式带来了巨大的灵活性和可伸缩性。
1.1 用户（User） 定义： 在RBAC模型中，用户是实际操作系统的实体，可以是个人、应用程序或服务账户。
在RBAC中的作用： 用户是权限的最终执行者。用户通过分配获得一个或多个角色，从而继承了这些角色所关联的权限。
1.2 角色（Role） 定义： 角色是一组具有逻辑关联的权限的集合，代表了某个职能或部门在系统中所需执行的任务。例如，“销售经理”、“财务主管”、“系统管理员”等。
在RBAC中的作用： 角色是RBAC模型的核心。它充当了用户与权限之间的桥梁。权限不直接分配给用户，而是先分配给角色，然后将用户分配给角色。这种抽象极大地简化了权限管理：当用户的职责变化时，只需调整其角色分配，而无需修改大量独立的权限。
1.3 权限（Permission/Privilege） 定义： 权限是系统允许执行的特定操作或对特定资源（对象）的访问能力。通常表示为“对某个资源执行某个操作”。例如，“读取客户信息”、“修改订单”、“删除用户”等。
在RBAC中的作用： 权限是授权的基本粒度。权限是原子性的，是最小的可授予单位。RBAC通过将这些原子权限组合成角色，从而实现更高级别的管理。
1.4 会话（Session） 定义： 会话代表了用户在某个特定时间点激活的角色集合。
在RBAC中的作用： 当用户登录系统时，他们可能被分配了多个角色。但在一个特定的会话中，用户可能只激活其中一部分角色。会话用于在用户当前访问上下文中，确定其具体可用的权限。
2. RBAC模型的变种：从基础到复杂 RBAC模型并非单一不变，而是存在一系列层次，从最基础的RBAC0到更复杂的RBAC1、RBAC2和RBAC3，它们在继承性、约束条件等方面有所区别。
2.1 RBAC0：核心RBAC 特点： 这是RBAC模型的最基本形式，定义了用户、角色和权限以及它们之间的分配关系。 用户可以被分配给一个或多个角色。 角色可以包含一个或多个权限。 用途： 适用于简单的权限管理场景，但缺乏角色继承和权限分离等高级功能。 2.2 RBAC1：带角色继承的RBAC（Hierarchical RBAC） 特点： 在RBAC0的基础上引入了角色继承（Role Hierarchy） 的概念。角色之间可以形成上下级关系，子角色自动继承父角色的所有权限。 例如，“部门经理”角色可以继承“普通员工”角色的所有权限，并在此基础上增加管理权限。 用途： 极大简化了拥有递进权限层级的组织结构（如公司层级、部门层级）的权限管理，减少了重复的权限配置。 2.3 RBAC2：带约束的RBAC（Constrained RBAC） 特点： 在RBAC0的基础上增加了各种约束（Constraints） 条件，以满足更复杂的安全策略和业务需求。这些约束可以是： 职责分离（Separation of Duty, SoD）： 强制用户不能同时拥有冲突的角色，以防止潜在的欺诈或错误。例如，一个用户不能同时拥有“创建订单”和“批准支付”的角色。 基数约束（Cardinality Constraints）： 限制用户可以拥有的角色数量、角色可以拥有的权限数量、角色中用户的最大数量等。 先决条件（Prerequisite Roles）： 在分配某个角色之前，用户必须先拥有另一个或某些角色。 用途： 适用于需要严格控制风险、防止内部欺诈、符合审计和合规性要求的复杂业务场景。 2.4 RBAC3：统一RBAC（Unified RBAC） 特点： RBAC3是RBAC1（角色继承）和RBAC2（约束）的结合体，提供了最全面的RBAC功能。 用途： 适用于大型、复杂的企业级应用，能够应对最严格的权限管理需求。 3. RBAC的设计原则与实践 成功的RBAC实施需要遵循一些设计原则和最佳实践：
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC10%E7%AF%87%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E7%9A%84%E7%BB%8F%E5%85%B8%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6rbac%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>第11篇：更精细的授权：基于属性的访问控制（ABAC）模型解析 在上一篇文章中，我们详细讲解了基于角色的访问控制（RBAC）模型，它通过将权限与角色关联，再将角色分配给用户，极大地简化了权限管理。然而，在面对日益复杂、动态变化的业务场景时，仅仅依靠预定义的角色可能显得力不从心。例如，“一个部门经理只能查看其本部门员工的绩效报告”——这个“本部门”的限制，是RBAC难以直接表达的。
为了实现更灵活、更细粒度、更动态的授权决策，基于属性的访问控制（Attribute-Based Access Control，简称ABAC） 模型应运而生。ABAC不依赖于固定的角色，而是通过评估请求中各种属性（如用户属性、资源属性、环境属性）来做出访问决策。
1. ABAC的核心概念：属性与策略 ABAC模型的核心在于“属性（Attributes）”和“策略（Policies）”。它通过定义一系列策略规则，这些规则基于主体、资源和环境的属性来决定是否允许访问。
1.1 主体属性（Subject Attributes） 定义： 描述尝试访问资源的用户或实体自身的属性。这些属性定义了“谁”在尝试访问。
示例：
用户ID： user:id="alice" 角色（RBAC中的角色也可以作为ABAC的一个属性）： user:role="manager" 部门： user:department="sales" 地理位置： user:location="shanghai" 雇佣类型： user:employmentType="full-time" 安全级别： user:securityLevel="confidential" 1.2 资源属性（Resource Attributes） 定义： 描述用户尝试访问的资源本身的属性。这些属性定义了“什么”被访问。
示例：
资源类型： resource:type="document" 资源ID： resource:id="report_Q2_2024" 所有者： resource:owner="alice" 密级： resource:classification="top_secret" 部门： resource:department="finance" 创建日期： resource:createDate="2024-05-01" 1.3 环境属性（Environment Attributes） 定义： 描述访问发生时所处的上下文环境的属性。这些属性定义了“何时”、“何地”、“如何”访问。
示例：
时间/日期： environment:timeOfDay="business_hours", environment:date="2024-06-30" 网络位置： environment:ipAddress="192.168.1.x" (来自内部网络) 设备类型： environment:deviceType="corporate_laptop" 会话强度： environment:authenticationStrength="MFA_enabled" 操作类型： action:type="read", action:type="write" 1.4 策略（Policy） 定义： 策略是ABAC的核心。它是一组规则，通过评估主体属性、资源属性和环境属性来做出授权决策（允许或拒绝）。策略通常以某种结构化的语言（如XACML - eXtensible Access Control Markup Language）表达。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC11%E7%AF%87%E6%9B%B4%E7%B2%BE%E7%BB%86%E7%9A%84%E6%8E%88%E6%9D%83%E5%9F%BA%E4%BA%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6abac%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>第12篇：策略即代码：初探基于策略的访问控制（PBAC）与XACML 在之前的文章中，我们讨论了RBAC（基于角色的访问控制）和ABAC（基于属性的访问控制）。RBAC通过预定义的角色简化了权限管理，而ABAC则通过评估运行时属性实现更精细和动态的授权。本篇，我们将进一步探讨一种将授权逻辑推向“策略即代码”境界的模型——基于策略的访问控制（Policy-Based Access Control，简称PBAC），以及实现PBAC的行业标准XACML。
PBAC的核心思想是将所有的授权规则表达为结构化的、可机器解析的策略，并由专门的引擎进行评估和执行。这使得授权逻辑可以像代码一样被管理、版本控制和自动化。
1. 策略即代码：PBAC的核心思想 基于策略的访问控制（PBAC） 是一种授权范式，它将授权决策从应用程序的业务逻辑中解耦出来，通过定义一套明确的、可执行的策略（Policies） 来驱动访问决策。
PBAC的理念可以概括为“策略即代码”：
策略是核心： 所有的授权规则都表现为具体的策略，这些策略清晰地定义了在什么条件下，谁可以对什么资源执行什么操作。 可外部化： 授权逻辑不再硬编码在应用内部，而是以独立的策略文件或服务形式存在。这意味着你可以不修改应用程序代码就改变授权逻辑。 可自动化： 策略可以用机器可读的语言编写，方便自动化工具进行管理、部署、测试和审计。 可审计性： 策略的清晰定义使得授权决策的依据一目了然，极大地提升了审计和合规性。 PBAC与ABAC的关系非常紧密。事实上，PBAC是ABAC的一种高级实现形式，它提供了将ABAC中基于属性的规则（如“如果主体部门是资源部门，且操作是读取，则允许”）以结构化、标准化的策略语言表达和执行的框架。可以说，ABAC是决策模型，而PBAC是实现这个模型的具体方法论和技术体系。
2. XACML：PBAC的工业级标准 为了标准化PBAC的实现，OASIS（结构化信息标准促进组织） 制定了XACML（eXtensible Access Control Markup Language，可扩展访问控制标记语言） 标准。XACML是一个声明式语言，用于表达访问控制策略，并定义了一个体系结构，规范了授权决策的各个组件及其交互方式。
XACML提供了一种强大且灵活的方式来编写复杂、细粒度的访问控制策略。它允许策略包含以下逻辑：
目标（Target）： 策略适用的主体、资源和操作的初始匹配条件。 规则（Rule）： 具体执行“允许”或“拒绝”决策的条件逻辑。 效应（Effect）： 如果规则满足，是“允许”（Permit）还是“拒绝”（Deny）。 条件（Condition）： 结合属性和函数进行更复杂的逻辑判断。 规则组合算法（Rule Combining Algorithm）： 当多个规则适用时，如何得出最终决策（例如，是“先拒绝”原则还是“先允许”原则）。 策略集（Policy Set）： 多个策略的集合，也可以有自己的策略组合算法。 3. XACML的核心架构组件 XACML定义了一个明确的授权体系结构，包含以下四个主要组件，它们协同工作来完成访问控制决策：
3.1 策略执行点（Policy Enforcement Point, PEP） 作用： PEP是离应用程序最近的组件，负责拦截用户对资源的访问请求。它就像一个“门卫”，在用户尝试进入时进行检查。 职责： 拦截请求： 当应用程序收到用户对受保护资源的请求时，PEP会拦截这个请求。 生成访问请求： PEP将访问请求转换为XACML格式的访问请求上下文（Access Request Context），其中包含了请求中所有相关的主体属性、资源属性、环境属性和操作属性。 发送到PDP： PEP将这个XACML格式的访问请求发送给策略决策点（PDP）。 执行决策： 接收PDP返回的访问决策（Permit/Deny/NotApplicable/Indeterminate），并据此强制执行（允许或拒绝访问）。 3.2 策略决策点（Policy Decision Point, PDP） 作用： PDP是XACML架构的核心，它负责接收PEP的访问请求，并根据预定义的XACML策略集做出授权决策。它就像一个“中央决策大脑”。 职责： 接收请求： 从PEP接收XACML访问请求上下文。 获取策略： 加载并识别所有相关的XACML策略和策略集。 获取属性： 如果请求上下文中缺少做出决策所需的某些属性，PDP会请求策略信息点（PIP）来获取这些属性。 评估策略： 根据XACML策略的规则和条件，评估所有属性，并根据策略组合算法得出最终的授权决策。 返回决策： 将最终决策（如Permit、Deny）返回给PEP。 3.3 策略信息点（Policy Information Point, PIP） 作用： PIP是属性数据的来源。当PDP在评估策略时发现缺少某些必要的属性信息（如用户的最新部门信息、资源的当前状态等），它会向PIP发出请求。PIP就像一个“数据源连接器”。 职责： 集成外部数据源： 连接到各种外部数据源，如LDAP目录、数据库、HR系统、微服务API、CRM系统等。 按需提供属性： 根据PDP的请求，从这些数据源中检索并提供所需的属性值，将其返回给PDP。 3.4 策略管理点（Policy Administration Point, PAP） 作用： PAP是负责创建、存储、管理、部署和维护XACML策略的组件。它就像一个“策略管理员”。 职责： 策略创作： 提供界面或API，允许管理员编写和修改XACML策略。 策略存储： 安全地存储策略，通常在一个策略存储库中。 策略分发： 将策略部署和分发给PDP。 策略版本控制： 管理策略的版本，支持回滚和审计。 策略测试与调试： 提供工具测试策略的有效性和预期行为。 XACML架构组件交互图示：
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC12%E7%AF%87%E7%AD%96%E7%95%A5%E5%8D%B3%E4%BB%A3%E7%A0%81%E5%88%9D%E6%8E%A2%E5%9F%BA%E4%BA%8E%E7%AD%96%E7%95%A5%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6pbac%E4%B8%8Exacml/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>第13篇：OAuth 2.0（上）：授权框架的核心流程与角色 在当今的数字生态系统中，我们经常遇到这样的场景：一个应用（例如，一个照片编辑工具）需要访问你在另一个服务（例如，Google相册）上的资源。你当然不希望把Google相册的用户名和密码直接告诉照片编辑工具，因为这不仅不安全，也意味着这个工具将拥有你账户的全部权限。
正是为了解决这种“委托授权”的问题，OAuth 2.0应运而生。它不是一个认证协议，而是一个授权框架，允许第三方应用在不获取用户凭证的情况下，安全地访问用户在服务提供者处的受保护资源。
1. OAuth 2.0的背景与目标 1.1 背景：为什么需要OAuth？ 在OAuth出现之前，应用程序访问用户资源的常见方式是 “共享凭证模式”：用户直接把自己在A网站的用户名和密码提供给B网站，让B网站以用户身份登录A网站并获取数据。这种模式存在巨大弊端：
安全风险高： B网站获取了用户的真实凭证，可以对A网站进行任何操作，包括未经授权的操作。如果B网站发生数据泄露，用户的A网站凭证也将暴露。 无法细粒度授权： 无法控制B网站只能访问特定资源或执行特定操作。 凭证生命周期管理困难： 用户无法方便地撤销B网站的访问权限，除非修改A网站密码，这会影响其他所有依赖该密码的应用。 OAuth 1.0在一定程度上解决了这些问题，但其复杂性限制了广泛应用。OAuth 2.0则在1.0的基础上进行了彻底的简化和改进，使其更易于实现和部署，成为现代API授权的事实标准。
1.2 目标：委托授权与安全解耦 OAuth 2.0的核心目标是实现委托授权（Delegated Authorization），即允许用户授权第三方应用（客户端）在限定的权限（作用域/Scope）内，代表用户访问其在资源服务器上的特定资源。
它旨在实现：
安全性： 用户凭证不直接暴露给第三方应用。 授权范围控制： 用户可以明确授权第三方应用访问哪些资源，以及进行哪些操作（通过Scope）。 便捷性： 用户授权过程简化，用户体验提升。 可撤销性： 用户可以随时撤销对第三方应用的授权，而无需修改密码。 2. OAuth 2.0的核心角色 OAuth 2.0框架中定义了四个核心角色，理解它们之间的交互是理解OAuth 2.0流程的关键：
2.1 资源所有者（Resource Owner） 定义： 拥有受保护资源的个人或实体。通常是最终用户。 作用： 授权客户端应用访问其在资源服务器上的资源。 2.2 客户端（Client） 定义： 希望访问受保护资源的应用程序。可以是Web应用、移动应用、桌面应用或服务器端应用。 作用： 代表资源所有者向资源服务器请求访问受保护资源。客户端必须预先在授权服务器注册，获得client_id和client_secret。 2.3 授权服务器（Authorization Server） 定义： 负责验证资源所有者身份，并在资源所有者同意后，向客户端颁发访问令牌（Access Token）。 作用： 是OAuth 2.0流程的枢纽。它处理用户的认证和授权，管理客户端的注册，并颁发不同类型的令牌。 2.4 资源服务器（Resource Server） 定义： 存储并提供受保护资源的服务器。 作用： 接收客户端的资源请求，通过验证请求中携带的访问令牌的有效性来决定是否允许访问资源。 3. OAuth 2.0的四种主要授权模式（Grant Types） OAuth 2.0定义了多种授权模式（Grant Types），以适应不同类型的客户端和应用场景。每种模式都有其特定的工作流程和安全考量。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC13%E7%AF%87oauth-2.0%E4%B8%8A%E6%8E%88%E6%9D%83%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E4%B8%8E%E8%A7%92%E8%89%B2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>第14篇：OAuth 2.0（下）：令牌（Token）、范围（Scope）与安全最佳实践 在上一篇文章中，我们介绍了OAuth 2.0作为授权框架的背景、核心角色以及四种主要的授权模式。我们了解到，OAuth 2.0的核心目标是在不共享用户凭证的前提下，安全地实现第三方应用对用户资源的访问。而实现这一目标的关键，正是其所颁发的各种令牌（Token） 以及对授权范围（Scope） 的精确控制。
本篇将深入探讨OAuth 2.0中的令牌类型、作用域概念，并重点讲解确保OAuth 2.0流程安全的关键机制和最佳实践，帮助你构建更健壮、更安全的授权体系。
1. 核心令牌类型：授权的凭证 OAuth 2.0主要定义了两种核心令牌，它们在授权流程中扮演着不同的角色：
1.1 访问令牌（Access Token） 定义： 访问令牌是客户端访问受保护资源的凭证。它是一个短生命周期的字符串，代表了用户授权客户端访问特定资源和执行特定操作的许可。 特性： 不透明性（Opaque）： 对于客户端而言，访问令牌通常是不透明的字符串（可以是随机字符串、JWT等）。客户端不需要解析其内部结构，只需将其作为凭证传递给资源服务器。 生命周期： 访问令牌通常具有较短的有效期（例如，几分钟到几小时）。过期后，客户端需要通过其他方式获取新的访问令牌。 承载者令牌（Bearer Token）： 大多数情况下，访问令牌是“承载者令牌”。这意味着任何持有该令牌的实体都可以访问相应的资源，如同持有现金一样。因此，访问令牌的保密性至关重要。 用途： 客户端在向资源服务器发送请求时，通常会在HTTP请求的"Authorization"头中携带访问令牌，例如：“Authorization: Bearer &lt;access_token>"。资源服务器会验证该令牌的有效性（包括是否过期、是否伪造、是否有权限），然后响应请求。 1.2 刷新令牌（Refresh Token） 定义： 刷新令牌是客户端用于获取新的访问令牌的凭证。它是一个长生命周期的令牌，通常只颁发给那些能够安全存储它的客户端（例如，服务器端应用）。 特性： 生命周期： 刷新令牌通常具有较长的有效期，甚至可以是永久的，直到被显式撤销或用户修改密码。 保密性： 由于刷新令牌的生命周期长，且能够获取新的访问令牌，其安全存储（通常在服务器端，不暴露给浏览器或移动应用）是至关重要的。 一次性使用或旋转： 为增强安全性，有些实现会强制刷新令牌在每次使用后即失效，并返回一个新的刷新令牌（刷新令牌旋转），以降低泄露风险。 用途： 当访问令牌过期时，客户端可以使用刷新令牌向授权服务器的令牌端点再次请求获取新的访问令牌（以及可能的新刷新令牌），而无需用户再次进行授权。这提升了用户体验，减少了用户重复登录的频率。 2. 精确授权范围：作用域（Scope）与用户同意（Consent） 2.1 作用域（Scope） 定义： Scope是OAuth 2.0中用于指定客户端所请求的访问权限范围的字符串。它定义了客户端可以访问哪些资源以及可以执行哪些操作。 重要性： Scope实现了最小权限原则。客户端不应获得超过其完成任务所需的权限。例如，一个客户端可能只请求“读取用户相册”的权限，而不是“修改用户所有数据”的权限。 示例： “read_photos”、“write_posts”、“email”、“profile"等。授权服务器会维护一个可用的Scope列表。 工作原理： 客户端在向授权服务器请求授权时，会带上其所需的"scope"参数。 授权服务器会根据客户端请求的Scope，向用户展示一个用户同意（Consent） 页面。 如果用户同意，授权服务器颁发的访问令牌将仅包含用户授权的Scope，资源服务器在验证令牌时也会检查其Scope是否满足请求操作所需权限。 2.2 用户同意（Consent） 定义： 用户同意是指在OAuth 2.0流程中，授权服务器向资源所有者展示一个明确的界面，说明客户端正在请求哪些权限（通过Scope），并征得用户的同意。 重要性： 用户同意是OAuth 2.0委托授权理念的直接体现。它确保用户对自己的数据和隐私拥有控制权，知道自己的数据将如何被第三方应用使用。 工作原理： 用户在授权服务器的同意页面上，可以看到客户端请求的"scope”，并选择“同意”或“拒绝”。只有当用户明确同意后，授权服务器才会继续颁发令牌。 3. OAuth 2.0安全最佳实践：铸就铜墙铁壁 尽管OAuth 2.0框架本身具有较高的安全性，但错误的实现或忽视某些安全细节仍可能导致严重漏洞。以下是一些重要的安全考量和最佳实践：
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC14%E7%AF%87oauth-2.0%E4%B8%8B%E4%BB%A4%E7%89%8Ctoken%E8%8C%83%E5%9B%B4scope%E4%B8%8E%E5%AE%89%E5%85%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>第15篇：OpenID Connect (OIDC)：在OAuth 2.0之上构建身份认证层 在前面的文章中，我们深入探讨了OAuth 2.0，了解到它是一个强大的授权框架，解决了“客户端应用如何安全地访问用户资源”的问题。然而，OAuth 2.0本身并不直接提供身份认证（Authentication） 功能，也就是说，它无法直接回答“当前登录的用户是谁”这个问题。
在实际应用中，尤其是在需要单点登录（SSO）的场景下，应用不仅需要获取用户的授权去访问资源，更需要确认用户的身份。这就是OpenID Connect (OIDC) 出现的背景。OIDC巧妙地构建在OAuth 2.0之上，为我们提供了一个简单、可互操作的身份认证层。
1. OIDC与OAuth 2.0的关系：授权之上的身份认证 OpenID Connect不是一个全新的协议，它是一个基于OAuth 2.0的身份认证层。可以这样理解：
OAuth 2.0： 是授权协议，目标是让第三方应用获得访问用户资源的权限。它回答的是“你（客户端）能替我（用户）做什么？” OpenID Connect： 是身份认证协议，目标是验证用户的身份，并获取用户的基本资料（User Profile）。它回答的是“当前登录的用户是谁？” OIDC的精髓在于，它利用了OAuth 2.0的授权流程（特别是授权码模式）来安全地分发代表用户身份的令牌。 当一个客户端（通常称为依赖方，Relying Party, RP）需要验证用户身份时，它会向OpenID Provider (OP)（即OAuth 2.0中的授权服务器）发起一个OAuth 2.0授权请求，OP在用户认证和授权后，除了返回OAuth 2.0的访问令牌（Access Token），还会返回一个额外的令牌——ID Token，其中包含了用户的身份信息。
这种关系使得OIDC既继承了OAuth 2.0的灵活性和安全性，又在其上增加了标准的身份认证机制，从而非常适合现代Web和移动应用的单点登录（SSO）场景。
2. ID Token详解：用户的数字身份证 ID Token是OpenID Connect的核心。它是一个JSON Web Token (JWT)，包含了关于用户认证事件和用户身份的关键信息。对于依赖方（RP）来说，ID Token就是用户的数字身份证。
2.1 JWT结构回顾 JWT通常由三部分组成，用点（.）分隔：Header.Payload.Signature。
Header（头部）： 声明令牌的类型（JWT）和所使用的签名算法（如HS256、RS256）。 Payload（负载/内容）： 包含了一组声明（Claims），即关于实体（通常是用户）和额外数据的陈述。这是ID Token真正包含身份信息的部分。 Signature（签名）： 用于验证令牌的完整性，确保令牌在传输过程中没有被篡改。 2.2 ID Token中的核心Claims ID Token的Payload中包含了一系列标准化的Claims（声明），这些声明提供了用户的身份信息和认证上下文。
iss (Issuer)： 必选。ID Token的颁发者，通常是OpenID Provider的URL。RP会验证此值。 sub (Subject)： 必选。主题标识符，是OP为此用户分配的唯一标识。在OP的上下文中，此值在所有客户端中对该用户都是唯一的且不可重新分配。 aud (Audience)： 必选。ID Token的接收方，即依赖方（RP）的client_id。RP会验证此值，确保令牌是为其自身颁发的。 exp (Expiration Time)： 必选。JWT的过期时间戳。RP会检查此值，拒绝过期的令牌。 iat (Issued At)： 必选。JWT的签发时间戳。 auth_time (Authentication Time)： 可选。用户进行认证的时间。RP可以使用此值来判断用户上次认证的时间是否满足其安全策略。 nonce： 可选，但强烈推荐在授权码模式和隐式模式中使用。一个由RP生成，在认证请求中发送到OP，并在ID Token中返回的随机值。用于防止重放攻击和CSRF攻击。RP会验证此值是否与请求时发送的一致。 azp (Authorized Party)： 可选，但推荐在某些场景下使用。表示授权令牌的客户端ID，用于RP验证。 amr (Authentication Methods References)： 可选。指示用户认证时使用的认证方法列表（如pwd密码、mfa多因素认证、face面部识别等）。 acr (Authentication Context Class Reference)： 可选。指示用户认证的上下文级别或强度，例如，LoA2低安全级别，LoA3高安全级别。 c_hash (Code Hash) / at_hash (Access Token Hash)： 可选，用于隐式模式和混合模式，用于客户端验证授权码或访问令牌是否与ID Token相关联，防止令牌注入攻击。 2.3 ID Token的验证 依赖方（RP）收到ID Token后，必须对其进行严格验证，才能信任其中的身份信息：
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC15%E7%AF%87openid-connect-oidc%E5%9C%A8oauth-2.0%E4%B9%8B%E4%B8%8A%E6%9E%84%E5%BB%BA%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%B1%82/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>第16篇：企业级SSO的利器SAML 2.0协议详解 在上一篇文章中，我们深入探讨了OpenID Connect (OIDC) 如何在OAuth 2.0之上构建身份认证层，成为现代互联网和移动应用SSO的主流选择。然而，在企业级应用和组织间协作的场景中，尤其是一些传统或遗留系统，你可能更常听到另一个强大的SSO协议——SAML 2.0 (Security Assertion Markup Language)。
SAML 2.0是基于XML的开放标准，专门用于在不同安全域之间安全地交换认证和授权数据。它在企业级SSO领域扮演着举足轻重的角色，是许多大型企业内部应用以及企业与云服务（如Salesforce、Microsoft 365等）进行身份联邦的基石。
1. SAML 2.0的核心概念：信任的桥梁 SAML 2.0的核心在于构建一个信任联盟（Trust Federation），允许用户在一个信任域（通常是企业内部）完成认证后，无需重复登录即可访问另一个信任域（例如，一个外部SaaS应用）的资源。理解其核心概念是掌握SAML的关键。
1.1 身份提供者（Identity Provider, IdP） 定义： IdP是负责认证用户身份并生成SAML断言的实体。它就像一个“数字护照签发机构”。 职责： 接收用户的认证请求（例如，登录页面的用户名密码）。 验证用户凭证。 成功认证后，生成一个包含用户身份和属性信息的SAML断言（Assertion），并对其进行数字签名。 将SAML断言发送给服务提供者（SP）。 常见示例： 企业内部的Active Directory Federation Services (AD FS)、Okta、PingFederate、Azure AD等。 1.2 服务提供者（Service Provider, SP） 定义： SP是提供具体应用服务并依赖IdP进行用户认证的实体。它就像一个“边境检查站”，接收并验证数字护照。 职责： 接收用户的访问请求。 检测用户是否已认证。如果未认证，将用户重定向到IdP。 接收来自IdP的SAML断言。 验证SAML断言的有效性（包括签名、时间戳、受众等）。 根据断言中的用户身份信息，创建本地会话并允许用户访问应用。 常见示例： Salesforce、Microsoft 365、Workday、各种企业内部Web应用。 1.3 SAML 断言（SAML Assertion） 定义： SAML断言是SAML协议的核心，它是一个XML文档，包含了由IdP生成的关于用户身份和认证事件的声明（Statements）。它就像一份数字化的“身份证明”或“通行证”。 核心信息： 认证声明（Authentication Statement）： 声明了用户何时、何地以及如何被IdP认证。 属性声明（Attribute Statement）： 包含了用户的各种属性信息（Attributes），如姓名、邮箱、部门、角色等。这些属性可以用于SP进行授权决策或填充用户档案。 授权决策声明（Authorization Decision Statement）： 较少使用，可用于声明IdP对特定资源或操作的授权决策。 安全性： SAML断言必须由IdP进行数字签名，以确保其完整性和真实性，防止篡改。SP会使用IdP的公共证书来验证此签名。断言通常也会被加密传输。 2. SAML 2.0的两种主要工作流程 SAML 2.0主要定义了两种用户启动SSO的流程，它们决定了用户在未登录时首先访问哪一方。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC16%E7%AF%87%E4%BC%81%E4%B8%9A%E7%BA%A7sso%E7%9A%84%E5%88%A9%E5%99%A8saml-2.0%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>第17篇：自动化身份供给：SCIM协议如何简化用户管理 在之前的文章中，我们讨论了身份认证（Authentication）和授权管理（Authorization）的各种核心协议与模型。然而，一个完整的身份和访问管理（IAM）体系，不仅仅包括“谁能登录”和“谁能做什么”，还必须高效地解决“用户身份信息如何创建、更新和同步到各个应用”的问题。这正是身份供给（Identity Provisioning） 的职责所在。
想象一下，当一个新员工入职时，他需要访问公司的CRM、ERP、协作套件（如Office 365）等多个系统。如果每次都需要IT管理员手动在每个系统中创建账户、分配权限，这无疑是一项繁琐、耗时且容易出错的工作。当员工离职或部门调动时，手动管理带来的效率低下和安全风险（权限未及时撤销）将更加凸显。
SCIM（System for Cross-domain Identity Management）协议正是为了解决这一痛点而诞生的。它提供了一种标准化的方式，实现用户和组身份信息的自动化管理和跨域同步。
1. SCIM的目标：简化与标准化身份供给 SCIM是由IETF（互联网工程任务组）发布的一个开放标准，旨在简化和自动化用户和组身份信息在不同系统之间的交换。其核心目标可以概括为：
互操作性： 提供一个通用的、基于RESTful API的协议和JSON数据模型，使得任何支持SCIM的系统都能“开箱即用”地进行身份信息交换，避免了定制化开发带来的高成本和复杂性。 自动化： 实现用户生命周期管理（创建、更新、禁用、删除）的自动化，减少人工干预。 效率： 显著提升身份供给的效率，加速新员工入职、离职等流程。 安全性： 确保身份信息的准确性和及时性，降低因手动操作导致的权限配置错误和安全漏洞。 扩展性： 允许扩展核心的用户和组模式（Schema），以适应各种特定业务需求。 在现代的IDaaS（Identity as a Service） 解决方案中，SCIM扮演着至关重要的角色。IDaaS平台通常作为中央身份源，通过SCIM与下游的各种SaaS应用（如Salesforce, Slack, Google Workspace, Microsoft 365等）进行用户和组信息的自动化同步。
2. SCIM的核心资源：用户与组 SCIM协议定义了两个核心的资源类型，用于表示和管理身份信息：
2.1 用户（User）资源 定义： 代表了系统中的一个独立用户身份。 核心属性： SCIM User Schema定义了一套丰富的标准属性，包括： userName：用户的唯一登录名（必填）。 id：资源的唯一标识符。 displayName：用户的显示名称。 name：包含givenName（名）、familyName（姓）等子属性。 emails：用户的邮箱地址（可以是多个，带类型如work, home）。 active：布尔值，表示用户是否活跃/启用（用于禁用/启用用户）。 password：密码（敏感信息，通常只用于设置/重置，不用于读取）。 groups：用户所属的组列表（引用）。 扩展性： SCIM允许服务提供者通过自定义的扩展模式（Extension Schema） 来添加标准模式中没有的额外属性，以满足特定应用的业务需求，例如自定义的员工ID、组织架构信息等。 2.2 组（Group）资源 定义： 代表了一组用户的集合。组在权限管理中非常有用，可以方便地对一组用户统一分配权限。 核心属性： SCIM Group Schema定义了： displayName：组的显示名称。 members：组的成员列表，每个成员包含value（用户ID）和displayName（用户显示名）等。 SCIM通过这些标准化的资源和属性，确保了不同系统之间身份数据的一致性和可理解性。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC17%E7%AF%87%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BA%AB%E4%BB%BD%E4%BE%9B%E7%BB%99scim%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E7%AE%80%E5%8C%96%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>第18篇：老牌目录服务：LDAP协议基础与应用场景 在之前我们探讨的身份与访问管理（IAM）体系中，无论是用户认证、授权决策，还是身份供给，其核心都离不开对用户身份信息的存储和管理。这些信息需要被高效地查询、更新，并能够被各种应用服务共享。而承担这一重任的，正是目录服务。
在众多目录服务技术中，LDAP（Lightweight Directory Access Protocol，轻量级目录访问协议） 无疑是最古老、最成熟且应用最为广泛的标准之一。它在企业级IAM领域占据着举足轻重的地位，是许多传统系统和现代解决方案的基石。
1. 什么是LDAP？ LDAP是一种用于访问和维护分布式目录信息服务的应用层协议。简单来说，它就像一个专门存储和查询“白页”（例如，电话簿、员工花名册）的数据库，但它比传统数据库更专注于读取操作的效率，并针对层次化、树状结构的数据存储进行了优化。
LDAP目录服务通常用于存储：
用户账户信息： 用户名、密码哈希、电子邮件、电话号码、部门、职位等。 组信息： 组名称、成员列表。 网络资源信息： 打印机、服务器、共享文件等。 应用程序配置信息： 集中存储应用的配置参数。 2. LDAP的核心概念：构建目录的基石 LDAP目录中的数据以树状层级结构组织，类似于文件系统的目录结构。理解以下几个核心概念，是理解LDAP的关键：
2.1 目录项（Entry） 定义： 目录项是LDAP目录中存储的每一个独立的信息单元，类似于数据库中的一行记录或文件系统中的一个文件。每个目录项都代表一个真实世界的对象（如用户、组、设备等）。 特性： 每个目录项都有一个唯一的标识符，称为判别名（Distinguished Name, DN）。 2.2 属性（Attribute） 定义： 每个目录项由一系列属性组成，每个属性由一个**类型（Type）和一个或多个值（Value）**构成。属性描述了目录项的特征。 示例： cn (Common Name)：通用名，如John Doe。 sn (Surname)：姓，如Doe。 givenName：名，如John。 mail：电子邮件地址。 uid (User ID)：用户ID。 objectClass：必选属性，定义了目录项的类型和必须包含的属性集合。 Schema（模式）： LDAP目录遵循一定的Schema。Schema定义了目录中可以存储哪些objectClass，每个objectClass可以包含哪些属性，以及属性的语法（例如，字符串、整数、二进制）。 2.3 判别名（Distinguished Name, DN） 定义： DN是LDAP目录中唯一标识一个目录项的字符串。它明确了该目录项在目录树中的完整路径。DN由一系列相对判别名（Relative Distinguished Name, RDN） 组成，从最特定的（通常是目录项本身）到最不特定的（根目录）。 结构： RDN之间用逗号（,）分隔，顺序从左到右是从下往上（叶子到根）。 示例： cn=John Doe,ou=users,dc=example,dc=com cn=John Doe 是该目录项的RDN（Common Name为John Doe）。 ou=users 是其父目录的RDN（组织单元为users）。 dc=example,dc=com 是根域的RDN。 唯一性： DN在整个LDAP目录中必须是唯一的。 2.4 相对判别名（Relative Distinguished Name, RDN） 定义： RDN是DN中最左边（最具体）的部分，它唯一标识了在特定父目录项下的子目录项。 示例： 在 cn=John Doe,ou=users,dc=example,dc=com 中，cn=John Doe 就是该目录项的RDN。 graph TD A[LDAP 目录树] --> B(DN: Distinguished Name); B --> C(Entry: 条目); C --> D(Attribute: 属性); subgraph DN组成部分 E[DC: Domain Component] --> F(dc=com); F(dc=com) --> G(dc=example); G --> H(ou=users); H --> I(cn=John Doe); end B --- E; 3. LDAP的常用操作 LDAP协议定义了一系列用于访问和修改目录数据的标准操作：
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to " href=https://bsong2015.github.io/blog/posts/technology/%E7%AC%AC18%E7%AF%87%E8%80%81%E7%89%8C%E7%9B%AE%E5%BD%95%E6%9C%8D%E5%8A%A1ldap%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://bsong2015.github.io/blog/posts/technology/page/2/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://bsong2015.github.io/blog/>万年水的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>